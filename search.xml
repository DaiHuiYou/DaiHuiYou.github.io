<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件工程之美]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[什么是软件？软件的目标用户是面向用户，然而程序是面向硬件的。 看待问题的角度很多时候， 自己在分析问题时往往陷入细节中， 并不能迅速想出解决方案。 类似写作，并不是确定好一个题目， 自己想到哪，写到哪， 往往结果是离题了。好的做法应该是：确定好题目，确定好架构（即你要写的大概的内容），架构好了，最后去写就是了。 当用工程方式去思考，会更多站在整体而非局部去思考， 更有大局观。 everthing is project。 会议的价值你是砍材的，他是放羊的，你和他聊一天，他的羊吃饱了，你的材呢？ 反思在编写自己的函数时，仅仅假设一个特定样本数据的输入， 并满足该函数的输出要求，就马不停蹄实现下一个函数的定义。 完全没有考虑这函数的健壮性，即没有足够的样本数据进行单元测试， 这样的函数犹如建房子的砖瓦「够用就行」。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F06%2F06%2Fleetcode%2F</url>
    <content type="text"><![CDATA[数组vector&lt;int&gt;iterator::it = nums.begin(); nums.insert(nums.end(), 100); // 等价于 nums.push_back(100); nums.insert(nums.end(), anothernums.begin, anothernums.end()); // nums = nums + anothernums 排序 C++ sort() 时间复杂度 Sort() 因为它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高！ 果断放弃的自己造轮子， 来实现 时间复杂度为 O(n^2) 的冒泡或者选择算法。 ^_^ unordered_map在 unordered_map 中，键值通常用于唯一标识元素，而映射值是与该键关联的内容的对象。键和映射值的类型可能不同。 在内部，unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。 unordered_map 容器比映射容器更快地通过它们的键来访问各个元素，尽管它们通过其元素的子集进行范围迭代通常效率较低。 无序映射实现直接访问操作符（operator []），该操作符允许使用其键值作为参数直接访问映射值。 容器中的迭代器至少是前向迭代器。 关键词：无序的 快速的检索 达到的是更快的访问 但是子集的范围迭代效率低。]]></content>
  </entry>
  <entry>
    <title><![CDATA[OS]]></title>
    <url>%2F2019%2F05%2F28%2FOS%2F</url>
    <content type="text"><![CDATA[并发和并行并发： 同一「时间点」顺序执行，同一「时间段」交替重叠。 （本质性上也顺序执行，利用单个 CPU 实现宏观层面的并行） 并行：正真意义上并行，无论微观和宏观上都是并行。完全是多个 CPU 执行。 并发 VS 并行： 单个CPU VS 多个CPU 线程是处理机调度的基本单位结合我以前的经历，通常单片机的裸机程序的编程都是模块和模块之间的顺序执行，当一个模块因某种原因阻塞，从而导致接下来的模块不能执行而延迟响应，所以不能呈现出良好的实时性。 那么可以通过单片机的「硬件计时」，自己分配处理机的时间片，通过「中断」切换模块和模块之间的执行流程。进而实现模块和模块之间的并发执行。 裸机程序的模块间的并发类似与多线程，理解为模块间是手动分配处理机的执行时间， 而多线程是处理机调度的基本单位，是由操作系统依据特定算法分配线程的处理机执行时间。 只不过单片机未引入操作系统之前，需要自己要分配时间片和确定好中断流程，在操作系统中多线程这不需要这些操作，单纯调用语句就行了。 进程是资源调度的基本单位单片机通常是执行一个特定的程序（进程）， 不存在进程间的资源争斗问题，一个进程拥有在单片机的全部资源。 我认为多进程的引入是为了充分利用资源。怎么说，属于临界资源的打印机， 一个进程需要打印机资源， 另一个进程也需要打印机资源，并不能让两个进程在同一「时间段」拥有打印机资源。 多进程的实现，在宏观层面上实现进程间的资源共享。当然， 同一时间段， 进程间的资源不能共享。这需要资源分配策略 「 银行家算法的实现 」。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[程序设计：面向对象： 强调数据，名词为类，动词为该类的成员方法。 面向过程：整体到局部。 C++ 类方法和 C 函数的区别 在变量的角度 在 C 的函数中，只能使用 local variable（函数内部的所有变量），global variable （独立于该函数外的所有变量）。 在C++的 类方法中，可以使用 局部变量，可以使用属于对象的成员变量，可以使用属于类的静态成员变量，以及属于该文件的全局变量。 在数据输出的角度 C 的函数在执行后，通过形参 pointer 来返回结果 或 通过 return 返回结果。结果只能是局部变量的值或者全局变量。 C++的类方法在执行后，可以通过 形参 或者 return 输出 成员变量，静态成员变量， 全局变量，局部变量的值或引用。 对象调用成员方法和类调用成员方法：obj.func(): 对象调用成员方法，可能会改变对象状态，也就是说将对象中的成员变量的值因成员方法的调用而所改变。 Class.func(): 类调用成员方法， 由于类无成员变量， 静态成员变量除外。所以 类调用成员方法只是单纯调用函数。 内部类 内部类的拥有外围的所有元素的访问权限 头文件声明和类的声明C 的头文件的声明 和 C++ 的类的声明类似， 在 C 中，头文件声明变量和函数， 变量可在函数中使用。 在 c++ 中， 类的声明，成员变量和成员函数在 class 中声明， 通常一个文件包含一个类。 类的声明可以当做一个文件。 变与不变的问题 需求不可能是固定的，为了应对需求的改变， 避免以前代码推倒重写，这需要开闭原则（对外支持功能扩展，对已有的代码封闭） 写新代码，就不要修改旧的代码。 类的成员变量：不变 类的成员函数的形参：变 委托模式：接口不变，支持扩展功能。 适配器模式：功能相同，接口不同 策略模式：接口相同，功能不同 代理模式：引用技术，智能指针 装饰模式：不修改原有的代码，进行添加功能]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOCKET]]></title>
    <url>%2F2019%2F05%2F20%2FSOCKET%2F</url>
    <content type="text"><![CDATA[1. TCP连接的粘包问题由于TCP是面向连接，二进制流传输，由于 Send()是发送给操作系统的缓冲区，并不是立即发送给客户端，等缓冲区有一定大小，再一次性发送给客户端。 所以由于这样的机制，多次消息的发送，可能一次性消息的接受。导致粘包问题，即是多个消息粘在一起发送。 解决方法 发送一次消息，等待接受消息，即判断对方是否接受到消息，确定对方接受到了消息，再继续发送下一条消息。 2. 多媒体文件传输多媒体文件并不是文本文件，采取文本文件读取，对方接受到多媒体文件无法解码。所以文件读取的方式采取是二进制。 传输文件的方法 服务端：读取文件，连续 send()，直到发送完成。等待客户端接受完成消息。 客户端：接受服务端的消息，以二进制的方式存储到文件中，接受完成后，发送服务端接受完成消息。 3. 阻塞和非阻塞阻塞即是有消息则接受消息，没有消息则一直等待，不去执行其他操作。 在 TCP中 recv() 是采用阻塞方式接受。 非阻塞即有消息接受消息，没有消息则执行其他操作。 4. 多线程实现多个客户端连接多线程实现多个客户端连接，线程的数量等于客户端的数量， 当客户端连接数量大到一定程序，服务端容易崩溃。 5. Select模型实现多个客户端连接select 模型时 Winsock 中最常见的 I/0 模型， 它的中心思想是利用 select 函数，实现多个套接字 I/0 的管理。 利用 select 函数，可以判断套接字上是否存在数据，或则能否向一个套接字写入数据。 只有在条件满足时，才对套接字进行输出操作。 异步 I/0 模型通过调用 WSAAsynocSelect 函数实现，利用这个模型，应用程序可在一个套接字上接受以 windows 消息为基础的网络事件。 6. pingPING ，使用 ICMP 协议， 基于网络层， 包加上 源IP 和 目的IP， 在 数据链路层中加上源 MAC 地址和目的 MAC 地址，发送到局域网的另一台主机。]]></content>
      <categories>
        <category>SOCKET</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)1 . 选择排序// 未优化 template&lt;typename T&gt; void selectionSort1(T arr[], int n) { for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[i]) swap(arr[j], arr[i]); } } return; } // 优化 template &lt;typename T&gt; void selectionSort2(T arr[], int n) { for (int i = 0; i &lt;= n - 1; i++){ int minIndex = i; for (int j = i+1; j &lt;= n - 1; j++) { if (arr[minIndex] &gt; arr[j]) minIndex = j; } swap(arr[minIndex], arr[i]); } return; } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 selectionSort1 : 2.208 s selectionSort2 : 0.108 s 2. 插入排序// 未优化 template&lt;typename T&gt; void InsertionSort1(T arr[], int n) { for (int i = 1; i &lt; n; i++) { for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) { swap(arr[j], arr[j - 1]); } } } // 优化 template&lt;typename T&gt; void InsertionSort2(T arr[], int n) { for (int i = 1; i &lt; n; i++) { T e = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--) arr[j] = arr[j - 1]; arr[j] = e; } return; } 测试 从1万个 0~100 的随机数中，从小到大排序。 InsertionSort1 : 2.653 s InsertionSort2 : 0.064 s 3. 希尔排序// 希尔排序 template&lt;typename T&gt; // n 表示数组 capacity void shellSort(T arr[], int n) { int cnt = n - 1; // 数组元素个数 int tmp = 0; // 临时变量 // d：distance， for (int d = n/2; d&gt;=1; d=d/2) { // 遍历 for (int i = d; i &lt;=cnt; i++) { // 插入排序 tmp = arr[i]; for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) { arr[j + d] = arr[j]; arr[j] = tmp; } } } } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 Insertion Sort : 6.332 s Shell Sort : 0.029 s O(nlogN)1. 归并排序2. 快速排序int __partition(int arr[], int l, int r) { int v = arr[l]; int j = l; for (int i = l + 1; i &lt;= r; i++) { if (arr[i] &lt; v) { j++; swap(arr[i], arr[j]); } } swap(arr[j], arr[l]); return j; } void __quickSort(int arr[], int l, int r) { if (l &gt;= r) return; int p = __partition(arr, l, r); __quickSort(arr, l, p - 1); __quickSort(arr, p + 1, r); } // 快速排序 void quickSort(int arr[], int n) { __quickSort(arr, 0, n - 1); } 3. 堆排序void shiftDown(int arr[], int n, int k) { while (2 * k + 1 &lt; n) { int j = 2 * k + 1; if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) { j++; } if (arr[k] &lt; arr[j]) { swap(arr[k], arr[j]); k = j; } else break; } } void heapSort1(int arr[], int n) { // heapify for (int i = (n - 1) / 2; i &gt;= 0; i--) { shiftDown(arr, n, i); } for (int i = n - 1; i &gt; 0; i--) { swap(arr[0], arr[i]); shiftDown(arr, i, 0); } } // n 为数组元素个数 // k 当前要筛选的索引 // arr[0] 为临时存储变量 void shift(int arr[], int n, int k) { while (2 * k &lt; n) { int j = 2 * k; if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if (arr[k] &lt; arr[j]) { // arr[j] 与 arr[k] 交换 arr[0] = arr[j]; arr[j] = arr[k]; arr[k] = arr[0]; k = j; } else break; } } // n 为数组元素个数 // arr[0] 为临时存储变量 void heapSort2(int arr[], int n) { for (int i = (n - 1) / 2; i &gt;= 1; i--) { shift(arr, n, i); } for (int i = n - 1; i &gt;=2; i--) { // arr[i] 与 arr[1] 交换 arr[0] = arr[i]; arr[i] = arr[1]; arr[1] = arr[0]; shift(arr, i, 1); } } 测试 从100 万个 0~100 的随机数中，从小到大排序。 Heap Sort 1 : 2.228 s Heap Sort 2 : 0.248 s]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硅谷来信]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[收获比较大的方面： 学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。 科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 结论可以证实，但不可证伪。为什么呢？ 就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？ 总之， 因为未来的不确定，结论可以证实，不能证伪。 别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。 语录： 对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[编程规范 #ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; } 使用链表的例子： 页帧管理​ 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[for循环常用写法date: 2018-09-27 11:03:38 void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 循序栈和链式栈date: 2018-09-25 15:54:15 stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 线性表顺序存储和链式存储date: 2018-09-23 19:46:15 单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 基本概念date: 2018-09-22 14:22:10 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 ​ //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 二叉树表示算数表达式： 先序遍历： 前缀表示法 中序遍历： 中缀表示法 后序遍历： 后缀表示法 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。 图线性表中我们把数据元素叫元素，树中的数据元素叫结点，在图中数据元素，我们称之为顶点（Vertex）。 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。同样，在图的结构中，不允许没有顶点，在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。 图中，任意两个顶点你之间都可能有关系，顶点之间的逻辑关系用吧边表示，边集可以是空的。 连通图 在无向图 G 中， 如果对于图中任意两个顶点v1，v2都是连通的，则称 G 是连通图。 无向图中的极大连通子图称为连通分量。 有向图 G 中，如果对于每一对vi， vj， 从vi 到 vj 和 从 vj 到 vi都存在路径，则称 G 是强连通图。 邻接表 一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间的浪费。这个思路同样适用于图的存储，我们把这种数据与链表结合的存储方法称为邻接表。 顶点表的各个结点有 data 和 firstedge 两个域表示， data 是数据域，存储顶点信息，firstedge 是指针域，指向边表的第一个结点。 边表结点有 adjvex 和 next 两个域组成， adjvex 是邻接点域，存储某顶点的邻接点在顶点中的下标。 next 则存储指向表中下一个结点的指针。 有时为了便于确定顶点的入度或以顶点为弧头的弧， 有向图的逆连接表，即对每个顶点 v1 都建立一个链接为 v1 为 弧头的表。 邻接矩阵 图的邻接矩阵存方式是用两个数组来表示图。一个一维数组存图中顶点信息， 一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:daihuiyou/Material.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;daihuiyou&quot; git config -global user.eamil &quot;daihuiyou.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
