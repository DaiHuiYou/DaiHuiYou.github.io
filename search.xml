<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[资源]]></title>
    <url>%2F2018%2F12%2F17%2F%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[前端note ：前阿里架构师整理出来的资料 ps 链接: https://pan.baidu.com/s/1mjYbcJA 密码：pqdt HTML5+CSS3 从入门到精通.iso 链接: https://pan.baidu.com/s/1cUHz3o 密码：gdyw Javascript 视频教程 链接: https://pan.baidu.com/s/1i6eC5YP 密码：ku5k Jquery 视频教程 链接：https://pan.baidu.com/s/17DbNSnR3q5OGSjdw9tvCEA 密码：twcp Bootstrap 视频教程 链接: https://pan.baidu.com/s/1jKb2UDS 密码：wr8c Vue.js 链接: https://pan.baidu.com/s/1slYqBa1 密码：75xd Smarty 模板引擎视频教程 链接: https://pan.baidu.com/s/1smewom5 密码：v8vp Nodejs 链接: https://pan.baidu.com/s/1sm509GD 密码：fux1 Mysql 视频教程 链接: https://pan.baidu.com/s/1kVTdjcr 密码：e37d PHP 视频教程 链接: https://pan.baidu.com/s/1kWE0qZP 密码：xc4q oracle 视频教程 链接: https://pan.baidu.com/s/1i6jwpal 密码：hk6p nginx 视频教程 链接: https://pan.baidu.com/s/1nxccLg1 密码：x2q8 ajax 链接: https://pan.baidu.com/s/1dHctdXv 密码：jfwf mongodb 视频教程 链接: https://pan.baidu.com/s/1c3EE7U4 密码：7v8b Angular.js 链接: https://pan.baidu.com/s/1jJhYrEu 密码：ddci React 链接: https://pan.baidu.com/s/1nwnrQxb 密码：942g dedeCMS 织梦视频 链接: https://pan.baidu.com/wap/init?surl=bpQBCbP 密码：ikns ThinkPHP 视频教程 链接: https://pan.baidu.com/wap/init?surl=ggiKvYV 密码：7p5h 案例和总结 链接: https://pan.baidu.com/wap/init?surl=eTSNB5C 密码：5rx7 天猫商城购物车实战 链接: https://pan.baidu.com/wap/init?surl=smVjb7v 密码：cu4c Java 学科链接：https://pan.baidu.com/wap/init?surl=DtnDNv1p9ENZETLqIuKytw 密码：82lk Python 链接：https://pan.baidu.com/wap/init?surl=scBXSLdiTs9SBixdkykflw 密码：ck51 node.js 微信开发链接： https://pan.baidu.com/wap/init?surl=5tYBZ2yVz9aPO57LKqt7Mg 密码：jrwb 数据分析与挖掘高级工程师课程链接： https://pan.baidu.com/s/1me3jTNxoKY6mQkPE-KnJtw提取码：fe2a]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CET-6]]></title>
    <url>%2F2018%2F12%2F12%2FCET-6%2F</url>
    <content type="text"><![CDATA[2018.61.过去，拥有一辆私家车对大部分中国人而言是件奢侈的事。 In the past, having a private car is a luxury for most Chinese. 如今，私家车在中国随处可见。 Today, private cars are everywhere in China. 汽车成了人们生活中不可或缺的一部分，他们不仅开车上下班，还经常驾车出游。 Cars have become a indispensable part of people’s life. They not only drive to and from work, but also often drive out. 有些城市的汽车增长速度过快，以至于交通堵塞和停车位不足的问题日益严重，这些城市的市政府不得不出台新政策，限制上路汽车的数量。 In some cities, the growth rate of cars is so fast that the problem of traffic congestion and insufficient parking spaces is becoming more and more serious. the municipal governments of these have to introduce new policies to limit the number of cars the road. 由于空气污染日益严重，现在越来越多的人选择购买新能源汽车，中国政府也采取了一些措施，支持新能源汽车的发展。 Due to air pollution is increased serious. Nowadays, more and more people choose to buy new energy vehicles, The Chinese governments has also taken some measures to support the development of new energy vehicles. 2.自行车曾今是中国城乡最主要的交通工具，中国一度被称为”自行车王国“。 Bicycles used to be the most important means of transportations in urban and rural in China, China was once known as the “Bicycles Kingdom “. called “Bicycles Kingdom”. 如今，随着城市交通拥堵和空气污染日益严重，骑自行车又开始流行起来。 Today, with urban traffic congestion and increasing air pollution, cycling has become popular again. 近来，中国企业家将移动互联网技术与传统自行车结合在一起，发明了一种称为共享单车的商业模式。 Recently , Chinese entrepreneurs have combined Internet technology with traditional bicycles to invent a business model called “shared bicycles”. 共享单车的出现使骑车出行更加方便，人们仅需一部手机就可以随时使用共享单车。 The emergence of Shared bicycles make cycling more convenient and people can use shared bicycles at ant time with just one mobile phone. 为了鼓励人们骑车出行，很多城市修建了自行车道。 In order to encourage people to ride bicycles, many cities have built bicycles lands. 现在，越来越多的中国人也喜欢通过骑车健身。 Nowadays , more and more China also like to exercise by cycling . 3.中国目前拥有世界上最大最快的高速铁路网。 China currently has a most largest and fastest high-speed rail network in the world. 高铁列车的运行速度还将继续提升，更多的城市将修建高铁站。 The speed of high-speed rail will continue to increase, and many cities will built high-speed rail stations. 高铁大大缩短了人们出行的时间。 The high-speed rail has greatly shortened the time of people travel. 相对于飞机而言，高铁列车的速度的突出优势在于准时，因为基本不受天气或交通管制的影响。 Compared to aircraft, the outstanding advantage of the speed of the high-speed rail is on time, because of basically immune to weather or traffic control. 高铁极大地改变了中国人的生活方式。 The high-speed rail has most changed the way of people’s life. 如今，它已经成了很多人商务旅行的首选交通工具。 Today, It has become the preferred means of transportation for many people on business trips. 越来越多的人也在假日乘高铁外出旅游。 More and more people are traveling on high-speed rail on holiday. 还有不少年轻人选择在一个城市工作而临近城市居住，每天乘高铁上下班。 There are still many young people who choose to work in a city and live close to the city, taking high-speed rail to work every day. 2017.121.青海湖位于海拔 3205 米、青海省省会西宁以西约 100 公里处，是中国最大的咸水湖，面积 4317 平方公里，最深处 25.5 米。 Qing hai Lake, which located at about 100 kilometers west of Xining, the provincial capital of Qinghai Province , is the largest salt lake in China, at an altitude of 3205 meters. It has an area of 4317 square kilometers and a maximum depth of 25.5 meters. 有 23 条河注入湖中，其中大部分是季节性的。 There are 23 rivers flowing into Qinghai Lake, most of which are seasonal. 百分之八十的湖水源于五条主要河流。 Five main rivers provide 80% of total inflow. 青海湖位于跨越亚洲的几条候鸟迁徙路线的交叉处。 Qinghai Lake is situated at the intersection of several bird migration routes across Asia. 许多鸟类把青海湖作为迁徙过程中的栖息地。 Many species of birds take Qinghai Lake as a place to have a short rest during their migration. 湖的西侧是著名的 ”鸟岛“，吸引着来自世界各地的观鸟者。 The famous “Bird Island”, which lies west of Qinghai, is attracting birdwatcher from all over the world. 每天夏天，游客们也来这里观看国际自行车比赛。 Every Summer, tourists also flocks here to watch the international bicycles competition. 2017.61.唐朝始于 618 年，终于 907 年，是中国历史上最灿烂的时期。 The Tong Dynasty, which started in 618 and ended in 907, is considered as the most splendid period in China. 经过近三百年的发展，唐代中国成为世界上最繁荣的中国，其首都长安是当时世界上最大的都市。 Through nearly three hundred years of development, China in the Tong Dynasty became the most prosperous power in the world. Whose capital Chang’an was the largest metropolis around the world at that time. 这一时期，经济发达、商业繁荣、社会秩序稳定，甚至边境也对外开发。 During that period, The Tang Dynasty enjoyed economic boom, commercial prosperity, social stability, and even border open to the outside world. 随着城市化和财富的增加，艺术和文化也繁荣起来。 With urbanization and the increase the wealth, art and literature also boomed. 李白和杜甫是以作品简洁自然而著称的诗人。 Li Bai and Du Fu were poets who were famous for their concise and natural works. 他们的诗歌打动了学者和普通人的心。 Scholars and ordinary people were touched by their poem. 即使在今天，他们的许多诗歌仍广为儿童及成人阅读背诵。 Many of which are widely read and recited by children and adults even today. 2. 港珠澳大桥作为世界上最长的跨海大桥，这座 55 公里长的大桥历经 5 年规划、9年建设，被誉为“新世界七大奇迹”。 As the world’s longest sea-based project, the 55-kilometer bridge is the result of five years of the research and another nine years of building. It has been named as one of the “seven wonders of the modern world “ by the Guardian. 大桥包括了 22.9 公里的主体桥梁， 6.7 公里的海底隧道以及桥下的人工岛。 The project is make up of a 22.9 kilometer long main bridge, a 6.7 kilometer-long tunnel and artificial island off the bridge. “港珠澳大桥设计使用寿命长达120年. It is designed with a service life of 120 years. 与此同时，这座Y型大桥将香港到珠海、澳门的四小时车程缩短为45分钟左右。 Meanwhile, the Y-shaped bridge will reduce travel time from Hong Kong to Zhuhai and Macao from four hours to about 45 minutes. “港珠澳大桥的意义首先在于交通。此外，它在社会、经济、文化、旅游等方面也会发挥重要作用，”港珠澳大桥管理局副局长余烈在接受新华社采访时表示。 The bridge will not only be a transport, furthermore, it play a important role in society, economic, culture and tourism connection.]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学概论]]></title>
    <url>%2F2018%2F12%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[数据存储位（bit, binary digits) 循环移位：circular shift or rotation 逻辑移位：logical shift 算术移位: arithmetic shift AND : 屏蔽： masking 掩码：mask 十六进制计数法（hexadecimal notation) 控制器： controller 端口：port 1. 位和位存储触发器（flip-flop)是一个可以产生 0 或 1 输出值的电路，它的值会一直保持不变，除非其他电路过来的的临时脉冲使其改变成领一个值。 2. 主存储器计算机主存储器是以称为存储单元（cell）的可管理单位组织起来的， 虽然计算机中没有左或右的概念，但是我们通常假设存储单元的位是排成一行。 该行的左端称为高位端（high-oder end), 右端称为低位端（low-order end). 高位端的最左以为称为高位或最高有效为（most significant bit ）。 低位端的最右一端称为低位或最低有效位（least significant bit）。 3. 海量存储器存储映射输入/输出（memory-mapped I/O): 计算机与其他设备的通信通常是通过成为控制器的中间设备来处理的。 DMA(Direct Memory Access) 握手: handshaking ：计算机和外围设备之间交换设备状态的信息，协调它们之间的活动 状态字 status word: 它是由外围设备生成并发送给控制器的一个位模式。 流水线技术 piplinning: 增加计算机的吞吐量（throughtput) 并行处理技术：parallel processing : 流水线技术看做迈向并行处理技术的第一步，真正的并行处理技术需要多个处理单元，于是产生了多处理器计算机。 若干个处理单元连接到同一个处理器上， 其中每一个都像但处理器中的CPU。在这样的配置下，各处理器可以地理地工作，并通过把相关的信息放在公共存储单元来协调各自的工作。 MIMD: Multiple-Instruction steam, Multiple-Date stream 多指令流多数据流 体系结构。 多处理体系结构的一个变体是将多个处理器连接起来，使得它们一起执行同一个指令序列，每个处理器都有各自的的数据集。 这就是产生了SIMD( Single-Instruction stream, Multiple-Data stream )单指令流多数据流的体系结构。 操作系统执行程序需要大量的设备准备工作（job）， 批处理（batch processing )： 把若干个要执行的作业收集到一个批次中，然后执行而无需与用户进一步的交互。 它们允许执行一个程序来通过远程终端与用户对话， 这种特性称为交互式处理（interactive processing ) 计算机在一个期限内被强制执行任务，这一过程就是众所周知的实时处理（real-time processing ),并且动作的完成也是按实时方式发生。 设计同时给多个用户提供服务的操作系统，这一特点称为分时（time-sharing)，实现分时的一种方法就是应用被成为多道程序设计（multiprogramming )的技术。 如今， 多道程序设计即可用于单用户系统，也可以用于多用户系统，前者通常成为多任务（multitasking ). 1. 软件描述为了完成计算机用户请求的动作，操作系统必须能够与这些用户进行通信。 操作系统负责这种通信的部分称为用户界面（user interface). 老式的用户界面称为shell， 通过键盘与显示屏用文本信息与用户通信。更现代的系统利用 GUI（Graphical User Interface 图形用户界面）实现与用户通信。 内核的另一个组件是一组设备驱动程序（device driver），它们是负责与控制器通信（有时直接与外围设备通信） 在操作系统的内核中，还有一个组件就是内存管理程序（memory manager）， 它担负着协调和管理计算使用主存储器的任务。 2. 系统启动通过一个称为引导（boot strapping， 简称为booting）的过程实现，这个过程是由计算机每次启动的时候完成的。 引导程序（boot loader）被永久储存在机器的ROM中。这样在计算机开机的时候将最先执行这个程序。 引导程序的任务是引导CPU把操作系统从海量存储其中预先定义的位置调入主存。 一旦操作系统被放入主存，引导程序就引导CPU执行跳转指令，转到这个存储区中。 这时，操作系统接管并开始控制计算机的活动。执行引导程序和启动操作系统的整个过程称作启动（booting）计算机。 PC机的只读存储器还包括了一组例行程序，用于实现基本的输入/输出活动，固件（firmware），固件例行程序被引导程序使用，以便在操作系统开始工作前完成I/0活动。 得到广泛使用的固件系统包括PC中一直使用的BIOS（Basic Input/Output System， 基本输入/输出系统） 3. 协调机器的活动 进程的概念 在操作系统的控制下执行某个程序的活动称为进程（process）。与进程联系在一起的活动的当前状态称为进程状态（process state） 进程管理 与协调进程的执行有关的任务是有操作系统内核中的调度程序（scheduler）和分派程序（dispatcher) 处理的。 调度程序维护一个有关计算机系统中现存进程的记录（也就是进程池），将新的进程加入到该进程池中，并把已经完成的进程移出进程池。这样用户请求一个应用时，调度程序就把这个应用加到当前进程池加以执行。 允许每个进程一次执行一个时间片。这种从一个进程到另一个进程的改变过程成为进程切换（process switch）或者进程上下文切换（context switch）。 每个分派程序给进程分配一个时间片，它都会初始化一个计时器电路，通过产生一个中断（interrupt）信号来指示时间片的结束。 处理进程间的竞争 操作系统的一个重要任务就是将机器的各种资源（resource）分配给系统中的各个进程中。 为了控制对打印机的访问，操作系统必须跟踪打印机是否被分配。 信号量（semaphore)。 临界区（critical region）： 一个临界区一次只允许被一个进程执行，这个要求称为互斥（mutual exclusion） 来自机器内部的攻击 特权级别（privilege level） 特权指令（privilege instruction) 组网及因特网计算机网路通常分为LAN(Local Area Network, 局域网)、MAN（Metropolitan Area Network，城域网）和WAN（Wide Area Network，广域网） AP(Access Point，接入点），是协调所有通信的焦点。 集线器（hub） 中继器（repeater） ICANN(Internet Corporation for Assigned Names and Number)向英特网服务提供商提供了大量连续数组的 IP 地址。因特网名称与数字地址分配机构是一家非营利性的国际组织。 ISP(Internet Service Provider, 因特网服务提供商)， 第一层 ISP(tier-1 ISP), 第二层 ISP （tier-2 ISP) 第一层和第二层因特网服务提供商本质上是路由器的网络，集中提供因特网通信设施。它们同样可以称为是因特网的核心。 通常由称为因特网接入服务提供商（access ISP) 域名服务器（name server) DNS (Domain Name System, 域名系统）:域名服务器都共同作为因特网范围内的目录系统。 使用域名系统进行解析的过程称为域名系统查找（DNS Lookup). 应用层（application layer）、 传输层（transport layer）、网络层（network layer）、链路层（link layer） 链路层使用的协议 CSMA/CD 协议。 OSI: 国际标准化组织 程序设计语言将程序设计语言划分不同代， 是基于一个线性尺度的，对于一个语言的定位则是由这门语言的使用者不受机器世界语言约束的程序，以及允许从问题的角度来考虑的程度来决定的。实际上，程序设计语言的发展并不确切地遵循这种方式，而是沿着不同的可以选择的程序设计过程（称为程序设计范型， programming paradigm)发展。 命令性范型（imperative paradigm), 也叫过程范型(procedural paradigm). 说明性范型（declarative paradigm) 逻辑程序设计（logic programming) 函数式范型（functional paradigm) 基于该泛型的程序可以被看做是接受输入和产生输出的实体。数学家将这样的实体被称为函数。 面向对象泛型（Object-Oriented Paradigm) 遵照该泛型，一个软件系统被看做是对象（Object）的集合，每一个对象都能够执行与自己直接相关的动作以及其他对象请求的动作。 1.传统的程序设计概念一部分命令编程语言是称为脚本语言（script language）的语言的集合。这些语言通常用于执行管理任务，而不是开发复杂的程序。这种任务的表述称为脚本（script）。例如： PC的用户也许写一个脚本来指导一系列程序的之执行。 通常，程序由一组语句组成，这些语句一般可以分成3类：声明语句，命令语句（imperative statement）和注释。命令语句（imperative statement）：描述了潜在的算法里的步骤。 聚合类型[aggregate type]: 也称为结构（structure), 记录（record)， 有时还称异构数组(heterogeneous array)，是其元素可能具有不同类型的数据块。 运算符优先级（operator precedence) 一个运算符的这种多种用法称为重载(overloading). 2. 过程单元过程是一个命令型语言获得程序得到模块化描述的主要技术。 过程（procedure）就是实现一个任务的一组指令的集合，它能够作为其他程序单元使用的抽象工具。 将控制权转移到过程的步骤经常称为调用（call 或者 invoke)。 过程通常以独立程序单元的形式来编写，单元以一个称为过程头（procedure‘s header)语句开始， 作用域（scope) 参数 按值传递（pass by value)： 按值传递参数可以保护调用单元中的数据没有被修改。 按引用传递（pass by reference）：当参数表示一块很大的数据时，按值传递的效率不高，一个更高效地给过程传递参数的方法，就是在调用程序单元中告诉过程它所需要的实参地址。 不同的程序设计语言提供了不同的参数传递技术，但是在任何情况下，参数的使用都允许过程以通用的意义书写，并在适当的时候应用与特定的数据。 函数 函数和过程的概念不同。 函数是指一个类似过程的程序单元，但它把一个值作为「该函数的值」传递给调用程序单元。 事件驱动软件系统 事件驱动（event-driven）：当系统执行时，这些过程等待，直到与他们对应的事件应该做什么。当系统执行时，这些过程的等待，知道与它们对应的时间发生，然后它们被激活，并在完成它们的任务后回到等待状态。 翻译过程 将一个程序从一种语言转换为另一种语言的过程称为翻译（translation）。原始形式的程序称作为源程序（source program），翻译后的版本称为目标程序（object program）。 翻译过程包括3部分工作，分别是词法分析、语法分析和代码生成。实现相应的行为的单元分别为词法分析器（lexical analyzer）、语法分析器（parser），以及代码生成器（code generator）。 以机器语言的形式提供软件意味着根据远程计算机上使用的机器预言提供不提供版本的软件。通过设计能够翻译源代码的「通用计算机语言」（在 Java 中称为字节编码， 在 C# 中称为 .NET中间通用语言）。 通用机器语言在执行前被快速翻译，这个过程称为即时翻译（just-in-time complication）。 2. 面向对象程序设计继承的使用导致相似但是不同的对象的存在。 多态（polymorphism） 封装（encapsulation）是与面向对象程序设计相关的另一个特性，它是指限制对一个对象内部属性的访问。所一个对象的特定属性是封装的，就意味着只有对象自己才可以访问他们。 被封装的属性称为私有属性，可以从对象外部访问到的属性称为公有属性。 3. 程序设计中的并发活动并行处理（parallel processing）或并发处理（concurrent processing）。真正的并行处理器需要多个CPU，每个CPU都执行一个激活。 「激活」在 Java 中称为线程（Thread） 软件工程瀑布模型（waterfall model）的一个软件开发过程，在设计之前必须先完成整个系统的需求分析， 这种开发过程只会按照一个方向进行。 增量模型（incremental model）：所需的软件系统以一种渐近的模式来构建，即软件产品先是以功能有限的简化版本出现。 迭代模式（iterative model）。与增量模式类似。 增量模型和迭代模型反映出软件开发采用的原型开发（prototyping）这样一种趋势，原型（prototype） 模块化（modularity）就是把软件分割成多个易处理的单元，通常称为模块（module），每个模块仅仅承担整个软件的一部分功能。 1. 模块式实现模块可以以不同的方式实现。在命令型范型的环境中，模块表示为过程。 2. 行业工具数据流图（dataflow diagram） 数据字典（data dictionary），他是关于整个软件系统中出现的数据项的一个中央信息库。 UML(Unified Modeling Language)统一建模语言 用例图（use case diagram） 3. 设计模式设计模式{design pattern） 4. 软件测试软件测试的另一种方法称为基本路径测试（basis path testing）：这种方法都开发出一组测试数据，并且这组数据要能保证软件中的每条指令都能至少执行一次。 白盒测试（glass-box testing）这一类，这也就意味着软件测试人员要了解软件的内部结构。 黑盒测试（black-box testing），测试人员并不关心软件本身是如何工作的，而注重软件的精确度和时间性方面是否能正确执行。 B测试： beta testing 4. 数据抽象同构数组（homogeneous array)是一种“矩形的”数据块，其项是具有相同类型。 异构数组（heterogeneous array）是一个可能具有不同类型的项块，块里通常称为部件(component). 5. 机器语言的指针立即寻址（immediate addressing） 直接寻址（direct addressing） 间接寻址（indirect addressing） 数据库系统数据库是指一种多维的数据集合。之说以说是多维的，是因为这种集合中，通过数据项的内部连接，信息可以从不同的的角度获取。这与传统的文件系统不同，有时也称为平面文件（flat file），是一种一维的存储系统，因为它只从一个角度来展示信息。 为了让不提供的用户访问数据中不同的信息，通常数据库系统都依赖模式和子模式。「模式」（schema）是整个数据库结构的一个描述，数据库软件用它来维护数据库。 「子模式」（subschema）只是与特定用户需求相关的那部分数据库的一个描述。 1. 数据库模型 关系模式 它描绘的是用矩形表格存放的数据，这种表格称为关系（relation）。 关系中的一行称为一个元组（tuple）， 关系中的列称为属性（attribute）。 关系运算 在一个关系上想要执行的一个中运算就是选取具有某些特性的元组，并把这些选出的元组放到一个新的关系中。 SELECT 运算是从一个关系中提取行，与此相反， PROJECT 运算则是提取列。 另外一个用于连接关系数据库中的运算是 JOIN 运算， 它用来把原来不同的关系组合成一个关系。 2. 维护数据库的完整性把一个事物的所有步骤记录进日志文件的那个点，称为提交点（commit point）。 DBMS 的主要作用就是维护数据库的完整性。 如果问题出现在事物达到其提交点之前，那么 DBMS 可能会出现自己不能完成已经执行了一部分的事物。这种情况可以利用日志回滚（roll back)实际上已被事物执行的活动。 锁定 错误决算问题（incorrect summary problem） 更新丢失问题（lost update problem） 共享锁（shared lock） 排他锁（exclusive lock） 3. 传统文件结构 顺序文件 它从头到尾都是以顺序的方式进行访问的，好像文件中的信息都排成一行。 顺序文件的末尾称为 EOF（End-of-File，文件结束）。 索引文件 与书本里的索引用来定位主题在书中的位置的方式非常一致，这种文件系统称为索引文件（indexed file）。 文件的索引通常作为一个单独的文件与被索引的文件存放在同一个大容量的存储设备里。 散列文件 尽管索引技术为访问数据存储结构的数据项提供了一种较快的访问机制，但维护索引的开销也比较大。 散列（hashing）技术也能提供类似的访问效果，但无须那样大的开销。 散列系统可以概括如下： 数据存储空间可以被分成几个区， 称为存储桶（bucket），每个桶能放几条记录。根据将键的值转换为桶号的算法，可以将记录分散存放这些桶中，这里，将键的值转换为桶号的算法称为散列函数（hash function）。 人工智能要弄明白一种自然语言中的一个句子的意思需要几个层次的分析。 语法分析（syntactic analysis ) 语义分析（semantic analysis） 上下文分析（contextual analysis）]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer]]></title>
    <url>%2F2018%2F12%2F02%2FC%2B%2BPrimer%2F</url>
    <content type="text"><![CDATA[Variables and Basic TypesC++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably. To support 「separate complication」, C++ distinguishes between declaration and definition. The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. 1. Main Function and Library「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main. Standard library collection of types and function that every C++ compiler must support. They also tend to refer to particular part of the library by referring to a library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes. By default, reading cin flushes cout, cout is also flushed when the program end normally. To handle input, we use an object of type istream named cin, This object is also referred to as the standard input. In C++ an expression yields a result. When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1. The word 「nullptr」 is a pointer literal. The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand. To attain a declaration that is not also a definition, add the 「extern」 keyword. An extern that has an initializer is a definition. 2. Variables Initialization Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one. Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class. We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer. Separate compilation lets us split our programs into several files, each of which can be compiled independently. Declaration and Definition To support separate compilation, C++ distinguishes between declarations and definitions. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer: extern int i; // declares but does not define i int j; // declares and defines j Variables must be defined exactly once but can be declared many times. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. Reference A reference is not an object. Instead, a reference is just another name for an already existing object. A reference must be initialized A reference may be bound only to an object, not to a literal or to the result of a more general expression: Unlike a reference, a pointer is an object in its own right. Unlike a reference , a pointer need not be initialized at the time it is defined. references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference. 3. Pointer Pointer Value The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. It can be a null pointer , indicating that it is not bound to any object. Using a Pointer to Access an object When a pointer points to an object, we can use the dereference operator (the * operator) to access that object: We may dereference only a valid pointer that points to an object. Dereferencing a pointer yields the object to which the pointer points. Null Pointers A null pointer does not point to any object. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. nullptr is a literal that has a special type that can be converted to any other pointer type. Modern C++ programs generally should avoid using NULL and use nullptr instead. void* Pointers The type void* is a special pointer type that can hold the address of any object. We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object. Understanding Compound Type Declarations A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types Reference to Pointers A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer. int i = 42; int *p; // p is a pointer to int int *&amp;r = p; // r is a reference to the pointer p r = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i *r = 0; // dereferencing r yields i, the object to which p points; changes i to // the base type of the declaration says that r is a reference to a pointer to an int. It can be easier to understand complicated pointer or reference declarations if you read them from right to left. 4. const QualifierBy Default, const Objects Are Local to a File We want to define the const in one file, and declare it in the other files that use that object. To share a const object among multiple files, you must define the variable as extern. References to const const int ci = 1024; const int &amp;r1 = ci; // ok: both reference and underlying object are const r1 = 42; // error: r1 is a reference to const int &amp;r2 = ci; // error: non const reference to a const object Initialization and Reference to const In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression A Reference to const May Refer to an Object That Is Not const int i = 42; int &amp;r1 = i; // r1 bound to i const int &amp;r2 = i; // r2 also bound to i; but cannot be used to change i r1 = 0; // r1 is not const; i is now 0 r2 = 0; // error: r2 is a reference to const const Pointers and Pointer to const Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored int errNumb = 0; int *const curErr = &amp;errNumb; // curErr will always point to errNumb const double pi = 3.14159; const double *const pip = &amp;pi; // pip is a const pointer to a const object On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. int *p = p3; // error: p3 has a low-level const but p doesn&#39;t p2 = p3; // ok: p2 has the same low-level const qualification as p3 constexpr and Constant Expressions A constant expression is an expression whose value cannot change and that can be evaluated at compile time. Such functions must be simple enough that the compiler can evaluate them at compile time. Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions. Pointers and constexpr const int *p = nullptr; // p is a pointer to a const int constexpr int *q = nullptr; // q is a const pointer to int The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines. constexpr int *np = nullptr; // np is a constant pointer to int that is null int j = 0; constexpr int i = 42; // type of i is const int // i and j must be defined outside any function constexpr const int *p = &amp;i; // p is a constant pointer to the const int i constexpr int *p1 = &amp;j; // p1 is a constant pointer to the int j 5. Dealing with Types Type Aliases Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used. We can define a type alias in one of two ways. Traditionally, we use a typedef typedef char *pstring; const pstring cstr = 0; // cstr is a constant pointer to char const pstring *ps; // ps is a pointer to a constant pointer to char When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char, the base type is char and the is part of the declarator. The auto Type Specifier Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer. The decltype Type Specifier Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression: decltype(f()) sum = x; // sum has whatever type f returns const int ci = 0, &amp;cj = ci; decltype(ci) x = 0; // x has type const int decltype(cj) y = x; // y has type const int&amp; and is bound to x decltype(cj) z; // error: z is a reference and must be initialized decltype and References Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment // decltype of an expression can be a reference type int i = 42, *p = &amp;i, &amp;r = i; decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int decltype(*p) c; // error: c is int&amp; and must be initialized // decltype of a parenthesized variable is always a reference decltype((i)) d; // error: d is int&amp; and must be initialized decltype(i) e; // ok: e is an (uninitialized) int // The type is a reference to the type of the left-hand operand. int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // equal to :int &amp;d = a; Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 6. Defining Our Own Data StructuresIn C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes. Defining the Sales_data Type struct Sales_data { std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body. It is a common mistake among new programmers to forget the semicolon at the end of a class definition. Writing Our Own Header Files In order to ensure that the class definition is the same in each file, classes are usually defined in header files. classes are stored in headers whose name derives from the name of the class. Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations. A Brief Introduction to the Preprocessor The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif. Preprocessor variable names do not respect C++ scoping rules. Preprocessor variables, including names of header guards, must be unique throughout the program. 7. Defined Termsconst reference Colloquial synonym for reference to const. constant expression Expression that can be evaluated at compile time. declaration Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared. definition Allocates storage for a variable of a specified type and optionally initializes the variable. object A region of memory that has a type. A variable is an object that has a name.outer scope Scope that encloses another scope. preprocessor variable Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled. reference An alias for another object. struct Keyword used to define a class. typedef Defines an alias for another type. void* Pointer type that can point to any nonconst type. Such pointers may not be dereferenced. Strings, Vectors, and ArraysC++ defines a rich library of abstract data types. Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections. Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector. The built-in types represent facilities present in most computer hardware, such as numbers or characters. The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly. A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type. 1. Namespace using DeclarationHeaders Should Not Include using Declarations. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts. 2. Library string TypeA string is a variable-length sequence of characters. To use the string type, we must include the string header. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization. string s5 = &quot;hiya&quot;; // copy initialization string s6(&quot;hiya&quot;); // direct initialization string s7(10, &#39;c&#39;); // direct initialization; s7 is cccccccccc The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered. Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator. Adding Literals and strings When we mix strings and string or character literals, at least one operand to each + operator must be of string type Dealing with the Characters in a string In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Processing Every Character? Use Range-Based for If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」. The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in declaration is initialized from the value of the next element in expression. Using a Range for to Change the Characters in a string If we want to change the value of the characters in a string, we must define the loop variable as a reference type. string s(&quot;Hello World!!!&quot;); // convert s to uppercase for (auto &amp;c : s) // for every char in s (note: c is a reference) c = toupper(c); // c is a reference, so the assignment changes the char in s cout &lt;&lt; s &lt;&lt; endl; a subscript The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position. Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1]. The value in the subscript is referred to as 「a subscript」 or 「an index」. The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined. 3. Library vector TypeA vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」. Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called 「instantiation」. vector&lt;int&gt; ivec; // ivec holds objects of type int vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items vector&lt;vector&lt;string&gt;&gt; file; // vector whose elements are vectors 「vector is a template, not a type.」 Types generated from vector must include the element type. NoteConventions for Variable Names：变量名称的约定 separate compilation：独立编译 tend to：倾向于 fits in：适合 so far：目前为止 the indicated value: 指定的值 yields a result : 产生一个结果 bound to (bind to) :绑定 plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析 evaluated : 求…值 do not respect C++ scoping rules: 不遵守作用域规则 be used to： 用于 associative:联合 container:容器，集装箱 derived-Class: 派生类/子类 alias:别名 override: 重写 overloading: 重载 directive:指令 redirect: 重定向 indicator:指示 arguments: 实参 library facility:库功能 (工具库) statements:语句 extensive: 大规模 mechanisms: 机制 string literal: 字符串字面量 semicolon: 分号 block: 代码块 iteration: 重复 comments: 注释 built-in type： 内置类型 backslash： 反斜杠 carriage return： 回车 Escape Sequences: 转义序列 initializer: 初始化 commas： 逗号 type specifier: 类型说明符 Identifiers: 标识符 inclusive：包括 Nested Scopes：嵌套范围 fetch: 获取 type modifiers: 类型修饰符 underlying: 底层 Qualifier: 限定符 plain: 原始,素 synonym: 同义词 groups: 分组 implement：实现 strategy：a plan of action 策略 contents:内容 cover: 介绍 / 覆盖 punctuation: 标点 capitalize: 大写字母 subscript：下标]]></content>
      <categories>
        <category>原版书籍</category>
      </categories>
      <tags>
        <tag>原版书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硅谷来信]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[收获比较大的方面： 学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。 科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 结论可以证实，但不可证伪。为什么呢？ 就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？ 总之， 因为未来的不确定，结论可以证实，不能证伪。 别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。 语录： 对于那些视图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++复习]]></title>
    <url>%2F2018%2F11%2F28%2FC-C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[带指针的类和不带指针的类 class with pointer member 必须有 拷贝构造 和拷贝赋值 &amp; 有不同意义， 取地址和声明参数引用。 对象类型： local objects （auto object）： Complex c2(); static objects：其生命在作用域结束后仍然存在，知道整个程序结束。 global objects heap objects using 编译指令： 在多函数程序中使用using编译指令，这是因为函数都使用了 cout， 因此需要能够访问位于命名空间std的 cout 定义 。 using namespace std； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素 namespace 和 Java 的 包类似 函数原型： 函数原型作为黑盒的函数 函数原型 prototype 成员函数： 成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。 static : static data 要 static 函数处理 static 成员函数 和 成员函数区别：没有 this pointer static 函数调用方式： object 调用 和 class name 调用 Inheritance 继承成员变量 继承成员函数的调用权 vitual pure vitual impure virtual non-virtual 为什么需要原型 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。 如 double volume = cube（side）； 原型的功能 原型可以帮组编译器完成许多工作。 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。 使用引用参数的原因 程序员能够修改调用函数中的数据对象。 通过传递引用而不是整个数据对象，可以提高程序的运行速度。 class CStuFile { public: CStuFile(char *filename); ~CStuFile(); void Add(CStudentRec stu); int Seek(char* id, CStudentRec &amp;stu); int List(int nNum = -1); private: char *strFileName; }; CStuFile::CStuFile(char *fileName) { strFileName = new char[strlen(fileName) + 1]; strcpy(strFileName, fileName); } CStuFile::~CStuFile() { if( strFileName ) delete []strFileName; } void CStuFile::Add(CStudentRec stu) { //写入文件， 二进制形式 fstream file(strFileName, ios::out|ios::app|ios::binary); file &lt;&lt; stu; file.close(); } int CStuFile::Seek(char *id, CStudentRec &amp;stu) { int nRec = -1; fstream file(strFileName, ios::in|ios::nocreate); if(!file) { cout &lt;&lt; &quot;文件&quot; &lt;&lt; strFileName &lt;&lt; &quot;不能打开&quot; &lt;&lt; endl; return nRec; } int i = 0; while( !file.eof() ) { file&gt;&gt;stu; if((strcmp(id,stu.strID) == 0) &amp;&amp; (stu.chFlag != &#39;N&#39;)){ nRec = i; break; } i++; } file.close(); return nRec; } int CStuFile::List(int nNum) { //录入数量 int nRec = 0; //打开文件方式 输入，不创建 fstream file(strFileName, ios::in|ios::nocreate); //file 为 NULL， 则打开文件失败 if( !file ) { cout &lt;&lt; &quot;文件&quot; &lt;&lt;strFileName &lt;&lt; &quot;不能打开!&quot; &lt;&lt; endl; return 0; } if((nNum==-1)||(nNum&gt;0)) { //输出数据左对齐 cout.setf(ios::left); cout&lt;&lt;setw(6)&lt;&lt;&quot;记录&quot; &lt;&lt;setw(20)&lt;&lt;&quot;姓名&quot;&lt;&lt;setw(10)&lt;&lt;&quot;学号&quot; &lt;&lt;&quot;\t成绩1\t成绩2\t成绩3\t平均分&quot;&lt;&lt;endl; } //当读取文件为结尾时 while( !file.eof() ) { CStudentRec data; file &gt;&gt; data; if(data.chFlag == &#39;A&#39;) { nRec++; if( (nNum == -1) || (nRec &lt;= nNum) ) { cout.setf(ios::left); cout &lt;&lt; setw(6) &lt;&lt; nRec; data.Print(); } } } file.close(); return nRec; }]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[编程规范 #ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; } 使用链表的例子： 页帧管理​ 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暗时间]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[暗时间 善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。 如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。 能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？（思维方式） 能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。 因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。 设计你自己的进度条 进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。 善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。前阵子流行的 GTD 方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。 其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。 饿死在干草堆之间的驴子（选择问题） 面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。 但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。 所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。 如何有效地记忆与学习 你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。 整理笔记：经常整理你的笔记——如果你没有做笔记，现在就开始——整理之前的笔记一来巩固已经淡化的记忆，二来给你重新审视知识的机会。我常常发现对知识的首次记忆往往是有偏颇的，或者只看到了一个方面，或者只关注了一个点，一段时间之后再回来看往往能够和这段时间以来的一些新思考和知识结合起来，得到更多的东西。留心一下你会发现记忆实际上是很脆弱的东西，而且我们对事物的首次理解几乎肯定是不深入的。 书写：将一段时间学习的知识按照一个主题系统地“串”起来大大地丰富了知识之间的关联，平添无数提取线索。 学习密度与专注力 其实，在大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家。而生活中太多的分散注意力的因素：游戏、篮球、选修课、女朋友… 要想集中注意力对一个单一的目标猛下功夫，其实还是相当有难度的。这个难度并非来自自制力，如果一个人要靠自制力去强迫自己不受干扰，那只能说还是寻常人(mediocre)。真正的效率源自于内心对一个东西强烈的热忱，也就是我们俗称的追求，这时候从表层意识到深层意识都关注在这件事情上面，脑细胞高度活跃，才能创造最大的效率。 专注力为什么会对学习效率造成这么大的影响。这来源于两个方面，一是专注于一件事情能让表层意识全功率运作，这个是显式的效率。第二点，也是更重要的，它还能够使你的潜意识进入一种专注于这件事情的状态。如果表层意识和潜意识都能专注同一件事情，也就是俗称的完全投入，这个时候的效率就能double。此外这种专注成了一种习惯之后，就容易在很短时间之内把自己的潜意识带入到一种关注的“惯性”中，于是即便表层意识的注意力已经移开了，然而潜意识仍在继续关注原来的问题。比如你可能有这样的经历，学习一首歌曲，一开始的时候并没有完全学会，然后你就去忙别的事情了，一个星期之后想起这首歌曲，居然发现原来难学会的几个地方突然会哼了；或者思考一个问题，一开始的时候总有一个地方没有思考出来，然后你就先放着了，几天之后回想这个问题，突然发现一切都清晰了。这就是潜意识的效率，它能在你不知不觉中把时间利用起来。 一个习惯于专注事情的人不管做什么事情都容易并迅速进入一种专注的状态。既然是一种习惯，就能够培养，金出武雄在《像外行一样思考，像专家一样实践——科研成功之道》里面提到“思维体力”的概念，所谓思维体力就是能够持续集中注意力的时间，注意力造就非凡专家，天才来源于长期的专注的训练。培养你的思维体力，是成为非凡专家的一个必要条件。除了培养专注的习惯之外，还可以通过另一个充分条件来实现专注力，即做自己喜欢做的事。我们从小对自己喜欢做的事情都是极其专注的，当然，即使长大了之后，仍然还是某种程度上保留了这种专注的能力，只不过因为种种外界因素，长久专注的能力反而削弱了，要考虑房子，要考虑业绩，要考虑小孩，要考虑医疗保险…这些让人焦虑的事情会积压在潜意识当中，总是在影响你专注做事，削弱你人生的效率。 一直以来伴随我的一些学习习惯学习与思考 Google &amp; Wiki（遇到问题做的第一件事情，也是学习某个东西做功课（homework）最先用到的东西。 做读书笔记。一是将自己阅读的时候的思考（包括闪念）总结下来，二是将书中的好例子摘抄下来。（这个习惯是一年前才养成的，发现受益极大。）有了 google note，笔记可以加上tag，非常便于回顾，加深理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上（后两者常常也是相关的）。 提到思考，我有一个小习惯。利用走路和吃饭的时候思考，还有睡觉前必然要弄一个问题放在脑子里面，在思考中迷糊入睡。发现这样一来往往在不知不觉中多出来大量的思考时间。 将思考成为习惯还有一个很大的好处——避免焦虑。 重要的事情营造比较大的时间块来完成。比如一本好书，或者一个重要的知识点，最好不要切得太琐碎了看，否则看了后面忘了前面。不利于知识的组织&amp;联系。 多看心理学与思维的书，因为它们是跨学科的。知识分两种，一是我们通常所谓的知识，即领域知识。二是关于我们的大脑吸收知识的机制的知识，后者不妨称为元知识。虽说这也是领域知识，但跟其它的领域知识不同的是，它指导着我们学习其它所有的领域知识。 学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。 获得的多少并不取决于读了多少，而取决于思考了多少、多深。 善于利用小块时间，也就是《奇特的一生》中所说的“时间下脚料”，如何利用前面有几个方法。同时，也善于创造整块时间（如通过要事优先）。 时间管理 学习和思考的过程中常问自己的几个问题： 你的问题到底是什么？. OK，到现在为止，我到底有了什么收获呢？时常反省和注意自己的思维过程。养成反驳自己的想法的习惯。 重视知识的本质：对于程序员来说这一点尤其重要，程序员行业的知识芜杂海量，而且总是在增长变化。很多人感叹跟不上新技术。应对这个问题的办法只能是：抓住不变量。大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时。算法数据结构永远都不过时。基本的程序设计理论永远都不过时。良好的编码习惯永远都不过时。分析问题和解决问题的能力永远都不过时。强大的学习能力和旺盛的求知欲永远都不过时。你大脑的思维方式永远都不过时。 重视积累的强大力量，万事提前准备：计划订长一点，自然就可以多获得准备的时间。设想你若干年后会在做什么事情，需要哪些技能，现在就开始准备。一个5年计划便可以让你获得从现在开始的5年准备时间。5年中每天腾出半个到一个小时专心于某一件事情，认准一个方向，每次走一点，其实不要说5年，两年就会发现会起到宏大的效应。 抬起头来：人的思维是非常容易只见树木不见森林的（否则这个成语从哪来的呢？）。时不时抬起头来审视一下自己正在做的事情，问一问它（对现在或未来）有什么价值，是不是你真正希望做的。你学到的东西到底是什么？它们重要吗？你需要在这个时候学习这些吗？（见第2条）。你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。仅仅遵循兴趣是不够的，人会对很多次要的东西产生兴趣，并一头钻进去浪费好多时间。所以判断一个东西值不值得学习是很重要的。（兴趣偏差） 有时间吗？总结总结最近得到的新知识吧。一般来说，我在一段时间内学习的一些东西总是会在这段时间内一直在脑子里打转，一有时间空隙（譬如走路，吃饭）它们就会自己蹦出来，促使我去进一步思考和总结。永远不要认为对一个知识的把握足够深刻，“理解”的感觉很多时候只是假象。学会反问自己对知识到底把握了多少，是很有价值的。 有时间吗？看本书吧。（传统的）阅读和思考永远优于所谓的在互联网上汲取新知识，后者往往浅表、不系统、乃至根本没价值。 制定简要的阅读计划：选出最近认为对你最有价值的书，先总览一下，决定阅读的顺序（哪些章节可以优先阅读）。然后每天看一点。并利用走路、吃饭、乘车或其他不适合带着书和笔的时间来总结看过的内容，建立知识结构，抽取知识本质，与以往的大脑中的知识建立联系。 阅读方法 趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去。万事开头难，因为从不了解到了解基本的一些事实，是一个新知识暴涨的阶段，这个时候的困难是最大的。有人熬不过去，觉得困难太大就放弃了。 根据主题来查阅资料，而不是根据资料来查阅主题。以前读书的时候是一本一本的读，眼里看到的是一本一本的书，现在则是一章、甚至一节一节的读，眼中看到的不是一本一本的书，而是一堆一堆的章节，一个一个的知识主题，按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。 学习一个东西之前，首先在大脑中积累充分的“疑惑感”。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到解答之后印象就越深刻。记得大学里面的课本总是瀑布式地把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完了很快又忘掉了，为什么？因为没有带着疑问去学习。 有选择地阅读。很多人觉得我读书速度很快，其实我只是有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读。二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的（譬如《黑天鹅》），那么1. 现象是什么？2. 解释是什么？3. 支撑这个解释的理由是什么？4. 例子是什么？一般来说，这一二三四用不了多少字就可以写完了（如果假设只举一到两个精到的例子的话），这样的无废话著作的典型是《合作的进化》；那为什么有些书，明明核心观点就那点东西（顶多加上几个精要的例子罢了）却写得长得要命呢？因为人的思维都有一个“联想”的特点，写着写着就容易旁逸斜出，而且作者自己也往往觉得引申出去挺牛逼，有时候很多与主题无关的废话就掺和进来了；那么，阅读的时候就应该有选择性地滤掉这些不相干的废话；此外还有一种可能性就是大量冗余的例子。一般来说组织得比较好的书会有详细且一目了然的目录和索引，根据目录首先就可以滤掉一部分（比如某个子章节的内容你以前是看过的），然后有时候作者还会举很多冗余的例子，如果你已经觉得印象够深刻了这些例子完全可以不看（一些书就非常厚道地对每个观点只辅以一两个最最经典的例子，譬如《与众不同的心理学——如何正视心理学》，这样的书我最是喜欢）。（有选择阅读） 知识结构 抓住不变量： 把知识分为essential的和non-essential的。对于前者采取提前深入掌握牢靠的办法，对于后者采取待用到的时刻RTM (Read the manual)方法（用本）。 思维改变生活 如何区分essential和non-essential的知识想必绝大多数时候大家心里都有数，我举几个例子：对程序员来说，硬件体系结构是essential的，操作系统的一些重要的实现机制是essential的，主流编程范式（OO、FP）是为了满足什么需求出现的（出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景）。这些我认为都是essential的。我想补充一点的是，并不是说硬件体系结构就要了解到逻辑门、晶体管层面才行（其实要了解到这个层面代价也很小，一两本好书就行了），也并不是说就要通读《Computer Architecture: Quantitative Approach》才行。而是关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）。《Computer Systems: A Programmer’s Perspective》就是为此目的，针对程序员的需求总结出那些essential knowledge的好书。（写下来，理性分析） 我们对于事物的思考深度常常是不够的，在浅层次的思考了之后，如果我们的情绪系统或者直觉已经给出了倾向，那么很少有人会继续深入地思考，而开始转向着手行动。这种匆忙的态度往往是失败的起源，在碰壁了之后，我们被动地“让事实告诉了我们”某方案是行不通的，让事实替代我们进行了思考和推理，我们从失败当中获得了信息，知道了为什么之前的方法是不恰当的，这就是一些时候我们认为要亲身经历才能明白的原因。然而，这并不意味着任何时候我们都只能“做了之后才发现…”，人类最强大的能力就是社会学习—— 普通人从自己的错误中学习，聪明人从别人的错误中学习。 人类最强大的另一个能力则是归纳和推理—— A few lines of reasoning can change the way we see the world. (via) 我们可以仔细地，理性地思考、权衡各个选择的利弊，而不仅仅满足于情绪上的判断。 假设我们面临两个选择，A和B，我们可以结合别人的经历，利用自己的推理能力，去分别推断A或B选项带来的各种各样可能的利弊，对于其中不确定的因素我们或者可以进一步从别人那里收集更多的信息来使得判断更靠谱，或者可以对风险的上下界进行一些估计，总之，我们尽量去让我们大脑中假想的角色去经历失败——我们通过推理发现某条路行不通，就避免了现实中去碰一鼻子灰。 书写是为了更好地思考 我经常在走路和睡前总结所学过的内容，思考遗留的问题，一段时间的阅读和思考之后，一个总体的知识框架就会逐渐浮现在脑海中。然后我会将它书写下来，然而，我往往非常惊讶地发现，当我书写的时候，新的内容仍然源源不断的冒出来，就像我的键盘自己也会思考一样。（总写学过的知识） 遇到问题为什么应该自己动手 有一个很不错的概念叫做“Unknown Unknown”，大意是如果你不知道一个东西的话，你也不会知道你自己不知道它。很多时候新知识就有这个特性——掌握了之后觉得很明白，掌握之前却觉得“不可能啊”、“这简直没有解嘛”。在这样的认知之下，你自然会高估前方的困难、风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为Unknown Unknown，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。（不知道自己不知道的） 用最小的代价解决手头的问题”——这里的问题在于，难道我们计算收益的时候仅仅考虑是否解决了手头的问题吗？如果解决的过程中得到了其他的收益呢？为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。（额外的收益） 什么才是你的不可替代性&amp;核心竞争力知识技能组合是具有相当程度的不可替代性的： 专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。 跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind 等等 学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。 性格要素：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等。 鱼是最后一个看到水的 《设计模式》被许多初学者奉为圭臬，认为那些看上去精巧的东西才是真正牛13的，值得学习的。而且，更聪明一点的人甚至会唯恐学的东西还不够复杂，因为越是复杂的东西搞出来越是有成就感。然而事实是，把简单的事情搞复杂的人比比皆是，把复杂的事情搞简单的人凤毛麟角。（不要把简单事情搞复杂） 避免思维被一门语言束缚的最好办法就是“学习其它语言”。 知其所以然 包含了多得多的知识：记一个算法，就只有一个算法。一个萝卜一个坑。就好比背99乘法表只能解决乘法问题一样。而记背后的思想，却有助于解决一类问题。思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。算法诞生过程中的思路往往包含了比实际算法更本质得多的知识，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。（分析推理） 重在分析推理，而不是联想：学了一大通算法和数据结构之后的一个副作用就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的思维捷径，在任何时候都会抢占大脑的工作记忆，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维最重要的特征。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。 习惯 也许，对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败而领悟的，还是看到书上或听到别人说的）写下来，并常常拿出来翻看。事实上，我的经验是，在写下来的时候我们的大脑会进入到理性分析模块，进一步检验和推理那些道理，我们越是对一个道理审视的详细、深入、全面，大脑中留下的印象深刻，从记忆加工的角度来说，这叫深度加工，带来的结果就是该记忆与更多的提取线索相关联，于是便能够在更多的场景下被唤起（而不是被以往的习惯直接覆盖） note: 俗语有谋事在人，成事在天的说法。其实这话说的是，我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果。不要奢望你努力了就绝对会成功，你不会。更不要以这个理由来作为不去努力的原因，因为不去努力，那就永远不会成功。 生活中一抓一大把。俗语云“公说公有理，婆说婆有理。”你敢于表达自己的观点，他说你喜欢炫耀。你韬光养晦呢，他又说你夹着尾巴做人；你为自己的成就骄傲一下，他说你得意忘形。你低调做人呢，他又说你怎么这么没种；你说彪悍的人生不需要解释，他说你自大狂。你说做人贵有自知之明呢，他又说你丫做人怎恁费劲捏？… ###]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高质量C/C++编程指南]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%AB%98%E8%B4%A8%E9%87%8FC-C-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[文件结构 程序的版式 命名规则 表达式和基本语句 常量 函数设计 内存管理 c++函数的高级特性]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式 //抽象工厂模式， 生产一组产品 class Fruit { public: virtual void SayName() = 0; }; class AbstractFactory { public: virtual Fruit *CreateBanana() = 0; virtual Fruit *CreateApple() = 0; }; class NorthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north banana&quot; &lt;&lt; endl; } }; class NorthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north apple&quot; &lt;&lt; endl; } }; class SouthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south Banana&quot; &lt;&lt; endl; } }; class SouthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south apple&quot; &lt;&lt; endl; } }; class NorthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new NorthBanana(); } virtual Fruit *CreateApple() { return new NorthApple(); } }; class SouthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new SouthBanana(); } virtual Fruit *CreateApple() { return new SouthApple(); } }; void main() { AbstractFactory *af = NULL; Fruit *fruit = NULL; af = new NorthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); af = new SouthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); system(&quot;pause&quot;); } 建造者模式class House { public: void setDoor(string door) { this-&gt;m_door = door; } void setWall(string wall) { this-&gt;m_wall = wall; } void setWindow(string window) { this-&gt;m_window = window; } string getDoor() { cout &lt;&lt; m_door &lt;&lt; endl; return m_door; } string getWall() { cout &lt;&lt; m_wall &lt;&lt; endl; return m_wall; } string getWindow() { cout &lt;&lt; m_window &lt;&lt; endl; return m_window; } private: string m_door; string m_wall; string m_window; }; class Builder { public: virtual void buildWall() = 0; virtual void buildDoor() = 0; virtual void buildWindow() = 0; virtual House* getHouse() = 0; }; class FlatBuilder : public Builder { public: FlatBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Flat door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Flat wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Flat window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class VillaBuilder : public Builder { public: VillaBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Villa door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Villa wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Villa window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class Director { public: Director(Builder *build) { m_build = build; } void Construct() { m_build-&gt;buildWall(); m_build-&gt;buildWindow(); m_build-&gt;buildDoor(); } private: Builder *m_build; }; void main() { House *house = NULL; Builder *builder = NULL; Director *director = NULL; builder = new VillaBuilder(); //设计师 指挥 工程队 干活 director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); //返回房子 house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; //请 FlatBuilder 公寓 builder = new FlatBuilder; director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; delete director; system(&quot;pause&quot;); return; }]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[SQL基本概念数据库是一个以某种有组织的方式存储的数据集合. 表是一种结构化的文件, 可用来存储某种特定类型的数据. 表:某种特定类型数据的结构化清单． 模式：关于数据库和表的布局及特定的信息. 表由列组成. 列中存储着表中某部分的信息. 列: 表中的一个字段. 所有表都是由一个或多个列组成的. 数据库中每个列都有相应的数据类型.数据类型定义列可以存储的数据种类. 表中数据都是按行存储的, 所保存的每个记录存储在自己行内. 行：表中的一个记录. 记录和行互相代替. 主键：一列(或一组列), 其值能够唯一区分表中每个行. 唯一标识表中的每行的这个列称为主键. SQL: 是结构化查询语言的缩写. 客户机-服务器应用分为两个不同的部分, 服务器部分是负责所有数据访问和处理的一个软件. 这个软件运行在称为数据服务其的计算机上. 与数据文件打交道的只有服务器软件. 关于数据, 数据添加, 删除和数据更新的所有请求都由服务器软件完成.这些请求或更改来自运行客户机软件的计算机. 客户机是与用户打交道的软件. ​ 客户机和如软件可能安装在两台计算机或一个计算机上. 不管他们在不在相同的计算机上, 为进行所有数据库交互, 客户机软件都要与服务器软件进行通信. ​ 所有这些活动对用户都是透明的. 数据存储在别的地方, 或者数据库服务器为你完成这个处理这一事实是隐藏的. 你不需要直接访问数据文件. 事实上, 多数网络的建立使用户不具有对数据的访问权, 甚至不具有对存储数据的驱动去的驱动器的访问权. 服务器软件为MySQL DBMS. 你可以在本地安装的副本上运行, 也可以连接到运行在你具有访问权的远程服务期上的一个副本. 客户机可以是MySQL提供的工具, 脚本语言, web应用开发语言, 程序设计语言. 熟悉MySQL命令行实用程序, 数据库的基本概念： 列/字段/属性/数据项（column/field/attribute/data item） 行/元组/记录（row/tuple/record） 关系模式： 表名 +表标题（格式） 表／关系：表名＋表标题（格式）＋表内容（值） DataBase：相互之间有关联关系的Table的集合。 数据库： DB 数据库管理系统：DBMS 数据库应用：DBAP 数据库管理员：DBA DBMS提供了一套数据控制语言（DCL）给用户，DBA-&gt;DCL-&gt;DBMS 数据操作语言：DML，提供给用户，以便给用户对数据进行操作 数据控制语言：DCL，用户使用DCL；定义对不同操作的约束，对不同操作者的约束。 数据定义语言：DDL, 定义表名，表标题，列名其结构形式 SQL语言： DML, DCL, DDL， 结构化的数据库语言 数据库语言与高级语言的区别： ​ 一条数据库语言相当于高级语言的一个或多个循环程序。 数据模型——模式——数据 模式：外模式（子模式），概念模式（全局模式，逻辑模式），内模式（存储模式，物理模式） E-C映像 ， C-I映像 三级模式两层映像：实现了逻辑独立性和物理独立性， 数据和应用程序的独立性 数据模型： 关系模型 层次模型 网状模型 关系模型的三个要素： 基本结构 基本操作 完整性约束：实体完整性，参照完整性和用户自定义完整性 关系运算：关系代数和关系演算；关系演算：元组演算和域演算 关系代数：基于集合的运算，即操作的对象和结果都是集合，是一次一集合的操作。而非关系型的数据操作通常是一次一记录的操作 “列“的取值范围“称为 ”域（Domain）” 笛卡尔积的每个元素（d1, d2,…..)称为一个n-元组 元组的每个值叫做一个分量。 笛卡尔积中具有某一方面意义的那些元组被称作一个关系。 关系模式和关系：关系模式是关系的结构，关系是关系模式在某一时刻的数据。 关系是笛卡尔积的子集。 列名（属性名） 列值（来自域） 关系的特性： 列位置的互换性：区分哪一列是靠列名 行位置的互换性：区分哪一行是靠某一或某几列的值 关系是以内容来区的 属性不可再分特性：又被称为关系第一范式 关系的任意两个元组不能完全相同。 Table：可能有重复的元组存在。 关系和Table（表） 大部分相同。 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组总去掉任何一个属性，它就不具有这一性质了，这样的属性称作候选码。 当有多个候选码，可以选定一个作为主码。 DBMS以主码为主要线索管理关系中的各个元组。 主属性：包含在任何一个候选码的属性被称作主属性 外码/外键：两个关系通常是靠外码连接起来的。 关系模型中的完整性： 实体完整性：关系的主码的属性值不能为空 参照完整性：相对于外码 用户自定义完整性：用户针对具体的应用环境定义的完整性的约束条件。 关系代数基本操作：并相容性 并 差 广义笛卡尔积 选择操作 投影操作 关系代数的基本书写思路： 选出将用到的关系/表 做“积”运算 做悬着运算保留所需的行/元组 做投影运算保留所需的列/属性 扩张操作 交运算 连接操作：在乘积操作的基础上，在做一个选择操作。 更名操作 等值连接 自然连接 除运算 关系代数 和 关系演算 关系演算：元组演算和域演算 E-R关系图： 实体表示方框， 属性表示椭圆， 关系表示菱形。 抽象是理解，区分，命名，表达 实体， 属性，联系， 关键字（码） 属性：单一属性和复合属性 关键字/码，实体中能够用其值唯一区分每个实体的属性或属性组合。 参与发生联系的实体的数目，称为联系的度， 联系是多样化的。 实体在联系中的作用称为实体的角色 当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需要显示指明其角色。 实体之间的联系有很多种类。 完全参与联系 部分参与联系 不同层次的型与值 数据模型：概念 命令行]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[for循环常用写法date: 2018-09-27 11:03:38 插入元素: 删除元素: void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 循序栈和链式栈date: 2018-09-25 15:54:15 stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 线性表顺序存储和链式存储date: 2018-09-23 19:46:15 单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 基本概念date: 2018-09-22 14:22:10 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 ​ //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 二叉树表示算数表达式： 先序遍历： 前缀表示法 中序遍历： 中缀表示法 后序遍历： 后缀表示法 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2018%2F10%2F11%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[匿名对象date: 2018-09-20 17:15:00 匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。 class AA { public: AA() { cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } ~AA() { cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl; } }; void main() { //AA a = AA(); //产生一个匿名对象， 有一个变量去接，不会调用析构函数。 AA b; //调用拷贝构造函数。 b = AA(); //匿名对象， 会调用拷贝构造函数和析构函数。 //func(); system(&quot;pause&quot;); } 异常date: 2018-09-21 14:28:22 抛出异常是跨函数的。 c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。 栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。 异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。 void func() thorw(A, B, C, D) { } 知识点date: 2018-09-20 21:51:18 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 字符串常量/字面量 拷贝构造函数：是一种特殊的构造函数，他在构建对象时， 是使用同一类中之前创建的对象来初始化新创建的对象。 迭代器： 是一种检查容器内元素并遍历元素的数据类型，可以代替下标访问vector对象的元素。迭代器是便利容器的同一方法。 容器： 任何数据类型都能存储。 引用引用分为普通引用和常引用 //常引用 //常引用当函数参数 ,可以传字面量或者实参 void func1(const int&amp; num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } //普通引用当函数参数， 传实参 void func2(int &amp;num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } void main() { int a = 10; int c = a; //引用当右值， 把变量的值赋值给变量 int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。 cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl; cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl; //字面量常引用 const int&amp; tmp = 123; //分配内存 cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl; cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl; //普通引用 //int&amp; var = 123; //不自动分配内存， 编译错误 int var = 123; func1(123); //可以传进字面量 func1(var); //可以传进变量 func2(var); //只能传进变量. cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 常量必须初始化 重载和重写date: 2018-09-20 08:28:05 重写与重载： 方法的重写Overriding和重载Overloading是多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同 定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。 左值右值date: 2018-09-19 21:34:18 左值和右值 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 对象的初始化， 和赋值不一样 A a = b; // 调用a的拷贝构造函数 A a; a = b; //调用操作符重载=函数, 类模板date: 2018-09-19 15:41:31 #include &quot;iostream&quot;//类模板的本质， 两次编译 using namespace std; template &lt;typename T&gt; class Teacher { public : static T a; private: }; template &lt;typename T&gt; T Teacher&lt;T&gt;::a = 0; void main() { Teacher&lt;int&gt; t1; t1.a = 10; t1.a++; t1.a++; Teacher&lt;char&gt; t2; t2.a = &#39;a&#39;; t2.a++; t2.a++; cout &lt;&lt; t2.a &lt;&lt; endl; //两个静态变量， 不一样， 属于不同内存空间 cout &lt;&lt; t1.a &lt;&lt; endl;//类模板机制的本质， 两次编译 cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 线性链表date: 2018-09-18 17:29:04 泛型编程date: 2018-09-17 22:11:16 指针作引用date: 2018-09-11 20:17:36 结构体作函数参数date: 2018-09-11 14:49:20 //结构体作函数参数 struct Teacher { char name[60]; int age; }; void printTeacher1(Teacher t1) { cout &lt;&lt; t1.age &lt;&lt; endl; } void printTeacher2(Teacher &amp;t2) { t2.age = 20; cout &lt;&lt;t2.age&lt;&lt; endl; } void printTeacher3(Teacher *t3) { t3-&gt;age = 30; cout &lt;&lt; t3-&gt;age &lt;&lt; endl; } void main() { Teacher t1; t1.age =10; printTeacher1(t1); printTeacher2(t1); //引用方式，结构体作函数参数 printTeacher3(&amp;t1); //作用与指针间接赋值一样。 system(&quot;pause&quot;); return; } Type &amp;name = var;//等效于C语言 Type *const name = var; 引用作函数参数， 当左值和右值。 当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址而已 引用就是给内存取多个门牌号（多个别名） 运算符date: 2018-09-11 07:21:16 //struct 和 class完成的功能一样 //布尔类型 bool类型 //关于左值（必须是一个变量，即有内存空间） //111 = 33；（111不能当左值， 不是一个变量，没有内存空间） //三目运算符， C返回是一个数（不能当左值）， C++返回是一个变量（能当左值） void main() { bool b1, b2, b3; b1 = 10; b2 = -10; b3 = 0; cout &lt;&lt; &quot;sizeof(bool)&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return; } //结果显示： //sizeof(bool)1 //1 //1 //0 //请按任意键继续. . . const 和 #define 相同之处 #define 是单纯的文本替换， 作用域具有全局性 #undef 限制作用域 引用的基本用法 C++的引用: 已定义变量再起个别名 Type&amp; name = var; //引用作函数参数: 与指针类似 void myswap1 (int a, int b) //不能间接赋值 { int c = 0; c = a; a = b; b = c; } void myswap2(int *a, int *b) //指针做函数参数， 实现间接赋值。 { int c = 0; c = *b; *b = *a; *a = c; } void myswap3(int &amp;a, int &amp;b) //引用做函数参数， 实现间接赋值。 { int c = 0; c = a; a = b; b = c; } void main() { int a = 10; int b = 20; myswap1(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; myswap2(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); myswap3(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return; } /*结果显示: 10 20 a = 20, b = 10 10 20 请按任意键继续. . . */ 函数返回值当左值右值 int&amp; func(void) { int a = 10; return a; } void main() { int a = func(); //将栈变量的值赋值给a. int &amp;b = func(); //传递栈变量的地址 cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; endl; //显示乱码 system(&quot;pause&quot;); } 类date: 2018-09-10 17:49:28 #include &quot;iostream&quot; using namspace std; void main() { cout&lt;&lt;&quot;hello.\n&quot;&lt;&lt;endl; system(&quot;pause&quot;): retun; } //endl 相当于 \n 类是一种数据类型， 是固定大小内存块的别名 定义一个类，是一个抽象的概念， 不会分配内存 using namespace std; C中的命名空间，只有一个全局作用域。C语言中所有的全局标识符共享一个作用域。 命名空间 C++中提出了命名空间的概念： 不同命名空间中的标识符可以同名而不会发生冲突 命名空间可以相互嵌套 全局作用域也叫默认命名空间。 namespace namespaceA { int age = 10; } namespace namespaceB { int age = 20; namespace namespaceC { struct Teacher { int age; }; } } void main() { cout &lt;&lt; &quot;hell.&quot; &lt;&lt; endl; using namespace namespaceA; using namespace namespaceB; cout &lt;&lt; namespaceA::age&lt;&lt;endl; cout &lt;&lt; namespaceB::age&lt;&lt;endl; using namespaceB::namespaceC::Teacher ; //注意事项， 缺少namespace Teacher t1; t1.age = 30; cout &lt;&lt; t1.age &lt;&lt;endl; system(&quot;pause&quot;); return; } 带指针的类和不带指针的类 class with pointer member 必须有 拷贝构造 和拷贝赋值 &amp; 有不同意义， 取地址和声明参数引用。 对象类型： local objects （auto object）： Complex c2(); static objects：其生命在作用域结束后仍然存在，知道整个程序结束。 global objects heap objects using 编译指令： 在多函数程序中使用using编译指令，这是因为函数都使用了 cout， 因此需要能够访问位于命名空间std的 cout 定义 。 using namespace std； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素 namespace 和 Java 的 包类似 函数原型： 函数原型作为黑盒的函数 函数原型 prototype 成员函数： 成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。 static : static data 要 static 函数处理 static 成员函数 和 成员函数区别：没有 this pointer static 函数调用方式： object 调用 和 class name 调用 Inheritance 继承成员变量 继承成员函数的调用权 vitual pure vitual impure virtual non-virtual 为什么需要原型 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。 如 double volume = cube（side）； 原型的功能 原型可以帮组编译器完成许多工作。 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。 使用引用参数的原因 程序员能够修改调用函数中的数据对象。 通过传递引用而不是整个数据对象，可以提高程序的运行速度。 class CStuFile { public: CStuFile(char *filename); ~CStuFile(); void Add(CStudentRec stu); int Seek(char* id, CStudentRec &amp;stu); int List(int nNum = -1); private: char *strFileName; }; CStuFile::CStuFile(char *fileName) { strFileName = new char[strlen(fileName) + 1]; strcpy(strFileName, fileName); } CStuFile::~CStuFile() { if( strFileName ) delete []strFileName; } void CStuFile::Add(CStudentRec stu) { //写入文件， 二进制形式 fstream file(strFileName, ios::out|ios::app|ios::binary); file &lt;&lt; stu; file.close(); } int CStuFile::Seek(char *id, CStudentRec &amp;stu) { int nRec = -1; fstream file(strFileName, ios::in|ios::nocreate); if(!file) { cout &lt;&lt; &quot;文件&quot; &lt;&lt; strFileName &lt;&lt; &quot;不能打开&quot; &lt;&lt; endl; return nRec; } int i = 0; while( !file.eof() ) { file&gt;&gt;stu; if((strcmp(id,stu.strID) == 0) &amp;&amp; (stu.chFlag != &#39;N&#39;)){ nRec = i; break; } i++; } file.close(); return nRec; } int CStuFile::List(int nNum) { //录入数量 int nRec = 0; //打开文件方式 输入，不创建 fstream file(strFileName, ios::in|ios::nocreate); //file 为 NULL， 则打开文件失败 if( !file ) { cout &lt;&lt; &quot;文件&quot; &lt;&lt;strFileName &lt;&lt; &quot;不能打开!&quot; &lt;&lt; endl; return 0; } if((nNum==-1)||(nNum&gt;0)) { //输出数据左对齐 cout.setf(ios::left); cout&lt;&lt;setw(6)&lt;&lt;&quot;记录&quot; &lt;&lt;setw(20)&lt;&lt;&quot;姓名&quot;&lt;&lt;setw(10)&lt;&lt;&quot;学号&quot; &lt;&lt;&quot;\t成绩1\t成绩2\t成绩3\t平均分&quot;&lt;&lt;endl; } //当读取文件为结尾时 while( !file.eof() ) { CStudentRec data; file &gt;&gt; data; if(data.chFlag == &#39;A&#39;) { nRec++; if( (nNum == -1) || (nRec &lt;= nNum) ) { cout.setf(ios::left); cout &lt;&lt; setw(6) &lt;&lt; nRec; data.Print(); } } } file.close(); return nRec; }]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2018%2F10%2F10%2FJava%2F</url>
    <content type="text"><![CDATA[java中类名第一个字母都是大写的. 常量分类: 字符型常量: “HelloWorld” 整形常量: 12 小数常量: 0.21 布尔常量: true 空常量: null 数据类型分类: 基本数据类型 注意: 整数默认是int 类型, 浮点数默认是double类型 定义long类型数据的时候, 要加L或者l 定义float类型数据的时候, 要加F或者f 引用数据类型(类, 接口, 数组) 标识符 标识符常见命名规则: 包(就是文件夹, 用于对类进行管理) 全部小写, 举例：com, com.itheima 类 一个单词的首字母大写 多个单词每个单词的首字符大写 方法和变量 一个单词首字母小写 多个单词组成, 从第二个单词开始每个单词的首字母大写. 变量定义和注意事项 变量未赋值, 不能直接使用 变量只在它所属的范围内有效,变量属于它所在的那对大括号 一行上可以定义多个变量, 但是不建议 类型转换 隐式转换 byte, short, char – int –long – float – double 从小变大 强制转换 目标类型 变量名 = (目标类型) (被转换的数据); 建议: 数据作运算，结果应该是什么类型，就用什么类型接受，不要随意转换类型，否则会有精度的损失． 字符串参与加法运算public class OperatorDemo01 { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(a + b + &quot;hello wolrd.&quot;); System.out.println(&quot;hello wolrd&quot; + a + b); System.out.println(&quot;hello world&quot; + a); } } 赋值运算符 注意:扩展的赋值运算符，隐含了强制类型转换． short s = 1; s += 1; //s = (short)(s+1); System.out.println(s); 逻辑运算符 &amp; 和 &amp;&amp;的区别: 相同点: &amp;&amp; 和 &amp; 的结果一样, || 和 | 的结果一样 不同点: &amp; 左边无论是什么, 右边都会执行. &amp;&amp;有短路效果, 左边为FALSE,右边都不执行. 键盘录入 Scanner 导入包中类 : import java.util.Scanner; //快捷键(推荐) Ctrl + shift + o 分配内存，定义对象 Scanner sc = new Sanner(System.in); 产生随机数Random r = new Random(); //产生随机数 for(int i=0; i&lt;10; i++) { int ret = r.nextInt(10); //随机数的范围为[0, 10), 包括0, 不包括10; System.out.println(ret); } int ret = r.nextInit(100) + 1; // 随机数的范围:[1, 100]; Java 中的内存分配 Java 程序在运行时, 需要在内存中分配空间. 为了提高运算效率, 就对空间进行了不同区域的划分, 因为每一片区域都有特定的处理数据方式和内存管理方式. 栈 存储局部变量 堆 存储new出来的东西 方法区(面向对象进阶讲) 本地方法区(和系统相关） 寄存器（给 cpu 使用)- 数组的动态初始化和静态初始化 //动态初始化 int [] myArray = new int[3]; //静态初始化 int [] myArray2 = new int[] {1,2,3}; //简化格式:int[] myArray2 = {1,2,3}; 引用类型: 类, 接口, 数组 输出内容System.out.println(); //输出内容并换行 System.out.print(); //只输出内容,不换行. 方法的形参 基本数据类型: 形参的改变 不影响 实际参数． 引用数据类型: 形参的改变直接 影响 实际参数． 一个对象的内存图 方法共用的内存图 成员变量和局部变量的区别 在类中的位置不同 成员变量： 类中，方法外． 局部变量： 方法中或者方法声明中（形式参数） 在内存中的位置不同 成员变量：在堆内存分配 局部变量: 在栈内存分配 生命周期不同 成员变量随着对象的创建而存在，随着对象的消失而消失 局部变量随着方法的调用而存在，随着方法的调用完成而消失． 初始化值的问题 成员变量有默认值 局部变量没有默认值，必须先定义，赋值，才可以使用． 类名作形式参数和返回值String类 /* * 通过构造方法创建字符串对象和直接赋值方式创建字符串对象的区别 * 通过构造方法创建字符串对象在堆内. * 直接赋值方式创建对象在方法区的常量池. * * ==: * 基本数据类型:：比较是基本数据类型的值是否相等 * 引用数据类型: 比较是引用数据类型的地址值是否相等. * */ public class StringDemo { public static void main(String[] args) { String s1 = new String(&quot;Hello&quot;); System.out.println(&quot;s1 &quot; + s1); System.out.println(&quot;----------&quot;); String s2 = &quot;Hello&quot;; System.out.println(&quot;s2 &quot; + s2); System.out.println(&quot;----------&quot;); System.out.println(&quot;s1 == s2 : &quot; + (s1==s2)); String s3 = &quot;Hello&quot;; System.out.println(&quot;s3 == s2: &quot; + (s3 == s2)); } } 内存图: String类的判断功能 Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. /* * Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 * 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. * String类的判断功能: * boolean equals(Object obj); 比较字符串的内容是否相同 * boolean equalsIgnoreCase(String str); 比价字符串的内容是否相同, 忽略大小写 * boolean startsWith(String str); 比较字符创对象是否以指定的str开始. * boolean endsWith(String str); 比较字符创对象是否以指定的str结尾. * * */ public class StringDemo { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;Hello&quot;; System.out.println(&quot;s1 == s2 :&quot; + s1.equals(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equals(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.equalsIgnoreCase(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equalsIgnoreCase(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;-------------&quot;); } String类的获取功能 /* * String类的获取功能 * int length():获取字符串长度, 其他也就是字符个数. * char charAt(int index); 获取指定索引处的字符 * int indexOf(String str); 获取str在字符串对象中第一次出现的索引 * String substring(int start); 从start开始截取字符串 * String substring(int start, int end); 从start到end之间截取字符串, 包括start, 不包括end * * */ public class StringDemo { public static void main(String[] args) { String s = &quot;helloworld&quot;; System.out.println(s.length()); System.out.println(&quot;-----------&quot;); System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;-----------&quot;); System.out.println(s.indexOf(&quot;ell&quot;));//获取str在字符串对象中第一次出现的索引 System.out.println(&quot;------------&quot;); System.out.println(s.substring(5)); System.out.println(&quot;------------&quot;); System.out.println(s.substring(0, 5));//从start到end之间截取字符串, 包括start, 不包括end } } String类的转换功能 /* char[] toCharArray(): 把字符串转换为字符数组 String toLowerCase(): 把字符串转换为小写字符串 String toUpperCase(): 把字符串转换为大写字符串 */ String类的其空格和分割功能 /* String trim(): 去除字符串两端的空格 String[] spilt(String str): 按照指定符号分割字符串,注意返回的是字符数组 */ public class StringDemo { public static void main(String[] args) { String s = &quot; aa,bb,cc&quot;; String tmpStr = s.trim(); //去除字符串两端的空格, 不包括中间空格 System.out.println(tmpStr); System.out.println(&quot;---------&quot;); String[] strArray = tmpStr.split(&quot;,&quot;);//返回值是字符串数组. for(int i=0; i&lt;strArray.length; i++) { System.out.println(strArray[i]); } } } StringBulder类 作用: 如果对字符串进行拼接操作，每次拼接，都会构建新的String的字符串对象, 即耗时,又浪费空间.而StringBuilder 可以解决这个问题. 内存分配示意图: 常用方法: /* * StringBuilder: 是一个可变的字符串. 字符串数组缓冲类 * * String 和 StringBuilder的区别 * String: 是内容是固定的. * StringBilder: 是内容可变的 * * StringBuilder的常用方法: * public String append(任意类型); * public String reverse(String str); */ public class StringDemo { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); System.out.println(&quot;容量为:&quot; + sb.capacity()); System.out.println(&quot;长度为: &quot; + sb.length()); StringBuilder sb2 = sb.append(&quot;hello&quot;); //返回本身对象的地址 System.out.println(sb); System.out.println(sb2); System.out.println(sb == sb2); //链式编程 sb.append(123).append(123).append(123); System.out.println(sb); System.out.println(&quot;------------&quot;); //public String reverse(String str) sb.reverse(); System.out.println(sb); } } String 和 StringBuilder 相互转换. /* String 和 StringBuilder的相互转换 StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;String public String toString(); 通过toString()就可以实现把StringBuilder转换成String String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;StringBuilder StringBuilder(String str); 通过构造方法, 将String转换成StringBuilder */ public class StringDemo { public static void main(String[] args) { //StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String StringBuilder sb = new StringBuilder(); sb.append(&quot;hello&quot;); String s = sb.toString(); System.out.println(s); //String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; StringBuilder String ss = &quot;hello&quot;; StringBuilder sb2 = new StringBuilder(ss); System.out.println(sb2); } } 自动生成方法/* * * 快速自动生成构造方法 Set() 和 Get()方法. * 右键: source * Generate Constructor from Superclass 无参构造方法 * Generate Constructor using Fields 有参构造方法 * Generate constructor Getter and Setters .. */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 对象数组内存图 集合类 集合类的特点: 长度可变 ArrayLIst 集合的增加 删除 修改 查找的方法 /* * * 获取元素 * public E get (int index): 返回指定索引处的元素 * 集合长度 * public int size():返回集合元素的个数 * 删除元素 * public boolean remove(Object o): 删除指定元素, 返回删除是否成功 * 修改元素 * public E set(int index, E, element):修改指定索引处的元素, 返回被修改的元素 */ public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); System.out.println(arr); System.out.println(arr.size()); System.out.println(arr.remove(&quot;hello&quot;)); System.out.println(arr.set(1, &quot;android&quot;)); System.out.println(arr); } } ArrayList 集合的遍历 //集合的遍历 public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); //标准的遍历操作 for(int x=0; x&lt;arr.size(); x++) { String s = arr.get(x); System.out.println(s); } } } IO流从程序角度出发: 输入流, 文件读数据. 输出流 文件写数据 输出流 import java.io.FileWriter; import java.io.IOException; /* * * 相对路径: 相对于当前项目的路径 * 绝对路径：系统盘符 * flush() 和 close()的方法的区别: * flush(): 刷新缓存区. 流对象还可以继续使用 * close(): 先刷新缓冲区, 然后通知系统释放资源. 流对象不可以再被使用. */ public class FileDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;a.txt&quot;); fw.write(&quot;IO流&quot;); fw.flush(); fw.close(); } } 数据换行: /* * 如何实现数据的换行 * \n 可以实现换行, 但是Windows系统自带的记事本打开并没有换行. * Windows识别的换行符不是 &quot;\n&quot;, 而是&quot;\r\n&quot; * 常见的操作系统识别的换行符: * windows:\r\n * linux: \n * mac: \r * * 如何实现文本的追加 * FileWriter fw = new FileWriter(String fileName, boolean append); */ public class FileWirterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;b.txt&quot;, true); //实现的文本的追加 for(int x=0; x&lt;10; x++) { fw.write(&quot;hello&quot;+x); fw.write(&quot;\r\n&quot;); } fw.close(); } } 输入流public class fileDemo{ public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;fr.txt&quot;); int ch = 0; //输入流 标准操作, 读到末尾时候值为-1 while((ch=fr.read())!=-1) { System.out.print((char)ch); } } } 高效的IO流BufferedReader类 BufferedWriter类 public class fileDemo{ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;fr.txt&quot;); String line; while((line=br.readline())!=null) { System.out.print((line); } } } static 的作用 一个JAVA源文件只能包含一个public类的 /* * static 的特点: * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载, 加载到方法区中 * 总结: static修饰的成员变量和成员方法不属于的所有对象. * */ public class StaticDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Person.school = &quot;wyu&quot;; //静态的加载优先与对象, 随着类的加载而加载 //static赋值, 可以使用类名调用, 无需实例化对象. Person p = new Person(&quot;xiaoming&quot;, &quot;21&quot;); } } class Person{ private String age; private String name; static String school; public Person() { } public Person(String age, String name) { super(); this.age = age; this.name = name; } public void printIf() { System.out.println(name+ &quot; &quot; + age+&quot; &quot;+ school); } } 注意事项: /* * static的注意事项: * 静态方法: * 可以调用静态成员变量和成员方法 * 不可以调用非静态成员方法和非静态成员变量 * 非静态的方法: * 全部都可以调用 * 静态的方法不含有this对象. */ public class StaticDemo_01 { public static void main(String[] args) { Student.school = &quot;s&quot;; Student.sleep(); //方法区中 } } class Student{ public String name; static public String school; public void print() { System.out.println(name + school); } static void sleep() { System.out.println(&quot;slepp&quot;); } } static的应用场景: ​ 工具类: Math类的应用, 其方法中全部被static修饰 自定义工具类package myStatic; //自定义工具类的使用 public class StaticDemo_02 { public static void main(String[] args) { int[] arr = {10, 3, 2, 4, 6}; int max = myArray.max(arr); System.out.println(max); } } ----------------------------------------------------------------------------------- package myStatic; //自定义一个工具类 public class myArray { //用 private修饰构造方法, 使class不可以实例化对象 private myArray() { } static int max(int[] arr) { int max = 0; for(int x=0; x&lt;arr.length; x++) { if(max &lt; arr[x]) { max = arr[x]; } } return max; } } 代码块局部代码块 构造代码块 和 静态代码块 代码块的执行顺序: /* * 代码块块的调用顺序: * BlockTest 静态代码块 &gt;&gt;&gt; BlockTest 的主函数调用了 &gt;&gt;&gt; * Phone 静态代码块 &gt;&gt;&gt;Phone 构造代码块 &gt;&gt;&gt;Phone 调用无参构造 * Phone 构造代码块&gt;&gt;&gt;Phone 调用有参构造 */ public class BlockTestDemo { { System.out.println(&quot;BlockTest 构造代码块&quot;); } static { System.out.println(&quot;BlockTest 静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;BlockTest 的主函数调用了&quot;); Phone p = new Phone(); Phone p1 = new Phone(); } } class Phone { private String name; private String prices; { System.out.println(&quot;Phone 构造代码块&quot;); } static { System.out.println(&quot;Phone 静态代码块&quot;);//随着类的加载而加载 } public Phone() { System.out.println(&quot;Phone 调用无参构造&quot;); } public Phone(String name, String prices) { System.out.println(&quot;Phone 调用有参构造&quot;); this.name = name; this.prices = prices; } // 结果显示: // BlockTest 静态代码块 // BlockTest 的主函数调用了 // Phone 静态代码块 // Phone 构造代码块 // Phone 调用无参构造 // Phone 构造代码块 // Phone 调用无参构造 } 继承/* * 继承: 多个类有共同的成员变量和方法, 抽取到另外一个类中(父类), * 再让多个类去继承这个父类, 我们就可以获取得到父类的成员了. */ public class ExtendsDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Dota d = new Dota(); d.sart(); LOL l = new LOL(); l.sart(); } } //抽取多个类的共性, 得到父类 class Game { String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); } } class Dota extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } class LOL extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } 继承中的成员变量的特点 /* * super: 可以获取父类的成员变量和成员方法, 用法和this相同. */ public class ExtendsDemo_01 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Child c = new Child(); c.show(); } } class Dad { String name = &quot;张三&quot;; } class Child extends Dad{ String name = &quot;张四&quot;; void show() { String name = &quot;张五&quot;; System.out.println(super.name); //调用父类的成员变量 System.out.println(this.name); //调用成员变量 System.out.println(name);// 就近原则:谁离我近就用谁 } } 继承中成员方法的特点 重写和重载的区别 继承中的构造方法的执行顺序 /* * 继承中构造方法的执行循序 * 在有子类继承关系的类中, 创建子类对象, 调用子类的构造方法, * 如果子类构造方法的第一行代码没有调用父类的构造方法, 则会默认的调用父类的无参构造. * 可以使用super()在子类构造方法的第一行中调用父类的构造方法 * 总结: * 始终都要调用父类的构造函数 */ public class ExtedndsDemo { public static void main(String[] args) { Child c = new Child(); } } //运行结果: //调用 父类无参构造 //调用 子类有参构造 //调用 子类无参构造 class Dad { public Dad() { System.out.println(&quot;调用 父类无参构造&quot;); } public Dad(int num) { System.out.println(&quot;调用 父类有参构造方法&quot;); } } class Child extends Dad{ public Child() { this(2); //调用子类的有参构造 System.out.println(&quot;调用 子类无参构造&quot;); } public Child(int num) { //调用父类无参构造 System.out.println(&quot;调用 子类有参构造&quot;); } } 继承的优缺点 ​ 优点: 提高了代码的复用性, 代码的可维护性 ​ 缺点:类的耦合性增强了， ​ 开发原则：高内聚低耦合 ​ 内聚：就是自己完成某件事情的能力. ​ 耦合：类与类的关系 抽象类​ /* * abstract 抽象类 * 抽象类不能实例化 * 抽象类有构造函数 * @Override * 在子类继承抽象类中, 需要重写抽象类的方法 */ public class abstractDemo { public static void main(String[] args) { Cat c = new Cat(&quot;Ruby&quot;, 10); c.eat(); c.run(); Dog d = new Dog(&quot;Bruces&quot;, 7); d.eat(); d.run(); } } abstract class Animals { String name; int age; public Animals(String name, int age) { this.name = name; this.age = age; } public abstract void eat(); //提供接口的功能 public void run() { System.out.println(&quot;run&quot;); } } class Cat extends Animals { public Cat(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The cat eats fishing.&quot;); } } class Dog extends Animals { public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The dog eats food.&quot;); } } 接口/* * Java语言是继承是单一继承, 一个子类只能有一个父类(一个儿子只能有一个亲爹) * Java语言给我们提供了一种机制,用于处理继承单一的局限性, 接口 * * 接口: 接口是一个比抽象类还抽象的类, 接口里所有方法全是抽象方法, 接口和类的关系是implements(实现) * interface * * 接口成员特点: * 只有抽象方法 * 只能有常量 * 默认和只能使用public abstract 修饰方法 * 默认使用 public static final 修饰变量 * 注意: * 接口不能创建对象(不能实例化) * 类与接口的关系是实现关系, 一个类的实现一个接口, 必须实现它所有的方法. * * 类与类: 继承关系, 单一继承, 多层继承 * 类与接口: 实现关系, 多实现 * 接口与接口的关系: 继承关系, 多层继承 */ public class interfaceDemo { public static void main(String[] args) { Tiger t = new Tiger(); t.eat(); Demo d = new Demo(); d.function(); d.method(); } } interface Animals { public static final int age = 10; public abstract void eat(); } class Tiger implements Animals { @Override public void eat() { System.out.println(&quot;eat&quot;); } } //接口与接口的关系是单一继承 interface interA { public abstract void method(); } interface interB extends interA{ public abstract void function(); } //类与接口是实现关系, 多实现 //每个接口都需要一个实现类, Demo是interA, interB的实现类 class Demo implements interA, interB { @Override public void function() { } @Override public void method() { } } 接口的优点: ​ 打破了继承的局限性， ​ 对外提供规则 ​ 降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发效率． 分析问题： ​ 分析: 由下至上, 不断向上抽取的过程 ​ 实现: 由上至下, 先实现共性 ​ 使用: 使用具体的子类. ​ /* 抽象类可以继承普通类 */ class Person { String name; int age; public void sleep() { System.out.println(&quot;sleep&quot;); } public void eat() { System.out.println(&quot;eat&quot;); } } abstract class Player extends Person{ public abstract void study(); } 匿名对象匿名对象: 没有名字的对象 应用场景： ​ 当方法只调用一次的时候, 可使用匿名对象 ​ 可以当作参数进行传递 //普通创建对象 Student st = new Student(); //匿名对象 new Student() //匿名对象可以当作参数 function (new Studnet); final​ 自定义常量必须初始化, 可以选择显示初始化或者构造初始化 多态/* * 多态的前提: * 子父类的继承关系 * 方法的重写 * 父类引用指向子类对象 * 动态绑定: * 运行期间调用的方法,是根据具体类型. */ public class Demo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Animals a = new Cat(); //多态的实现 a.eat(); } } class Animals{ public void eat() { System.out.println(&quot;吃东西&quot;); } } class Cat extends Animals { //方法的重写 public void eat() { System.out.println(&quot;猫吃鱼&quot;); } } 多态成员的特点: /*成员变量: 编译时看的是左边, 运行时看的是左边 成员方法: 编译时看的是左边, 运行时看的是右边 静态防范: 编译时看的是左边, 运行时看的也是左边. 总结: 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法)看的都是左边. */ Dad d = new Kid(); //左边是 Dad d //右边是 new Kid() 多态中的向上转型和向下转型 Anmials a =new Dog(); //多态实现, 向上转型, 子类转化为父类 Dog d = (Dog)a; //向下转型, 父类转化为子类 多态的优缺点以及如何实现多态 /* * 多态的优缺点: * 优点: 可以提高可维护性(多态提前保证的), 提高代码的扩展性, * 缺点:无法直接访问子类特有的成员． */ public class Demo02 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); PhoneFactory pf = new PhoneFactory(); //实现多态 pf.createPhone(new XiaoMi()); //调用匿名对象 pf.createPhone(new HongMi()); } } //实现多态. class PhoneFactory { //用父类对象作参数 public void createPhone(Phone p) { p.create(); } } interface Phone { public abstract void create(); } class XiaoMi implements Phone { @Override public void create() { System.out.println(&quot;小米手机&quot;); } } class HongMi implements Phone{ @Override public void create() { System.out.println(&quot;红米手机&quot;); } } 权限修饰符​ public: 当前类, 相同包下不同的类, 不同包下的类 可以访问 ​ default: 当前类, 相同包下的不同类 可以访问 ​ private:当前类 ​ protected: 当前类, 不同包下的类 ​ default 和 protected 的区别: ​ default: 当前包下使用 ​ protected: 让子类对象使用 内部类​ 方法内部类 ​ 局部内部类 ​ 匿名内部类 迭代器迭代器是依赖于集合的， 相当于集合的一个副本，当迭代器在操作的时候， 如果发现和集合不一样， 则抛出异常（并发修改异常） foreach：增强for循环， 一般用于遍历集合或者数组。 List的常用子类​ ArrayList： 底层数据结构是数组， 查询快，增加删除慢 ​ LinkedList： 底层数据结构是链表，查询慢， 增加删除块 多线程多线程的执行方式 /* * 多线程的实现方式： * 方式1：一种方法是将声明为Thread的子类。 该子类应重写Thread类的run方法，接下来可以分配并启动子类的实例。 * * CPU执行程序的随机性 */ public class Demo { public static void main(String[] args) { myThread mt = new myThread(); mt.setName(&quot;Thread 1 &quot;); mt.start(); myThread mt1 = new myThread(); mt1.setName(&quot;Thread 2 &quot;); mt1.start(); myThread mt2 = new myThread(); mt2.setName(&quot;Thread 3 &quot;); mt2.start(); } } 多线程出现数据访问问题： /* 要有多个线程 要有被多个线程所共享的数据 多个线程并发的访问共享数据 */ synchronized: 同步（锁）， 可以修饰代码块和方法， 被修饰和代码块和方法一旦被某个线程访问，则直接被锁住，其他线程无法访问。 同步代码块： synchronized{ ...... } 同步方法： public synchronized void method(); note:2018-10-22 17:51:18 == 与 equals== : 它的作用判断两个对象的地址是否相等, 判断基本数据类型的值是否相等. equals: String 中的 equals() 方法是被重写的, 因为 Object 的 equals 方法是比较对象的内存地址.而 String 的 equals 方法是比较对象的值. 线程, 程序, 进程的基本概念和他们之间关系1. 线程和进程相似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 与线程不同的是同类的多个线程共享同一个内存空间和一组系统资源, 所以系统产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因如此, 线程也被称称为轻量级进程. 2. 程序是含有指令和数据的文件, 被存储在磁盘或者其他的数据存储设备中, 也就是说程序是静态的代码. 3. 进程是程序一次运行过程, 是系统运行的基本单位, 因为进程是动态. 系统运行一个程序即是一个进程从创建, 运行到消亡的过程.简单来说, 一个进程就是一个执行中的程序, 它在计算机中的一个指令接着一个指令的执行, 同时, 每个进程还占某些系统资源如CPU时间, 内存空间, 文件, 输入输出设备的使用权等等. 4. 换句话说, 当程序在执行时, 将会被操作系统载入内存中, 线程是进程划分成的更小的运行单位. 线程和进程最大不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响. 从另一角度出发, 进程属于操作系统的范畴, 主要是同一段时间内, 可以同时执行一个以上的程序, 而线程则是在同一个程序内几乎同时执行一个以上的程序段. 线程的基本状态和基本状态的定义 新建（new): 新创建了一个线程对象. 可运行(runnable):线程对象创建后, 其他线程(比如main线程)调用了该对象的 start() 方法. 该状态的线程位于可运行线程池中, 等待被线程调度选中, 获取CPU的使用权. 运行(running): 可运行(runnable)的线程获得了 CPU 时间片(time slice), 执行程序代码. 阻塞(block): 阻塞状态是指线程因为某种原因放了CPU的使用权, 也即让出了 CPU time slice. 暂时停止运行. 直到线程进入可运行的状态, 才有机会再次获得 CPU time slice 转到运行状态. 阻塞的情况分三种: 等待阻塞 同步阻塞 其他阻塞 死亡: 线程 run(), main()方法执行结束后, 或者因异常退出了run()方法, 则该线程接受了生命周期. 死亡的线程不可再次复生. 在 Java 中定义一个不做事且没有参数的构造方法的作用 Java 程序在执行子类的构造方法之前, 如果没有用super()来调用父类特定的构造方法, 则会调用父类中没有参数的构造方法. 因此父类中只定义了有参数的构造方法, 而在子类的构造方法中又没有的super()来调用父类中特定的构造方法, 则编译时将方法错误, 因为 Java 程序在父类中找不到没有参数的构造方法可执行. 解决方法是咋父类里加上一个不做事且没有参数的构造方法. Java 和 C++的区别都是面向对象的语言， 都支持封装，继承和多态 Java 不提供指针来直接内存，程序内存更加安全 Java 的类是单继承的， C++支持多继承； 虽然 Java 的类不可以多继承， 但是接口可以多继承 Java 有自动内存管理机制， 不需要程序员手动释放无用内存 接口和抽象类的区别： 接口的方法默认是 public， 所有方法在接口中不能有实现，抽象类可有非抽象的方法 接口中实例变量默认是 final 类型， 而抽象类中则不一定 一个类可以实现多个接口， 但最多只能实现一个抽象类 一个类实现接口的话， 要实现接口的所有方法， 而抽象类不一定。 接口不能用 new 实例化， 但可以声明， 必须应用一个实现该接口的的对象 从设计层面来说， 抽象是对类的抽象，是一种模板设计； 接口是行为的抽象， 是一种行为的规范。 静态方法和实例方法 在外部调用静态方法，可以使用“类名.方法名”的方式， 也可以使用“对象.方法名”的方式。 而实例方法只有后面这种方式。 也就是说， 调用静态方法可不需要创建对象。 静态方法在访问本类的成员时， 只允许访问静态成员（即静态成员变量和静态方法）， 而不允许访问实例成员变量和实例方法； 实例方法则无此限制。 对象的相等与指向他们的引用相等，两者有什么不同？ 对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 帮助子类做初始化工作。 注释和注解的区别 Java中的注释和其他编程语言一样，注释的内容不会被编译运行，知识源代码中对代码的解释说明， 提高源代码的可读性。 Java中的注解（Annotation），也叫元数据，是Java 5以后版本引入的一个特性 注解与类、接口、枚举是在同一个层次，可以用来标注包、类、字段、方法、局部变量、方法参数等元素，达到对这些元素的面数和说明。 注解是可以允许 jvm 在运行中读取它，这一点与注释完全不同。 注解作用： 编写文档， 代码分析， 编译检查]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F08%2F28%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[换行：1.方法1： 连续两个以上空格+回车。 首行缩进两个字符：（每个表示一个空格，连续使用两个即可） 1.&amp;ensp;半角的空格 ​ 2.&emsp;全角的空格 字体、字号、颜色 - &lt;font color=red&gt;red&lt;/font&gt; - &lt;font color=blue&gt;blue&lt;/font&gt; - &lt;font color=green&gt;green&lt;/font&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clovers]]></title>
    <url>%2F2018%2F08%2F28%2Fclover%2F</url>
    <content type="text"><![CDATA[快捷键技巧： Ctrl+W关闭页面Ctrl+Tab切换页面]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>clovers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;stromzhang&quot; git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知道自己不知道的]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[入门篇： python 和 java Script 选择 入门语言 学习使用操作系统linux 学习使用编程工具 vs 和 vs code 正式入门 推荐文章： The Key To Accelerating Your Coding Skills 编程技巧方面：怎么把程序写好的书（代码大全）。 java语言学习：Java核心技术卷一， spring: spring in action 操作系统：鸟哥的Linux私房菜 网络协议：HTTPS文档， 数据库设计：慕课网 数据库设计那些事 数据库：MySQL必知必会 前端方面： 编码方面：ASCII, UNICODE, 编程工具方面：JAVA VS CODE 版本管理工具：GIT, 调试前端工具： 数据库设计工具： java语言 综合性实力最强 IDE 版本管理工具 git 调试前端工具 数据库设计工具 程序员修养 英文能力 问问题的能力 写代码的修养 安全防范意识 软件工程和上线规范 编程规范 专业技术篇 编程语言: c, c++, java 理论学科: 算法与数据结构，网络模型，计算机原理，操作系统原理，编译原理，数据库原理。（工人和工程师的差别） 系统知识：Unix, Linux, TCP/IP, C10K 从业方向：底层，大数据，分布式开发等等。 软件设计能力&emsp;&emsp;工程师走向架构师 程序员荒谬之言还是至理名言 如果你把一个技术搞精搞深，你的知识面自然会很广的。 面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会（依据自己兴趣学习） 为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。 不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。 永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。（特别赞同） Teach Yourself Programming in Ten Years——用十年教会自己编程]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>系统知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
