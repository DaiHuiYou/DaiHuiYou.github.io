<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F05%2F18%2Fpython%2F</url>
    <content type="text"><![CDATA[参数在 Python 中定义函数， 可以用必选参数，默认参数，可变参数，关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意， 参数的定义顺序必须是： 必选参数，默认参数，可变参数， 命名关键字参数， 关键字参数。 递归函数在函数内部， 可以调用其他函数。 如果一个函数在内部调用自身本身，这个函数就是递归函数。 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)： 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 在很多编程语言中， 针对字符串提供了很多各种截取函数（substring），其实目的就是对字符串切片， Python没有针对字符串的截取函数，字需要切片一个操作就可以完成了。 迭代如果给定一个 list 或 tuple， 我们可以通过 for 循环来遍历这个 list 或 tuple， 这种编译我们称为 迭代（iteration） 在Python中，迭代是通过for ... in来完成的，而很多语言比如C语言，迭代 list 是通过下标完成的，比如 Java代码： for (i=0; i&lt;list.length; i++) { n = list[i]; } 可以看出，Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。 list 这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如 dict 就可以迭代： 判断是否可迭代对象， 方法通过 collections 模块的 Iterable 类型判断 列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式。 生成器如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 LIst， 从而节省大量的空间。 在Python中，这种一边循环一边计算的机制，称为生成器。 要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator 要一个一个打印出来，可以通过next()函数获得generator的下一个返回值 我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它， 定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator： generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 generator 是非常强大的工具， 在 Python中，可以简单地把列表生成式改成 generator， 也可以通过函数实现复杂逻辑的 generator。 生成器： 一个列表生成式的[]改成(), 普通函数变为 generator 就是把 函数体中加入 yelid。 普通函数调用直接返回结构， generator 函数的调用实际是一个generator对象。 迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 凡是可作用于 for 循环的对象都是 Iterable 类型 凡是可作用于 next() 函数的对象都是 Iterator 类型 集合数据类型如 list， dict， str 是 Iterable， 但不是 Iterator， 不过可以通过 iter() 函数获得一个 Iterator 对象。 Python 的 for 循环的本质就是通过不断调用 next() 函数实现的。 函数式编程函数式 Python 内建支持的一种封装， 我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。 函数就是面向过程的程序设计的基本单元。 函数式编程时一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数只要有输入是确定的，输出就确定。 函数式编程的一个特点就是， 允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ 高阶函数 函数本身也可以赋值给变量，即： 变量可以指向函数。 函数名就是指向函数的变量。 传入函数： 一个函数可以接受另一个函数作为参数，这种函数就称之为高阶函数。 在数学总他们叫算子（运算符）或泛函。微积分总的导数就是常见的例子，因为它映射一个函数到另一个函数。 map / reduce map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 filter Python内建的filter()函数用于过滤序列。 和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 返回函数 把函数作为结果值返回 内部函数可以引用外部函数的参数和局部变量。当外部函数返回内部函数， 相关参数和变量都保存在返回的函数中，这种称为”闭包”（Closure） 返回函数时不要引用任何循环变量， 或者或许会发生变化的变量。 匿名函数 在传入函数是，有些时候，不需要显示的定义函数， 直接传入匿名函数更方便。 关键字 lambda 表示匿名函数，冒号前面表示函数参数。 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，在利用变量来调用函数。 匿名函数可以作为函数返回值返回 装饰器 由于函数也是一个对象， 而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。 增强函数的功能，在代码运行期间动态增加功能的方式，称之为 “ 装饰器 ” 在面向对象（OOP）的设计模式中，decorator被称为装饰模式， OOP的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外， 直接从语法层次支持 decorator。 Python 的 decorator 可以用函数实现， 也可以用类表现。 偏函数（Partial function) 简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分函数，从而在调用时更简单。 模块 为了编写可维护的代码， 把很多函数分组，分贝放到不同的文件里。 在 Python 中， 一个 .py 文件就称之为一个模块 (Module) 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。但不要与内置函数函数名字冲突。 为了解决不同的人编写的模块名相同， Python 引入了按目录来组织模块的方法， 称为包（Package）。 每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。 任何模块代码的第一个字符串都被视为模块的文档注释； 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。 正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等； 类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名； 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。 面向对象编程OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数， 每个对象都可以接受其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 给对象发送消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。 class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的 通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问. 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 继承和多态 新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态： 调用方只管调用，不管细节。 调用方和定义方可以责任分清。当我们新增一个 子类时， 只要确保 run()方法编写正确，不用管原来的代码是如何调用的。 这就是著名的 ‘开闭原则 ’ 对扩展开放： 允许新增 Animal 子类； 对修改封闭： 不需要修改依赖 Animal 类型的 run_twice 等函数 静态语言 vs 动态语言 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 获取对象信息 能用type()判断的基本类型也可以用isinstance()判断 总是优先使用 isinstance() 判断类型，可以将指定类型及其子类“一网打尽”。 如果要获得一个对象的所有属性和方法，可以使用dir()函数 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法 通过内置的一系列的函数，我们可以任意一个 Python 进行剖析，拿到其内部的数据。 要注意的是，只有在不知道对象信息的时候，我们才会获取对象信息。 实例属性和类属性 由于 Python 的动态语言，根据类创建的实例可以任意绑定属性。 给实例绑定属性的方法是通过实例变量， 或则通过 self 变量。 直接在class中定义属性，这种属性是类属性 实例属性属于各个实例所有，互不干扰。 类属性属于类所有，所有实例共享一个属性 不要对实例属性和类属性使用相同的名字，否则产生难以发现的错误。 使用 slots 通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。 限制实例的属性， 只允许对 Student 实例添加 name 和 age 属性。为了达到限制的目的， 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__ 使用@property Python内置的@property装饰器就是负责把一个方法变成属性调用 @property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。 @property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 多重继承在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为 MixIn。 MixIn 的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 定制类 __str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。 __repr__()。但是通常__str__()和__repr__()代码都是一样的 如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 要表现得像list那样按照下标取出元素，需要实现__getitem__()方法 任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用 __call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。 怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象 通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。 使用枚举类 枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能： @unique装饰器可以帮助我们检查保证没有重复值。 Enum可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。 Python提供了Enum类来实现这个功能： from enum import Enum Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;)) 使用元类动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。 当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象 type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)...的定义： 正常情况下，我们都用class Xxx...来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类 metaclass 除了使用type()动态创建类以外，要控制类的创建行为，还可以使用 metaclass。 当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。 但是如果我们想创建出类呢？那就必须根据 metaclass 创建出类，所以：先定义 metaclass，然后创建类。 连接起来就是：先定义 metaclass，就可以创建类，最后创建实例。 异常处理Python的错误其实也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。 捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。 raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型 调用栈： 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。 调试 第一种方法： 简单直接粗暴有效，就是用print()把可能有问题的变量打印出来看看。 用print()最大的坏处是将来还得删掉它，想想程序里到处都是print()，运行结果也会包含很多垃圾信息。 第二种方法： 断言， 凡是用print()来辅助查看的地方，都可以用断言（assert）来替代： assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。 第三种方法： logging() 替换为 logging 是第 3 种方式 ， 和 assert 比， logging 不会抛出错误， 而且可以输出文件。 logging的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。 logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件 启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态. pdb.set_trace() ,这个方法也是用 pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点 单元测试测试驱动开发”（TDD：Test-Driven Development）。 编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。 每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的 另一种重要的断言就是期待抛出指定类型的Error，比如通过d[&#39;empty&#39;]访问不存在的key时，断言会抛出KeyError 单元测试是用来对一个模块，一个函数或则一个类来进行正确性检验的测试工作。 单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。 这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。 单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。 单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。 单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。 文档测试 Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。 实现自动执行写在注释中的这些代码 doctest 非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest 的注释提取出来。用户看文档的时候，同时也看到了doctest。 IO 编程IO 在计算机中指 Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要 IO接口。 同步IO 是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10秒 后写入磁盘，再接着往下执行。 异步IO 是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行。 同步和异步的区别就在于是否等待 IO 执行的结果。 文件读写在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。 Python引入了 with 语句来自动帮我们调用close()方法 像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。 StringIO就是在内存中创建的file-like Object，常用作临时缓冲。 StringIO很多时候，数据读写不一定是文件，可以在内存中读写。 StringIO 顾名思义就是在内存中读写 str StringIO 和 ByteIO 是在内存中中操作 str 和 bytes 的方法， 使得和读写文件具有一致的接口 操作文件和目录 操作系统提供的命令指示简单地调用了操作系统的提供的接口函数， Python 内置的 os 模块也可以直接调用操作系统提供的接口函数 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符 要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便 Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中 序列化 在程序运行过程中， 所有的变量都是在内存中，我们把变量从内存中变成可存储或传输的过程称之为序列化。 在 Python 中叫 picking， 在其他语言中也被称之为 serialization， marshalling， flattening 等等。 序列化之后， 就可以把序列化后的内容写入磁盘，或则通过网络传输到别的机器上。 反过来， 把变量内容从序列化的对象重新读到内存里称之为反序列化。 即 unpickling。 Python提供了pickle模块来实现序列化 JSON 如果我们在不同的编程语言之间传递对象，就必须把对象序列化为标准格式， 比如 XML， 但更好的方法是序列化为 JSON， 因为 JSON 表示出来就是一个字符串，可以被所有语言读取， 也可以方便存储到磁盘或则通过网络传输。 JSON 不仅是标准格式， 并且比 XML 更快， 而且直接在 Web 页面读取。 JSON 表示的对象就是标准的 JavaScript 语言的对象 Python内置的json模块提供了非常完善的Python对象到 JSON 格式的转换 dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。 通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了__slots__的class Python 语言特定的序列化模块是 pickle， 但如果把序列化搞得更通用， 更符合 Web 标准， 就可以使用 json 模块。 json模块的dumps()和loads()函数是定义得非常好的接口的典范 进程和线程多任务： 就是操作系统可以同时运行多个任务。 单核 CPU， 也可以执行多任务。 真正的并行执行多任务只能在多核 CPU 上实现， 但是， 由于任务数量远远多于 CPU 的核心数量， 所以，操作系统也会自动把任务轮流调度到每个核心上执行。 多个线程可以同时执行， 多线程的执行范式和多进程一样，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样， 当然，正确地同时执行多线程需要多核 CPU 才可能实现。 我们要同时执行多个任务：第一种方法， 启动多个进程， 每个进程虽然只有一个线程， 但多个进程可以一块执行多个任务。 第二种方法，启动一个进程，在一个进程内启动多个线程，这样，多个线程可以一块执行多个任务。 多任务的实现 3 种方式： 多进程模式： 多线程模式： 多进程 + 多线程模式 同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调。 线程是最小的执行单元， 而进程有至少一个进程组成，如何调度进程和线程，完全有操作系统决定，程序自己不能决定什么时候执行， 执行多长时间。 多进程Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程。 multiprocessingPython是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块 multiprocessing模块提供了一个Process类来代表一个进程对象 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Pool如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。 子进程在Unix/Linux下，可以使用fork()调用实现多进程。 要实现跨平台的多进程，可以使用multiprocessing模块。 进程间通信是通过Queue、Pipes等实现的。 多线程多线程和多进程最大不同在于， 多进程中，同一个变量，各自有一份拷贝在每个进程中，互不影响，而多线程中，所有变量都有所有线程共享，所有，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时该一个变量， 把内容改乱。 高级语言的一条语句在 CPU 执行时是若干条语句 锁的好处是确保了某段关键代码只能由一个线程从头到尾地执行，坏处当然也很多，首先阻止了多线程的并发执行，不同的线程持有不同的锁，可能会造成死锁，导致多个线程全部挂起。 多核 CPU多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。 Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。 ThreadLocal]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)1 . 选择排序// 未优化 template&lt;typename T&gt; void selectionSort1(T arr[], int n) { for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[i]) swap(arr[j], arr[i]); } } return; } // 优化 template &lt;typename T&gt; void selectionSort2(T arr[], int n) { for (int i = 0; i &lt;= n - 1; i++){ int minIndex = i; for (int j = i+1; j &lt;= n - 1; j++) { if (arr[minIndex] &gt; arr[j]) minIndex = j; } swap(arr[minIndex], arr[i]); } return; } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 selectionSort1 : 2.208 s selectionSort2 : 0.108 s 2. 插入排序// 未优化 template&lt;typename T&gt; void InsertionSort1(T arr[], int n) { for (int i = 1; i &lt; n; i++) { for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) { swap(arr[j], arr[j - 1]); } } } // 优化 template&lt;typename T&gt; void InsertionSort2(T arr[], int n) { for (int i = 1; i &lt; n; i++) { T e = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--) arr[j] = arr[j - 1]; arr[j] = e; } return; } 测试 从1万个 0~100 的随机数中，从小到大排序。 InsertionSort1 : 2.653 s InsertionSort2 : 0.064 s 3. 希尔排序// 希尔排序 template&lt;typename T&gt; // n 表示数组 capacity void shellSort(T arr[], int n) { int cnt = n - 1; // 数组元素个数 int tmp = 0; // 临时变量 // d：distance， for (int d = n/2; d&gt;=1; d=d/2) { // 遍历 for (int i = d; i &lt;=cnt; i++) { // 插入排序 tmp = arr[i]; for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) { arr[j + d] = arr[j]; arr[j] = tmp; } } } } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 Insertion Sort : 6.332 s Shell Sort : 0.029 s O(nlogN)1. 归并排序2. 快速排序int __partition(int arr[], int l, int r) { int v = arr[l]; int j = l; for (int i = l + 1; i &lt;= r; i++) { if (arr[i] &lt; v) { j++; swap(arr[i], arr[j]); } } swap(arr[j], arr[l]); return j; } void __quickSort(int arr[], int l, int r) { if (l &gt;= r) return; int p = __partition(arr, l, r); __quickSort(arr, l, p - 1); __quickSort(arr, p + 1, r); } // 快速排序 void quickSort(int arr[], int n) { __quickSort(arr, 0, n - 1); } 3. 堆排序void shiftDown(int arr[], int n, int k) { while (2 * k + 1 &lt; n) { int j = 2 * k + 1; if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) { j++; } if (arr[k] &lt; arr[j]) { swap(arr[k], arr[j]); k = j; } else break; } } void heapSort1(int arr[], int n) { // heapify for (int i = (n - 1) / 2; i &gt;= 0; i--) { shiftDown(arr, n, i); } for (int i = n - 1; i &gt; 0; i--) { swap(arr[0], arr[i]); shiftDown(arr, i, 0); } } // n 为数组元素个数 // k 当前要筛选的索引 // arr[0] 为临时存储变量 void shift(int arr[], int n, int k) { while (2 * k &lt; n) { int j = 2 * k; if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if (arr[k] &lt; arr[j]) { // arr[j] 与 arr[k] 交换 arr[0] = arr[j]; arr[j] = arr[k]; arr[k] = arr[0]; k = j; } else break; } } // n 为数组元素个数 // arr[0] 为临时存储变量 void heapSort2(int arr[], int n) { for (int i = (n - 1) / 2; i &gt;= 1; i--) { shift(arr, n, i); } for (int i = n - 1; i &gt;=2; i--) { // arr[i] 与 arr[1] 交换 arr[0] = arr[i]; arr[i] = arr[1]; arr[1] = arr[0]; shift(arr, i, 1); } } 测试 从100 万个 0~100 的随机数中，从小到大排序。 Heap Sort 1 : 2.228 s Heap Sort 2 : 0.248 s]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer]]></title>
    <url>%2F2018%2F12%2F02%2FC%2B%2BPrimer%2F</url>
    <content type="text"><![CDATA[Variables and Basic TypesC++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably. To support 「separate complication」, C++ distinguishes between declaration and definition. The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. 1. Main Function and Library「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main. Standard library collection of types and function that every C++ compiler must support. They also tend to refer to particular part of the library by referring to a library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes. By default, reading cin flushes cout, cout is also flushed when the program end normally. To handle input, we use an object of type istream named cin, This object is also referred to as the standard input. In C++ an expression yields a result. When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1. The word 「nullptr」 is a pointer literal. The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand. To attain a declaration that is not also a definition, add the 「extern」 keyword. An extern that has an initializer is a definition. 2. Variables Initialization Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one. Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class. We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer. Separate compilation lets us split our programs into several files, each of which can be compiled independently. Declaration and Definition To support separate compilation, C++ distinguishes between declarations and definitions. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer: extern int i; // declares but does not define i int j; // declares and defines j Variables must be defined exactly once but can be declared many times. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. Reference A reference is not an object. Instead, a reference is just another name for an already existing object. A reference must be initialized A reference may be bound only to an object, not to a literal or to the result of a more general expression: Unlike a reference, a pointer is an object in its own right. Unlike a reference , a pointer need not be initialized at the time it is defined. references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference. 3. Pointer Pointer Value The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. It can be a null pointer , indicating that it is not bound to any object. Using a Pointer to Access an object When a pointer points to an object, we can use the dereference operator (the * operator) to access that object: We may dereference only a valid pointer that points to an object. Dereferencing a pointer yields the object to which the pointer points. Null Pointers A null pointer does not point to any object. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. nullptr is a literal that has a special type that can be converted to any other pointer type. Modern C++ programs generally should avoid using NULL and use nullptr instead. void* Pointers The type void* is a special pointer type that can hold the address of any object. We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object. Understanding Compound Type Declarations A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types Reference to Pointers A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer. int i = 42; int *p; // p is a pointer to int int *&amp;r = p; // r is a reference to the pointer p r = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i *r = 0; // dereferencing r yields i, the object to which p points; changes i to // the base type of the declaration says that r is a reference to a pointer to an int. It can be easier to understand complicated pointer or reference declarations if you read them from right to left. 4. const QualifierBy Default, const Objects Are Local to a File We want to define the const in one file, and declare it in the other files that use that object. To share a const object among multiple files, you must define the variable as extern. References to const const int ci = 1024; const int &amp;r1 = ci; // ok: both reference and underlying object are const r1 = 42; // error: r1 is a reference to const int &amp;r2 = ci; // error: non const reference to a const object Initialization and Reference to const In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression A Reference to const May Refer to an Object That Is Not const int i = 42; int &amp;r1 = i; // r1 bound to i const int &amp;r2 = i; // r2 also bound to i; but cannot be used to change i r1 = 0; // r1 is not const; i is now 0 r2 = 0; // error: r2 is a reference to const const Pointers and Pointer to const Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored int errNumb = 0; int *const curErr = &amp;errNumb; // curErr will always point to errNumb const double pi = 3.14159; const double *const pip = &amp;pi; // pip is a const pointer to a const object On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. int *p = p3; // error: p3 has a low-level const but p doesn&#39;t p2 = p3; // ok: p2 has the same low-level const qualification as p3 constexpr and Constant Expressions A constant expression is an expression whose value cannot change and that can be evaluated at compile time. Such functions must be simple enough that the compiler can evaluate them at compile time. Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions. Pointers and constexpr const int *p = nullptr; // p is a pointer to a const int constexpr int *q = nullptr; // q is a const pointer to int The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines. constexpr int *np = nullptr; // np is a constant pointer to int that is null int j = 0; constexpr int i = 42; // type of i is const int // i and j must be defined outside any function constexpr const int *p = &amp;i; // p is a constant pointer to the const int i constexpr int *p1 = &amp;j; // p1 is a constant pointer to the int j 5. Dealing with Types Type Aliases Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used. We can define a type alias in one of two ways. Traditionally, we use a typedef typedef char *pstring; const pstring cstr = 0; // cstr is a constant pointer to char const pstring *ps; // ps is a pointer to a constant pointer to char When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char, the base type is char and the is part of the declarator. The auto Type Specifier Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer. The decltype Type Specifier Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression: decltype(f()) sum = x; // sum has whatever type f returns const int ci = 0, &amp;cj = ci; decltype(ci) x = 0; // x has type const int decltype(cj) y = x; // y has type const int&amp; and is bound to x decltype(cj) z; // error: z is a reference and must be initialized decltype and References Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment // decltype of an expression can be a reference type int i = 42, *p = &amp;i, &amp;r = i; decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int decltype(*p) c; // error: c is int&amp; and must be initialized // decltype of a parenthesized variable is always a reference decltype((i)) d; // error: d is int&amp; and must be initialized decltype(i) e; // ok: e is an (uninitialized) int // The type is a reference to the type of the left-hand operand. int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // equal to :int &amp;d = a; Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 6. Defining Our Own Data StructuresIn C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes. Defining the Sales_data Type struct Sales_data { std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body. It is a common mistake among new programmers to forget the semicolon at the end of a class definition. Writing Our Own Header Files In order to ensure that the class definition is the same in each file, classes are usually defined in header files. classes are stored in headers whose name derives from the name of the class. Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations. A Brief Introduction to the Preprocessor The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif. Preprocessor variable names do not respect C++ scoping rules. Preprocessor variables, including names of header guards, must be unique throughout the program. 7. Defined Termsconst reference Colloquial synonym for reference to const. constant expression Expression that can be evaluated at compile time. declaration Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared. definition Allocates storage for a variable of a specified type and optionally initializes the variable. object A region of memory that has a type. A variable is an object that has a name.outer scope Scope that encloses another scope. preprocessor variable Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled. reference An alias for another object. struct Keyword used to define a class. typedef Defines an alias for another type. void* Pointer type that can point to any nonconst type. Such pointers may not be dereferenced. Strings, Vectors, and ArraysC++ defines a rich library of abstract data types. Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections. Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector. The built-in types represent facilities present in most computer hardware, such as numbers or characters. The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly. A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type. 1. Namespace using DeclarationHeaders Should Not Include using Declarations. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts. 2. Library string TypeA string is a variable-length sequence of characters. To use the string type, we must include the string header. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization. string s5 = &quot;hiya&quot;; // copy initialization string s6(&quot;hiya&quot;); // direct initialization string s7(10, &#39;c&#39;); // direct initialization; s7 is cccccccccc The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered. Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator. Adding Literals and strings When we mix strings and string or character literals, at least one operand to each + operator must be of string type Dealing with the Characters in a string In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Processing Every Character? Use Range-Based for If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」. The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in declaration is initialized from the value of the next element in expression. Using a Range for to Change the Characters in a string If we want to change the value of the characters in a string, we must define the loop variable as a reference type. string s(&quot;Hello World!!!&quot;); // convert s to uppercase for (auto &amp;c : s) // for every char in s (note: c is a reference) c = toupper(c); // c is a reference, so the assignment changes the char in s cout &lt;&lt; s &lt;&lt; endl; a subscript The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position. Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1]. The value in the subscript is referred to as 「a subscript」 or 「an index」. The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined. 3. Library vector TypeA vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」. Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called 「instantiation」. vector&lt;int&gt; ivec; // ivec holds objects of type int vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items vector&lt;vector&lt;string&gt;&gt; file; // vector whose elements are vectors 「vector is a template, not a type.」 Types generated from vector must include the element type. NoteConventions for Variable Names：变量名称的约定 separate compilation：独立编译 tend to：倾向于 fits in：适合 so far：目前为止 the indicated value: 指定的值 yields a result : 产生一个结果 bound to (bind to) :绑定 plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析 evaluated : 求…值 do not respect C++ scoping rules: 不遵守作用域规则 be used to： 用于 associative:联合 container:容器，集装箱 derived-Class: 派生类/子类 alias:别名 override: 重写 overloading: 重载 directive:指令 redirect: 重定向 indicator:指示 arguments: 实参 library facility:库功能 (工具库) statements:语句 extensive: 大规模 mechanisms: 机制 string literal: 字符串字面量 semicolon: 分号 block: 代码块 iteration: 重复 comments: 注释 built-in type： 内置类型 backslash： 反斜杠 carriage return： 回车 Escape Sequences: 转义序列 initializer: 初始化 commas： 逗号 type specifier: 类型说明符 Identifiers: 标识符 inclusive：包括 Nested Scopes：嵌套范围 fetch: 获取 type modifiers: 类型修饰符 underlying: 底层 Qualifier: 限定符 plain: 原始,素 synonym: 同义词 groups: 分组 implement：实现 strategy：a plan of action 策略 contents:内容 cover: 介绍 / 覆盖 punctuation: 标点 capitalize: 大写字母 subscript：下标]]></content>
      <categories>
        <category>原版书籍</category>
      </categories>
      <tags>
        <tag>原版书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硅谷来信]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[收获比较大的方面： 学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。 科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 结论可以证实，但不可证伪。为什么呢？ 就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？ 总之， 因为未来的不确定，结论可以证实，不能证伪。 别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。 语录： 对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[编程规范 #ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; } 使用链表的例子： 页帧管理​ 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高质量C/C++编程指南]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%AB%98%E8%B4%A8%E9%87%8FC-C-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[文件结构 程序的版式 命名规则 表达式和基本语句 常量 函数设计 内存管理 c++函数的高级特性]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2018%2F10%2F11%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[匿名对象 匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。 class AA { public: AA() { cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } ~AA() { cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl; } }; void main() { //AA a = AA(); //产生一个匿名对象， 有一个变量去接，不会调用析构函数。 AA b; //调用拷贝构造函数。 b = AA(); //匿名对象， 会调用拷贝构造函数和析构函数。 system(&quot;pause&quot;); } 异常 抛出异常是跨函数的。 c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。 栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。 异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。 引用 引用分为普通引用和常引用 //常引用 //常引用当函数参数 ,可以传字面量或者实参 void func1(const int&amp; num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } //普通引用当函数参数， 传实参 void func2(int &amp;num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } void main() { int a = 10; int c = a; //引用当右值， 把变量的值赋值给变量 int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。 cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl; cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl; //字面量常引用 const int&amp; tmp = 123; //分配内存 cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl; cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl; //普通引用 //int&amp; var = 123; //不自动分配内存， 编译错误 int var = 123; func1(123); //可以传进字面量 func1(var); //可以传进变量 func2(var); //只能传进变量. cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 重载和重写 重写与重载： 方法的重写Overriding和重载Overloading是多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同 定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。 左值右值 左值和右值 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 对象的初始化， 和赋值不一样 A a = b; // 调用a的拷贝构造函数 A a; a = b; //调用操作符重载=函数, 类 带指针的类和不带指针的类 class with pointer member 必须有 拷贝构造 和拷贝赋值 &amp; 有不同意义， 取地址和声明参数引用。 对象类型： local objects （auto object）： Complex c2(); static objects：其生命在作用域结束后仍然存在，知道整个程序结束。 global objects heap objects using 编译指令： 在多函数程序中使用using编译指令，这是因为函数都使用了 cout， 因此需要能够访问位于命名空间std的 cout 定义 。 using namespace std； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素 namespace 和 Java 的 包类似 函数原型： 函数原型作为黑盒的函数 函数原型 prototype 成员函数： 成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。 static : static data 要 static 函数处理 static 成员函数 和 成员函数区别：没有 this pointer static 函数调用方式： object 调用 和 class name 调用 Inheritance 继承成员变量 继承成员函数的调用权 vitual pure vitual impure virtual non-virtual 为什么需要原型 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。 如 double volume = cube（side）； 原型的功能 原型可以帮组编译器完成许多工作。 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。 多态 多态即多种形态，多态的实现即3步骤：有继承，虚函数重写，父类指针指向子类对象。 那么类中函数的重载（overloading），也是多态，同一函数名的多种状态。 多态实现的原理： 在类的成员方法有virtual关键字，那么在创建类对象时，编译器会把对象添加一个虚函数指针,来指向虚函数表。 虚函数表的作用来存放类中成员方法的虚函数地址。在程序运行时，根据虚函数表才能确定对应执行的操作（动态绑定） 为什么类中的析构函数通常都要添加 virtual 关键字？ 是为了正确调用子类的析构函数，不引发子类对象析构时的错误。 在父类中没有添加virtual的析构函数时，父类指针指向子类对象并析构子类对象时，只调用父类的虚构函数，导致错误的析构。 #include&lt;iostream&gt; using namespace std; class Base { public: Base() {}; //Base的构造函数 ~Base() //Base的析构函数 { cout &lt;&lt; &quot;Output from the destructor of class Base!&quot; &lt;&lt; endl; }; virtual void DoSomething() { cout &lt;&lt; &quot;Do something in class Base!&quot; &lt;&lt; endl; }; }; class Derived : public Base { public: Derived() {}; //Derived的构造函数 ~Derived() //Derived的析构函数 { cout &lt;&lt; &quot;Output from the destructor of class Derived!&quot; &lt;&lt; endl; }; void DoSomething() { cout &lt;&lt; &quot;Do something in class Derived!&quot; &lt;&lt; endl; }; }; int main() { Derived *pTest1 = new Derived(); //Derived类的指针 pTest1-&gt;DoSomething(); delete pTest1; cout &lt;&lt; endl; Base *pTest2 = new Derived(); //Base类的指针 pTest2-&gt;DoSomething(); delete pTest2; return 0; } // 输出结果 1 Do something in class Derived! 2 Output from the destructor of class Derived! 3 Output from the destructor of class Base! 4 5 Do something in class Derived! 6 Output from the destructor of class Base! 运算符重载 运算符重载的左侧的操作数是调用的对象。 所以对于成员方法的运算符重载，那么左侧的操作数是 this，并不是第一个参数。 类型转换 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。 动态绑定和静态绑定 动态绑定就是程序在执行时才确定具体的操作，我认为动态绑定是动态存储区(heap)申请内存；静态绑定（即在编译时刻已经确定程序的大小）是在静态存储区存放大小。 在 C 中 malloc 实现动态存储区的申请。 在 C++ 中 new 实现动态存储区的申请。 静态绑定的执行效率优于动态绑定的执行效率。 虚函数表的存储空间在哪呢？ 我觉得是动态存储区，因为只有实例化对象时，虚函数表才能生成，并不是编译时刻就确定好。 智能指针 智能指针在结束对象的生存期，智能释放指针指向的存储空间，不会产生内存泄露问题。相对于普通指针，更加安全。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F08%2F28%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[换行：1.方法1： 连续两个以上空格+回车。 首行缩进两个字符：（每个表示一个空格，连续使用两个即可） 1.&amp;ensp;半角的空格 ​ 2.&emsp;全角的空格 字体、字号、颜色 - &lt;font color=red&gt;red&lt;/font&gt; - &lt;font color=blue&gt;blue&lt;/font&gt; - &lt;font color=green&gt;green&lt;/font&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clovers]]></title>
    <url>%2F2018%2F08%2F28%2Fclover%2F</url>
    <content type="text"><![CDATA[快捷键技巧： Ctrl+W关闭页面Ctrl+Tab切换页面]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>clovers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;stromzhang&quot; git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知道自己不知道的]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[入门篇： python 和 java Script 选择 入门语言 学习使用操作系统linux 学习使用编程工具 vs 和 vs code 正式入门 推荐文章： The Key To Accelerating Your Coding Skills 编程技巧方面：怎么把程序写好的书（代码大全）。 java语言学习：Java核心技术卷一， spring: spring in action 操作系统：鸟哥的Linux私房菜 网络协议：HTTPS文档， 数据库设计：慕课网 数据库设计那些事 数据库：MySQL必知必会 前端方面： 编码方面：ASCII, UNICODE, 编程工具方面：JAVA VS CODE 版本管理工具：GIT, 调试前端工具： 数据库设计工具： java语言 综合性实力最强 IDE 版本管理工具 git 调试前端工具 数据库设计工具 程序员修养 英文能力 问问题的能力 写代码的修养 安全防范意识 软件工程和上线规范 编程规范 专业技术篇 编程语言: c, c++, java 理论学科: 算法与数据结构，网络模型，计算机原理，操作系统原理，编译原理，数据库原理。（工人和工程师的差别） 系统知识：Unix, Linux, TCP/IP, C10K 从业方向：底层，大数据，分布式开发等等。 软件设计能力&emsp;&emsp;工程师走向架构师 程序员荒谬之言还是至理名言 如果你把一个技术搞精搞深，你的知识面自然会很广的。 面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会（依据自己兴趣学习） 为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。 不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。 永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。（特别赞同） Teach Yourself Programming in Ten Years——用十年教会自己编程]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>系统知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
