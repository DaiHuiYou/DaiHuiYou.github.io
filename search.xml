<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C/C++复习]]></title>
    <url>%2F2018%2F11%2F28%2FC-C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[带指针的类和不带指针的类 class with pointer member 必须有 拷贝构造 和拷贝赋值 &amp; 有不同意义， 取地址和声明参数引用。 对象类型： local objects （auto object）： Complex c2(); static objects：其生命在作用域结束后仍然存在，知道整个程序结束。 global objects heap objects using 编译指令： 在多函数程序中使用using编译指令，这是因为函数都使用了 cout， 因此需要能够访问位于命名空间std的 cout 定义 。 using namespace std； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素 namespace 和 Java 的 包类似 函数原型： 函数原型作为黑盒的函数 函数原型 prototype 成员函数： 成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。 static : static data 要 static 函数处理 static 成员函数 和 成员函数区别：没有 this pointer static 函数调用方式： object 调用 和 class name 调用 Inheritance 继承成员变量 继承成员函数的调用权 vitual pure vitual impure virtual non-virtual 为什么需要原型 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。 如 double volume = cube（side）； 原型的功能 原型可以帮组编译器完成许多工作。 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。 使用引用参数的原因 程序员能够修改调用函数中的数据对象。 通过传递引用而不是整个数据对象，可以提高程序的运行速度。 class CStuFile { public: CStuFile(char *filename); ~CStuFile(); void Add(CStudentRec stu); int Seek(char* id, CStudentRec &amp;stu); int List(int nNum = -1); private: char *strFileName; }; CStuFile::CStuFile(char *fileName) { strFileName = new char[strlen(fileName) + 1]; strcpy(strFileName, fileName); } CStuFile::~CStuFile() { if( strFileName ) delete []strFileName; } void CStuFile::Add(CStudentRec stu) { //写入文件， 二进制形式 fstream file(strFileName, ios::out|ios::app|ios::binary); file &lt;&lt; stu; file.close(); } int CStuFile::Seek(char *id, CStudentRec &amp;stu) { int nRec = -1; fstream file(strFileName, ios::in|ios::nocreate); if(!file) { cout &lt;&lt; &quot;文件&quot; &lt;&lt; strFileName &lt;&lt; &quot;不能打开&quot; &lt;&lt; endl; return nRec; } int i = 0; while( !file.eof() ) { file&gt;&gt;stu; if((strcmp(id,stu.strID) == 0) &amp;&amp; (stu.chFlag != &#39;N&#39;)){ nRec = i; break; } i++; } file.close(); return nRec; } int CStuFile::List(int nNum) { //录入数量 int nRec = 0; //打开文件方式 输入，不创建 fstream file(strFileName, ios::in|ios::nocreate); //file 为 NULL， 则打开文件失败 if( !file ) { cout &lt;&lt; &quot;文件&quot; &lt;&lt;strFileName &lt;&lt; &quot;不能打开!&quot; &lt;&lt; endl; return 0; } if((nNum==-1)||(nNum&gt;0)) { //输出数据左对齐 cout.setf(ios::left); cout&lt;&lt;setw(6)&lt;&lt;&quot;记录&quot; &lt;&lt;setw(20)&lt;&lt;&quot;姓名&quot;&lt;&lt;setw(10)&lt;&lt;&quot;学号&quot; &lt;&lt;&quot;\t成绩1\t成绩2\t成绩3\t平均分&quot;&lt;&lt;endl; } //当读取文件为结尾时 while( !file.eof() ) { CStudentRec data; file &gt;&gt; data; if(data.chFlag == &#39;A&#39;) { nRec++; if( (nNum == -1) || (nRec &lt;= nNum) ) { cout.setf(ios::left); cout &lt;&lt; setw(6) &lt;&lt; nRec; data.Print(); } } } file.close(); return nRec; }]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[编程规范 #ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; } 使用链表的例子： 页帧管理​ 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。]]></content>
  </entry>
  <entry>
    <title><![CDATA[暗时间]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[暗时间 善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。 如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。 能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？（思维方式） 能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。 因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。 设计你自己的进度条 进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。 善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。前阵子流行的 GTD 方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。 其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。 饿死在干草堆之间的驴子（选择问题） 面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。 但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。 所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。 如何有效地记忆与学习 你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。 整理笔记：经常整理你的笔记——如果你没有做笔记，现在就开始——整理之前的笔记一来巩固已经淡化的记忆，二来给你重新审视知识的机会。我常常发现对知识的首次记忆往往是有偏颇的，或者只看到了一个方面，或者只关注了一个点，一段时间之后再回来看往往能够和这段时间以来的一些新思考和知识结合起来，得到更多的东西。留心一下你会发现记忆实际上是很脆弱的东西，而且我们对事物的首次理解几乎肯定是不深入的。 书写：将一段时间学习的知识按照一个主题系统地“串”起来大大地丰富了知识之间的关联，平添无数提取线索。 学习密度与专注力 其实，在大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家。而生活中太多的分散注意力的因素：游戏、篮球、选修课、女朋友… 要想集中注意力对一个单一的目标猛下功夫，其实还是相当有难度的。这个难度并非来自自制力，如果一个人要靠自制力去强迫自己不受干扰，那只能说还是寻常人(mediocre)。真正的效率源自于内心对一个东西强烈的热忱，也就是我们俗称的追求，这时候从表层意识到深层意识都关注在这件事情上面，脑细胞高度活跃，才能创造最大的效率。 专注力为什么会对学习效率造成这么大的影响。这来源于两个方面，一是专注于一件事情能让表层意识全功率运作，这个是显式的效率。第二点，也是更重要的，它还能够使你的潜意识进入一种专注于这件事情的状态。如果表层意识和潜意识都能专注同一件事情，也就是俗称的完全投入，这个时候的效率就能double。此外这种专注成了一种习惯之后，就容易在很短时间之内把自己的潜意识带入到一种关注的“惯性”中，于是即便表层意识的注意力已经移开了，然而潜意识仍在继续关注原来的问题。比如你可能有这样的经历，学习一首歌曲，一开始的时候并没有完全学会，然后你就去忙别的事情了，一个星期之后想起这首歌曲，居然发现原来难学会的几个地方突然会哼了；或者思考一个问题，一开始的时候总有一个地方没有思考出来，然后你就先放着了，几天之后回想这个问题，突然发现一切都清晰了。这就是潜意识的效率，它能在你不知不觉中把时间利用起来。 一个习惯于专注事情的人不管做什么事情都容易并迅速进入一种专注的状态。既然是一种习惯，就能够培养，金出武雄在《像外行一样思考，像专家一样实践——科研成功之道》里面提到“思维体力”的概念，所谓思维体力就是能够持续集中注意力的时间，注意力造就非凡专家，天才来源于长期的专注的训练。培养你的思维体力，是成为非凡专家的一个必要条件。除了培养专注的习惯之外，还可以通过另一个充分条件来实现专注力，即做自己喜欢做的事。我们从小对自己喜欢做的事情都是极其专注的，当然，即使长大了之后，仍然还是某种程度上保留了这种专注的能力，只不过因为种种外界因素，长久专注的能力反而削弱了，要考虑房子，要考虑业绩，要考虑小孩，要考虑医疗保险…这些让人焦虑的事情会积压在潜意识当中，总是在影响你专注做事，削弱你人生的效率。 一直以来伴随我的一些学习习惯学习与思考 Google &amp; Wiki（遇到问题做的第一件事情，也是学习某个东西做功课（homework）最先用到的东西。 做读书笔记。一是将自己阅读的时候的思考（包括闪念）总结下来，二是将书中的好例子摘抄下来。（这个习惯是一年前才养成的，发现受益极大。）有了 google note，笔记可以加上tag，非常便于回顾，加深理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上（后两者常常也是相关的）。 提到思考，我有一个小习惯。利用走路和吃饭的时候思考，还有睡觉前必然要弄一个问题放在脑子里面，在思考中迷糊入睡。发现这样一来往往在不知不觉中多出来大量的思考时间。 将思考成为习惯还有一个很大的好处——避免焦虑。 重要的事情营造比较大的时间块来完成。比如一本好书，或者一个重要的知识点，最好不要切得太琐碎了看，否则看了后面忘了前面。不利于知识的组织&amp;联系。 多看心理学与思维的书，因为它们是跨学科的。知识分两种，一是我们通常所谓的知识，即领域知识。二是关于我们的大脑吸收知识的机制的知识，后者不妨称为元知识。虽说这也是领域知识，但跟其它的领域知识不同的是，它指导着我们学习其它所有的领域知识。 学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。 获得的多少并不取决于读了多少，而取决于思考了多少、多深。 善于利用小块时间，也就是《奇特的一生》中所说的“时间下脚料”，如何利用前面有几个方法。同时，也善于创造整块时间（如通过要事优先）。 时间管理 学习和思考的过程中常问自己的几个问题： 你的问题到底是什么？. OK，到现在为止，我到底有了什么收获呢？时常反省和注意自己的思维过程。养成反驳自己的想法的习惯。 重视知识的本质：对于程序员来说这一点尤其重要，程序员行业的知识芜杂海量，而且总是在增长变化。很多人感叹跟不上新技术。应对这个问题的办法只能是：抓住不变量。大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时。算法数据结构永远都不过时。基本的程序设计理论永远都不过时。良好的编码习惯永远都不过时。分析问题和解决问题的能力永远都不过时。强大的学习能力和旺盛的求知欲永远都不过时。你大脑的思维方式永远都不过时。 重视积累的强大力量，万事提前准备：计划订长一点，自然就可以多获得准备的时间。设想你若干年后会在做什么事情，需要哪些技能，现在就开始准备。一个5年计划便可以让你获得从现在开始的5年准备时间。5年中每天腾出半个到一个小时专心于某一件事情，认准一个方向，每次走一点，其实不要说5年，两年就会发现会起到宏大的效应。 抬起头来：人的思维是非常容易只见树木不见森林的（否则这个成语从哪来的呢？）。时不时抬起头来审视一下自己正在做的事情，问一问它（对现在或未来）有什么价值，是不是你真正希望做的。你学到的东西到底是什么？它们重要吗？你需要在这个时候学习这些吗？（见第2条）。你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。仅仅遵循兴趣是不够的，人会对很多次要的东西产生兴趣，并一头钻进去浪费好多时间。所以判断一个东西值不值得学习是很重要的。（兴趣偏差） 有时间吗？总结总结最近得到的新知识吧。一般来说，我在一段时间内学习的一些东西总是会在这段时间内一直在脑子里打转，一有时间空隙（譬如走路，吃饭）它们就会自己蹦出来，促使我去进一步思考和总结。永远不要认为对一个知识的把握足够深刻，“理解”的感觉很多时候只是假象。学会反问自己对知识到底把握了多少，是很有价值的。 有时间吗？看本书吧。（传统的）阅读和思考永远优于所谓的在互联网上汲取新知识，后者往往浅表、不系统、乃至根本没价值。 制定简要的阅读计划：选出最近认为对你最有价值的书，先总览一下，决定阅读的顺序（哪些章节可以优先阅读）。然后每天看一点。并利用走路、吃饭、乘车或其他不适合带着书和笔的时间来总结看过的内容，建立知识结构，抽取知识本质，与以往的大脑中的知识建立联系。 阅读方法 趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去。万事开头难，因为从不了解到了解基本的一些事实，是一个新知识暴涨的阶段，这个时候的困难是最大的。有人熬不过去，觉得困难太大就放弃了。 根据主题来查阅资料，而不是根据资料来查阅主题。以前读书的时候是一本一本的读，眼里看到的是一本一本的书，现在则是一章、甚至一节一节的读，眼中看到的不是一本一本的书，而是一堆一堆的章节，一个一个的知识主题，按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。 学习一个东西之前，首先在大脑中积累充分的“疑惑感”。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到解答之后印象就越深刻。记得大学里面的课本总是瀑布式地把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完了很快又忘掉了，为什么？因为没有带着疑问去学习。 有选择地阅读。很多人觉得我读书速度很快，其实我只是有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读。二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的（譬如《黑天鹅》），那么1. 现象是什么？2. 解释是什么？3. 支撑这个解释的理由是什么？4. 例子是什么？一般来说，这一二三四用不了多少字就可以写完了（如果假设只举一到两个精到的例子的话），这样的无废话著作的典型是《合作的进化》；那为什么有些书，明明核心观点就那点东西（顶多加上几个精要的例子罢了）却写得长得要命呢？因为人的思维都有一个“联想”的特点，写着写着就容易旁逸斜出，而且作者自己也往往觉得引申出去挺牛逼，有时候很多与主题无关的废话就掺和进来了；那么，阅读的时候就应该有选择性地滤掉这些不相干的废话；此外还有一种可能性就是大量冗余的例子。一般来说组织得比较好的书会有详细且一目了然的目录和索引，根据目录首先就可以滤掉一部分（比如某个子章节的内容你以前是看过的），然后有时候作者还会举很多冗余的例子，如果你已经觉得印象够深刻了这些例子完全可以不看（一些书就非常厚道地对每个观点只辅以一两个最最经典的例子，譬如《与众不同的心理学——如何正视心理学》，这样的书我最是喜欢）。（有选择阅读） 知识结构 抓住不变量： 把知识分为essential的和non-essential的。对于前者采取提前深入掌握牢靠的办法，对于后者采取待用到的时刻RTM (Read the manual)方法（用本）。 思维改变生活 如何区分essential和non-essential的知识想必绝大多数时候大家心里都有数，我举几个例子：对程序员来说，硬件体系结构是essential的，操作系统的一些重要的实现机制是essential的，主流编程范式（OO、FP）是为了满足什么需求出现的（出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景）。这些我认为都是essential的。我想补充一点的是，并不是说硬件体系结构就要了解到逻辑门、晶体管层面才行（其实要了解到这个层面代价也很小，一两本好书就行了），也并不是说就要通读《Computer Architecture: Quantitative Approach》才行。而是关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）。《Computer Systems: A Programmer’s Perspective》就是为此目的，针对程序员的需求总结出那些essential knowledge的好书。（写下来，理性分析） 我们对于事物的思考深度常常是不够的，在浅层次的思考了之后，如果我们的情绪系统或者直觉已经给出了倾向，那么很少有人会继续深入地思考，而开始转向着手行动。这种匆忙的态度往往是失败的起源，在碰壁了之后，我们被动地“让事实告诉了我们”某方案是行不通的，让事实替代我们进行了思考和推理，我们从失败当中获得了信息，知道了为什么之前的方法是不恰当的，这就是一些时候我们认为要亲身经历才能明白的原因。然而，这并不意味着任何时候我们都只能“做了之后才发现…”，人类最强大的能力就是社会学习—— 普通人从自己的错误中学习，聪明人从别人的错误中学习。 人类最强大的另一个能力则是归纳和推理—— A few lines of reasoning can change the way we see the world. (via) 我们可以仔细地，理性地思考、权衡各个选择的利弊，而不仅仅满足于情绪上的判断。 假设我们面临两个选择，A和B，我们可以结合别人的经历，利用自己的推理能力，去分别推断A或B选项带来的各种各样可能的利弊，对于其中不确定的因素我们或者可以进一步从别人那里收集更多的信息来使得判断更靠谱，或者可以对风险的上下界进行一些估计，总之，我们尽量去让我们大脑中假想的角色去经历失败——我们通过推理发现某条路行不通，就避免了现实中去碰一鼻子灰。 书写是为了更好地思考 我经常在走路和睡前总结所学过的内容，思考遗留的问题，一段时间的阅读和思考之后，一个总体的知识框架就会逐渐浮现在脑海中。然后我会将它书写下来，然而，我往往非常惊讶地发现，当我书写的时候，新的内容仍然源源不断的冒出来，就像我的键盘自己也会思考一样。（总写学过的知识） 遇到问题为什么应该自己动手 有一个很不错的概念叫做“Unknown Unknown”，大意是如果你不知道一个东西的话，你也不会知道你自己不知道它。很多时候新知识就有这个特性——掌握了之后觉得很明白，掌握之前却觉得“不可能啊”、“这简直没有解嘛”。在这样的认知之下，你自然会高估前方的困难、风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为Unknown Unknown，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。（不知道自己不知道的） 用最小的代价解决手头的问题”——这里的问题在于，难道我们计算收益的时候仅仅考虑是否解决了手头的问题吗？如果解决的过程中得到了其他的收益呢？为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。（额外的收益） 什么才是你的不可替代性&amp;核心竞争力知识技能组合是具有相当程度的不可替代性的： 专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。 跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind 等等 学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。 性格要素：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等。 鱼是最后一个看到水的 《设计模式》被许多初学者奉为圭臬，认为那些看上去精巧的东西才是真正牛13的，值得学习的。而且，更聪明一点的人甚至会唯恐学的东西还不够复杂，因为越是复杂的东西搞出来越是有成就感。然而事实是，把简单的事情搞复杂的人比比皆是，把复杂的事情搞简单的人凤毛麟角。（不要把简单事情搞复杂） 避免思维被一门语言束缚的最好办法就是“学习其它语言”。 知其所以然 包含了多得多的知识：记一个算法，就只有一个算法。一个萝卜一个坑。就好比背99乘法表只能解决乘法问题一样。而记背后的思想，却有助于解决一类问题。思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。算法诞生过程中的思路往往包含了比实际算法更本质得多的知识，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。（分析推理） 重在分析推理，而不是联想：学了一大通算法和数据结构之后的一个副作用就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的思维捷径，在任何时候都会抢占大脑的工作记忆，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维最重要的特征。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。 习惯 也许，对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败而领悟的，还是看到书上或听到别人说的）写下来，并常常拿出来翻看。事实上，我的经验是，在写下来的时候我们的大脑会进入到理性分析模块，进一步检验和推理那些道理，我们越是对一个道理审视的详细、深入、全面，大脑中留下的印象深刻，从记忆加工的角度来说，这叫深度加工，带来的结果就是该记忆与更多的提取线索相关联，于是便能够在更多的场景下被唤起（而不是被以往的习惯直接覆盖） note: 俗语有谋事在人，成事在天的说法。其实这话说的是，我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果。不要奢望你努力了就绝对会成功，你不会。更不要以这个理由来作为不去努力的原因，因为不去努力，那就永远不会成功。 生活中一抓一大把。俗语云“公说公有理，婆说婆有理。”你敢于表达自己的观点，他说你喜欢炫耀。你韬光养晦呢，他又说你夹着尾巴做人；你为自己的成就骄傲一下，他说你得意忘形。你低调做人呢，他又说你怎么这么没种；你说彪悍的人生不需要解释，他说你自大狂。你说做人贵有自知之明呢，他又说你丫做人怎恁费劲捏？… ###]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高质量C/C++编程指南]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%AB%98%E8%B4%A8%E9%87%8FC-C-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[文件结构 程序的版式 命名规则 表达式和基本语句 常量 函数设计 内存管理 c++函数的高级特性]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式 //抽象工厂模式， 生产一组产品 class Fruit { public: virtual void SayName() = 0; }; class AbstractFactory { public: virtual Fruit *CreateBanana() = 0; virtual Fruit *CreateApple() = 0; }; class NorthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north banana&quot; &lt;&lt; endl; } }; class NorthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north apple&quot; &lt;&lt; endl; } }; class SouthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south Banana&quot; &lt;&lt; endl; } }; class SouthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south apple&quot; &lt;&lt; endl; } }; class NorthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new NorthBanana(); } virtual Fruit *CreateApple() { return new NorthApple(); } }; class SouthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new SouthBanana(); } virtual Fruit *CreateApple() { return new SouthApple(); } }; void main() { AbstractFactory *af = NULL; Fruit *fruit = NULL; af = new NorthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); af = new SouthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); system(&quot;pause&quot;); } 建造者模式class House { public: void setDoor(string door) { this-&gt;m_door = door; } void setWall(string wall) { this-&gt;m_wall = wall; } void setWindow(string window) { this-&gt;m_window = window; } string getDoor() { cout &lt;&lt; m_door &lt;&lt; endl; return m_door; } string getWall() { cout &lt;&lt; m_wall &lt;&lt; endl; return m_wall; } string getWindow() { cout &lt;&lt; m_window &lt;&lt; endl; return m_window; } private: string m_door; string m_wall; string m_window; }; class Builder { public: virtual void buildWall() = 0; virtual void buildDoor() = 0; virtual void buildWindow() = 0; virtual House* getHouse() = 0; }; class FlatBuilder : public Builder { public: FlatBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Flat door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Flat wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Flat window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class VillaBuilder : public Builder { public: VillaBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Villa door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Villa wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Villa window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class Director { public: Director(Builder *build) { m_build = build; } void Construct() { m_build-&gt;buildWall(); m_build-&gt;buildWindow(); m_build-&gt;buildDoor(); } private: Builder *m_build; }; void main() { House *house = NULL; Builder *builder = NULL; Director *director = NULL; builder = new VillaBuilder(); //设计师 指挥 工程队 干活 director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); //返回房子 house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; //请 FlatBuilder 公寓 builder = new FlatBuilder; director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; delete director; system(&quot;pause&quot;); return; }]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[SQL基本概念数据库是一个以某种有组织的方式存储的数据集合. 表是一种结构化的文件, 可用来存储某种特定类型的数据. 表:某种特定类型数据的结构化清单． 模式：关于数据库和表的布局及特定的信息. 表由列组成. 列中存储着表中某部分的信息. 列: 表中的一个字段. 所有表都是由一个或多个列组成的. 数据库中每个列都有相应的数据类型.数据类型定义列可以存储的数据种类. 表中数据都是按行存储的, 所保存的每个记录存储在自己行内. 行：表中的一个记录. 记录和行互相代替. 主键：一列(或一组列), 其值能够唯一区分表中每个行. 唯一标识表中的每行的这个列称为主键. SQL: 是结构化查询语言的缩写. 客户机-服务器应用分为两个不同的部分, 服务器部分是负责所有数据访问和处理的一个软件. 这个软件运行在称为数据服务其的计算机上. 与数据文件打交道的只有服务器软件. 关于数据, 数据添加, 删除和数据更新的所有请求都由服务器软件完成.这些请求或更改来自运行客户机软件的计算机. 客户机是与用户打交道的软件. ​ 客户机和如软件可能安装在两台计算机或一个计算机上. 不管他们在不在相同的计算机上, 为进行所有数据库交互, 客户机软件都要与服务器软件进行通信. ​ 所有这些活动对用户都是透明的. 数据存储在别的地方, 或者数据库服务器为你完成这个处理这一事实是隐藏的. 你不需要直接访问数据文件. 事实上, 多数网络的建立使用户不具有对数据的访问权, 甚至不具有对存储数据的驱动去的驱动器的访问权. 服务器软件为MySQL DBMS. 你可以在本地安装的副本上运行, 也可以连接到运行在你具有访问权的远程服务期上的一个副本. 客户机可以是MySQL提供的工具, 脚本语言, web应用开发语言, 程序设计语言. 熟悉MySQL命令行实用程序, 数据库的基本概念： 列/字段/属性/数据项（column/field/attribute/data item） 行/元组/记录（row/tuple/record） 关系模式： 表名 +表标题（格式） 表／关系：表名＋表标题（格式）＋表内容（值） DataBase：相互之间有关联关系的Table的集合。 数据库： DB 数据库管理系统：DBMS 数据库应用：DBAP 数据库管理员：DBA DBMS提供了一套数据控制语言（DCL）给用户，DBA-&gt;DCL-&gt;DBMS 数据操作语言：DML，提供给用户，以便给用户对数据进行操作 数据控制语言：DCL，用户使用DCL；定义对不同操作的约束，对不同操作者的约束。 数据定义语言：DDL, 定义表名，表标题，列名其结构形式 SQL语言： DML, DCL, DDL， 结构化的数据库语言 数据库语言与高级语言的区别： ​ 一条数据库语言相当于高级语言的一个或多个循环程序。 数据模型——模式——数据 模式：外模式（子模式），概念模式（全局模式，逻辑模式），内模式（存储模式，物理模式） E-C映像 ， C-I映像 三级模式两层映像：实现了逻辑独立性和物理独立性， 数据和应用程序的独立性 数据模型： 关系模型 层次模型 网状模型 关系模型的三个要素： 基本结构 基本操作 完整性约束：实体完整性，参照完整性和用户自定义完整性 关系运算：关系代数和关系演算；关系演算：元组演算和域演算 关系代数：基于集合的运算，即操作的对象和结果都是集合，是一次一集合的操作。而非关系型的数据操作通常是一次一记录的操作 “列“的取值范围“称为 ”域（Domain）” 笛卡尔积的每个元素（d1, d2,…..)称为一个n-元组 元组的每个值叫做一个分量。 笛卡尔积中具有某一方面意义的那些元组被称作一个关系。 关系模式和关系：关系模式是关系的结构，关系是关系模式在某一时刻的数据。 关系是笛卡尔积的子集。 列名（属性名） 列值（来自域） 关系的特性： 列位置的互换性：区分哪一列是靠列名 行位置的互换性：区分哪一行是靠某一或某几列的值 关系是以内容来区的 属性不可再分特性：又被称为关系第一范式 关系的任意两个元组不能完全相同。 Table：可能有重复的元组存在。 关系和Table（表） 大部分相同。 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组总去掉任何一个属性，它就不具有这一性质了，这样的属性称作候选码。 当有多个候选码，可以选定一个作为主码。 DBMS以主码为主要线索管理关系中的各个元组。 主属性：包含在任何一个候选码的属性被称作主属性 外码/外键：两个关系通常是靠外码连接起来的。 关系模型中的完整性： 实体完整性：关系的主码的属性值不能为空 参照完整性：相对于外码 用户自定义完整性：用户针对具体的应用环境定义的完整性的约束条件。 关系代数基本操作：并相容性 并 差 广义笛卡尔积 选择操作 投影操作 关系代数的基本书写思路： 选出将用到的关系/表 做“积”运算 做悬着运算保留所需的行/元组 做投影运算保留所需的列/属性 扩张操作 交运算 连接操作：在乘积操作的基础上，在做一个选择操作。 更名操作 等值连接 自然连接 除运算 关系代数 和 关系演算 关系演算：元组演算和域演算 E-R关系图： 实体表示方框， 属性表示椭圆， 关系表示菱形。 抽象是理解，区分，命名，表达 实体， 属性，联系， 关键字（码） 属性：单一属性和复合属性 关键字/码，实体中能够用其值唯一区分每个实体的属性或属性组合。 参与发生联系的实体的数目，称为联系的度， 联系是多样化的。 实体在联系中的作用称为实体的角色 当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需要显示指明其角色。 实体之间的联系有很多种类。 完全参与联系 部分参与联系 不同层次的型与值 数据模型：概念 命令行]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维力]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%80%9D%E7%BB%B4%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[如何清楚的表达？ 思维力： 阅读摘抄思维力提升是当今时代的要求 知识积累方式变化下的必然要求 框架不仅仅体现了系统的构成元素，还体现了系统各构成元素的之间有机联系， 这种联系就是规律。 系统思维是用框架来系统思考与表达的思维方式。 系统反应了人们对事物的一种认识论： 系统是由两个或两个以上的元素结合而成的有机整体，而且系统的整体不等于其局部的简单相加–不仅要靠考虑系统的构成元素，更要考虑元素之间的联系。 系统思维就是以系统论为基本模式的思维形态， 它的客观一句是事物存在的普遍方式和属性。 框架是系统思维的核心组成部分。 以假设为前提，以事实为基础的工作方法。 世间万物的本质其实是系统，而框架就是对系统构成元素一级元素间有机联系的简化体现。因此人类大脑的在处理信息时本能地想将其组合为能够被认知的框架，以反应对事物的理解。 因此，系统思维在表达上应用的核心就是强调要采用自上而下表达的形式，第一时间传递容易认知的框架给受众，从而使受众更轻松，更有效接受你所传递的信息。 系统思维弥补经验上的不足，加速经验积累。 运用框架解决问题和加速经验的积累。 系统思维提高学习效率，加速知识积累。 我构建了个人的知识体系，我知道自己需要学习什么， 还缺少什么，因此每当我学习新的知识、经历新的事情时，我会不由自主的地了解的新的内容填充进我的知识框架里。随着我构建的知识体系越完整，越秘籍，就好像一张三维的渔网一样， 同一个姿势或同一段经历能够区填充的各自也就越来越多，知识积累的速度也就不停地加快。 麦肯锡结构化思维的内涵（定义）：分析问题的框架。 麦肯锡结构化思维的外延（应用范围）：框定假设的范围 明确问题的构成要素5 W 2 H 分析法， 又称 “七何”分析法 你可以在电话里运用框架跟他一次性确认所有关键要素。 Why What When Where Who How How much 其实很简单，这就是我要教给你的“探究问题本质”的第一种方法——5Why分析法。 5Why分析法的关键：鼓励解决问题的人努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。 因此，我们抛给别人的问题或需求，或别人抛给我们的问题或需要，往往都不是问题本身，而是问题的初步解决方案。 因此，我们在工作、生活和学习中需要多多提醒自己区分清楚问题初步解决方案和问题的本身。 在现实的工作、生活和学习中，很多时候对方提出的问题都是经过他们初步加工后的解决方案，而非真正的问题。将问题的初步解决方案与问题本身混为一谈是最容易犯的错误之一，也是大量时间和精力浪费的根源之一。你需要找到真正的问题，而不是惯性地将初步解决方案当做问题本身来应对。 隐含时间的假设广泛存在于我们的工作、生活和学习中，我相信你听过很多隐含时间假设的论断，也可能因未能显性化问题隐含的时间假设而错过了不少机会。例如，领导给你布置一个相当有挑战性的任务时，你的第一反应是“这个工作需要很强的沟通能力，我的沟通能力不行，因此我不能接这个任务”，还是“这个工作需要很强的沟通能力，目前我的沟通能力不行，正好可以借这个任务锻炼提升”呢？若是前者，你不仅辜负了领导的信任，还丧失了一次提升沟通能力的机会。而后者既可以提升沟通能力，又能够得到领导的青睐，即使任务没圆满完成，你的沟通能力的提升也绝对比你不接受这个任务要高得多 逻辑树是我们运用系统思维分析和解决问题的主要工具逻辑树是一种非常有效的问题/议题分解的方法，其价值主要有以下三点：​ 1.对问题/议题/假设层层有序分解，有助于理清思路，不做重复和无效的思考；​ 2.可有效分解复杂问题/议题，从而简化问题/议题的处理；​ 3.通过将问题/议题分解为更细的问题/议题，有助于团队的协作和分工 80/20法则的作用一个人的时间和精力都是非常有限的，“做好每一件事”几乎不可能，因此必须学会合理分配的时间和精力。面面俱到不如重点突破，把80%的资源花在能出关键效应的20%的方面上，这20%的方面又能带动其余80%的发展。 自上而下的表达三点式表示]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[for循环常用写法date: 2018-09-27 11:03:38 插入元素: 删除元素: void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 循序栈和链式栈date: 2018-09-25 15:54:15 stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 线性表顺序存储和链式存储date: 2018-09-23 19:46:15 单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 基本概念date: 2018-09-22 14:22:10 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 ​ //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 二叉树表示算数表达式： 先序遍历： 前缀表示法 中序遍历： 中缀表示法 后序遍历： 后缀表示法 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2018%2F10%2F11%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[匿名对象date: 2018-09-20 17:15:00 匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。 class AA { public: AA() { cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } ~AA() { cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl; } }; void main() { //AA a = AA(); //产生一个匿名对象， 有一个变量去接，不会调用析构函数。 AA b; //调用拷贝构造函数。 b = AA(); //匿名对象， 会调用拷贝构造函数和析构函数。 //func(); system(&quot;pause&quot;); } 异常date: 2018-09-21 14:28:22 抛出异常是跨函数的。 c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。 栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。 异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。 void func() thorw(A, B, C, D) { } 知识点date: 2018-09-20 21:51:18 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 字符串常量/字面量 拷贝构造函数：是一种特殊的构造函数，他在构建对象时， 是使用同一类中之前创建的对象来初始化新创建的对象。 迭代器： 是一种检查容器内元素并遍历元素的数据类型，可以代替下标访问vector对象的元素。迭代器是便利容器的同一方法。 容器： 任何数据类型都能存储。 引用引用分为普通引用和常引用 //常引用 //常引用当函数参数 ,可以传字面量或者实参 void func1(const int&amp; num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } //普通引用当函数参数， 传实参 void func2(int &amp;num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } void main() { int a = 10; int c = a; //引用当右值， 把变量的值赋值给变量 int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。 cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl; cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl; //字面量常引用 const int&amp; tmp = 123; //分配内存 cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl; cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl; //普通引用 //int&amp; var = 123; //不自动分配内存， 编译错误 int var = 123; func1(123); //可以传进字面量 func1(var); //可以传进变量 func2(var); //只能传进变量. cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 常量必须初始化 重载和重写date: 2018-09-20 08:28:05 重写与重载： 方法的重写Overriding和重载Overloading是多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同 定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。 左值右值date: 2018-09-19 21:34:18 左值和右值 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 对象的初始化， 和赋值不一样 A a = b; // 调用a的拷贝构造函数 A a; a = b; //调用操作符重载=函数, 类模板date: 2018-09-19 15:41:31 #include &quot;iostream&quot;//类模板的本质， 两次编译 using namespace std; template &lt;typename T&gt; class Teacher { public : static T a; private: }; template &lt;typename T&gt; T Teacher&lt;T&gt;::a = 0; void main() { Teacher&lt;int&gt; t1; t1.a = 10; t1.a++; t1.a++; Teacher&lt;char&gt; t2; t2.a = &#39;a&#39;; t2.a++; t2.a++; cout &lt;&lt; t2.a &lt;&lt; endl; //两个静态变量， 不一样， 属于不同内存空间 cout &lt;&lt; t1.a &lt;&lt; endl;//类模板机制的本质， 两次编译 cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 线性链表date: 2018-09-18 17:29:04 泛型编程date: 2018-09-17 22:11:16 指针作引用date: 2018-09-11 20:17:36 结构体作函数参数date: 2018-09-11 14:49:20 //结构体作函数参数 struct Teacher { char name[60]; int age; }; void printTeacher1(Teacher t1) { cout &lt;&lt; t1.age &lt;&lt; endl; } void printTeacher2(Teacher &amp;t2) { t2.age = 20; cout &lt;&lt;t2.age&lt;&lt; endl; } void printTeacher3(Teacher *t3) { t3-&gt;age = 30; cout &lt;&lt; t3-&gt;age &lt;&lt; endl; } void main() { Teacher t1; t1.age =10; printTeacher1(t1); printTeacher2(t1); //引用方式，结构体作函数参数 printTeacher3(&amp;t1); //作用与指针间接赋值一样。 system(&quot;pause&quot;); return; } Type &amp;name = var;//等效于C语言 Type *const name = var; 引用作函数参数， 当左值和右值。 当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址而已 引用就是给内存取多个门牌号（多个别名） 运算符date: 2018-09-11 07:21:16 //struct 和 class完成的功能一样 //布尔类型 bool类型 //关于左值（必须是一个变量，即有内存空间） //111 = 33；（111不能当左值， 不是一个变量，没有内存空间） //三目运算符， C返回是一个数（不能当左值）， C++返回是一个变量（能当左值） void main() { bool b1, b2, b3; b1 = 10; b2 = -10; b3 = 0; cout &lt;&lt; &quot;sizeof(bool)&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return; } //结果显示： //sizeof(bool)1 //1 //1 //0 //请按任意键继续. . . const 和 #define 相同之处 #define 是单纯的文本替换， 作用域具有全局性 #undef 限制作用域 引用的基本用法 C++的引用: 已定义变量再起个别名 Type&amp; name = var; //引用作函数参数: 与指针类似 void myswap1 (int a, int b) //不能间接赋值 { int c = 0; c = a; a = b; b = c; } void myswap2(int *a, int *b) //指针做函数参数， 实现间接赋值。 { int c = 0; c = *b; *b = *a; *a = c; } void myswap3(int &amp;a, int &amp;b) //引用做函数参数， 实现间接赋值。 { int c = 0; c = a; a = b; b = c; } void main() { int a = 10; int b = 20; myswap1(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; myswap2(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); myswap3(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return; } /*结果显示: 10 20 a = 20, b = 10 10 20 请按任意键继续. . . */ 函数返回值当左值右值 int&amp; func(void) { int a = 10; return a; } void main() { int a = func(); //将栈变量的值赋值给a. int &amp;b = func(); //传递栈变量的地址 cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; endl; //显示乱码 system(&quot;pause&quot;); } 类date: 2018-09-10 17:49:28 #include &quot;iostream&quot; using namspace std; void main() { cout&lt;&lt;&quot;hello.\n&quot;&lt;&lt;endl; system(&quot;pause&quot;): retun; } //endl 相当于 \n 类是一种数据类型， 是固定大小内存块的别名 定义一个类，是一个抽象的概念， 不会分配内存 using namespace std; C中的命名空间，只有一个全局作用域。C语言中所有的全局标识符共享一个作用域。 命名空间 C++中提出了命名空间的概念： 不同命名空间中的标识符可以同名而不会发生冲突 命名空间可以相互嵌套 全局作用域也叫默认命名空间。 namespace namespaceA { int age = 10; } namespace namespaceB { int age = 20; namespace namespaceC { struct Teacher { int age; }; } } void main() { cout &lt;&lt; &quot;hell.&quot; &lt;&lt; endl; using namespace namespaceA; using namespace namespaceB; cout &lt;&lt; namespaceA::age&lt;&lt;endl; cout &lt;&lt; namespaceB::age&lt;&lt;endl; using namespaceB::namespaceC::Teacher ; //注意事项， 缺少namespace Teacher t1; t1.age = 30; cout &lt;&lt; t1.age &lt;&lt;endl; system(&quot;pause&quot;); return; } ​]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2018%2F10%2F10%2FJava%2F</url>
    <content type="text"><![CDATA[java中类名第一个字母都是大写的. 常量分类: 字符型常量: “HelloWorld” 整形常量: 12 小数常量: 0.21 布尔常量: true 空常量: null 数据类型分类: 基本数据类型 注意: 整数默认是int 类型, 浮点数默认是double类型 定义long类型数据的时候, 要加L或者l 定义float类型数据的时候, 要加F或者f 引用数据类型(类, 接口, 数组) 标识符 标识符常见命名规则: 包(就是文件夹, 用于对类进行管理) 全部小写, 举例：com, com.itheima 类 一个单词的首字母大写 多个单词每个单词的首字符大写 方法和变量 一个单词首字母小写 多个单词组成, 从第二个单词开始每个单词的首字母大写. 变量定义和注意事项 变量未赋值, 不能直接使用 变量只在它所属的范围内有效,变量属于它所在的那对大括号 一行上可以定义多个变量, 但是不建议 类型转换 隐式转换 byte, short, char – int –long – float – double 从小变大 强制转换 目标类型 变量名 = (目标类型) (被转换的数据); 建议: 数据作运算，结果应该是什么类型，就用什么类型接受，不要随意转换类型，否则会有精度的损失． 字符串参与加法运算public class OperatorDemo01 { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(a + b + &quot;hello wolrd.&quot;); System.out.println(&quot;hello wolrd&quot; + a + b); System.out.println(&quot;hello world&quot; + a); } } 赋值运算符 注意:扩展的赋值运算符，隐含了强制类型转换． short s = 1; s += 1; //s = (short)(s+1); System.out.println(s); 逻辑运算符 &amp; 和 &amp;&amp;的区别: 相同点: &amp;&amp; 和 &amp; 的结果一样, || 和 | 的结果一样 不同点: &amp; 左边无论是什么, 右边都会执行. &amp;&amp;有短路效果, 左边为FALSE,右边都不执行. 键盘录入 Scanner 导入包中类 : import java.util.Scanner; //快捷键(推荐) Ctrl + shift + o 分配内存，定义对象 Scanner sc = new Sanner(System.in); 产生随机数Random r = new Random(); //产生随机数 for(int i=0; i&lt;10; i++) { int ret = r.nextInt(10); //随机数的范围为[0, 10), 包括0, 不包括10; System.out.println(ret); } int ret = r.nextInit(100) + 1; // 随机数的范围:[1, 100]; Java 中的内存分配 Java 程序在运行时, 需要在内存中分配空间. 为了提高运算效率, 就对空间进行了不同区域的划分, 因为每一片区域都有特定的处理数据方式和内存管理方式. 栈 存储局部变量 堆 存储new出来的东西 方法区(面向对象进阶讲) 本地方法区(和系统相关） 寄存器（给 cpu 使用)- 数组的动态初始化和静态初始化 //动态初始化 int [] myArray = new int[3]; //静态初始化 int [] myArray2 = new int[] {1,2,3}; //简化格式:int[] myArray2 = {1,2,3}; 引用类型: 类, 接口, 数组 输出内容System.out.println(); //输出内容并换行 System.out.print(); //只输出内容,不换行. 方法的形参 基本数据类型: 形参的改变 不影响 实际参数． 引用数据类型: 形参的改变直接 影响 实际参数． 一个对象的内存图 方法共用的内存图 成员变量和局部变量的区别 在类中的位置不同 成员变量： 类中，方法外． 局部变量： 方法中或者方法声明中（形式参数） 在内存中的位置不同 成员变量：在堆内存分配 局部变量: 在栈内存分配 生命周期不同 成员变量随着对象的创建而存在，随着对象的消失而消失 局部变量随着方法的调用而存在，随着方法的调用完成而消失． 初始化值的问题 成员变量有默认值 局部变量没有默认值，必须先定义，赋值，才可以使用． 类名作形式参数和返回值String类 /* * 通过构造方法创建字符串对象和直接赋值方式创建字符串对象的区别 * 通过构造方法创建字符串对象在堆内. * 直接赋值方式创建对象在方法区的常量池. * * ==: * 基本数据类型:：比较是基本数据类型的值是否相等 * 引用数据类型: 比较是引用数据类型的地址值是否相等. * */ public class StringDemo { public static void main(String[] args) { String s1 = new String(&quot;Hello&quot;); System.out.println(&quot;s1 &quot; + s1); System.out.println(&quot;----------&quot;); String s2 = &quot;Hello&quot;; System.out.println(&quot;s2 &quot; + s2); System.out.println(&quot;----------&quot;); System.out.println(&quot;s1 == s2 : &quot; + (s1==s2)); String s3 = &quot;Hello&quot;; System.out.println(&quot;s3 == s2: &quot; + (s3 == s2)); } } 内存图: String类的判断功能 Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. /* * Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 * 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. * String类的判断功能: * boolean equals(Object obj); 比较字符串的内容是否相同 * boolean equalsIgnoreCase(String str); 比价字符串的内容是否相同, 忽略大小写 * boolean startsWith(String str); 比较字符创对象是否以指定的str开始. * boolean endsWith(String str); 比较字符创对象是否以指定的str结尾. * * */ public class StringDemo { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;Hello&quot;; System.out.println(&quot;s1 == s2 :&quot; + s1.equals(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equals(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.equalsIgnoreCase(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equalsIgnoreCase(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;-------------&quot;); } String类的获取功能 /* * String类的获取功能 * int length():获取字符串长度, 其他也就是字符个数. * char charAt(int index); 获取指定索引处的字符 * int indexOf(String str); 获取str在字符串对象中第一次出现的索引 * String substring(int start); 从start开始截取字符串 * String substring(int start, int end); 从start到end之间截取字符串, 包括start, 不包括end * * */ public class StringDemo { public static void main(String[] args) { String s = &quot;helloworld&quot;; System.out.println(s.length()); System.out.println(&quot;-----------&quot;); System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;-----------&quot;); System.out.println(s.indexOf(&quot;ell&quot;));//获取str在字符串对象中第一次出现的索引 System.out.println(&quot;------------&quot;); System.out.println(s.substring(5)); System.out.println(&quot;------------&quot;); System.out.println(s.substring(0, 5));//从start到end之间截取字符串, 包括start, 不包括end } } String类的转换功能 /* char[] toCharArray(): 把字符串转换为字符数组 String toLowerCase(): 把字符串转换为小写字符串 String toUpperCase(): 把字符串转换为大写字符串 */ String类的其空格和分割功能 /* String trim(): 去除字符串两端的空格 String[] spilt(String str): 按照指定符号分割字符串,注意返回的是字符数组 */ public class StringDemo { public static void main(String[] args) { String s = &quot; aa,bb,cc&quot;; String tmpStr = s.trim(); //去除字符串两端的空格, 不包括中间空格 System.out.println(tmpStr); System.out.println(&quot;---------&quot;); String[] strArray = tmpStr.split(&quot;,&quot;);//返回值是字符串数组. for(int i=0; i&lt;strArray.length; i++) { System.out.println(strArray[i]); } } } StringBulder类 作用: 如果对字符串进行拼接操作，每次拼接，都会构建新的String的字符串对象, 即耗时,又浪费空间.而StringBuilder 可以解决这个问题. 内存分配示意图: 常用方法: /* * StringBuilder: 是一个可变的字符串. 字符串数组缓冲类 * * String 和 StringBuilder的区别 * String: 是内容是固定的. * StringBilder: 是内容可变的 * * StringBuilder的常用方法: * public String append(任意类型); * public String reverse(String str); */ public class StringDemo { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); System.out.println(&quot;容量为:&quot; + sb.capacity()); System.out.println(&quot;长度为: &quot; + sb.length()); StringBuilder sb2 = sb.append(&quot;hello&quot;); //返回本身对象的地址 System.out.println(sb); System.out.println(sb2); System.out.println(sb == sb2); //链式编程 sb.append(123).append(123).append(123); System.out.println(sb); System.out.println(&quot;------------&quot;); //public String reverse(String str) sb.reverse(); System.out.println(sb); } } String 和 StringBuilder 相互转换. /* String 和 StringBuilder的相互转换 StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;String public String toString(); 通过toString()就可以实现把StringBuilder转换成String String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;StringBuilder StringBuilder(String str); 通过构造方法, 将String转换成StringBuilder */ public class StringDemo { public static void main(String[] args) { //StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String StringBuilder sb = new StringBuilder(); sb.append(&quot;hello&quot;); String s = sb.toString(); System.out.println(s); //String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; StringBuilder String ss = &quot;hello&quot;; StringBuilder sb2 = new StringBuilder(ss); System.out.println(sb2); } } 自动生成方法/* * * 快速自动生成构造方法 Set() 和 Get()方法. * 右键: source * Generate Constructor from Superclass 无参构造方法 * Generate Constructor using Fields 有参构造方法 * Generate constructor Getter and Setters .. */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 对象数组内存图 集合类 集合类的特点: 长度可变 ArrayLIst 集合的增加 删除 修改 查找的方法 /* * * 获取元素 * public E get (int index): 返回指定索引处的元素 * 集合长度 * public int size():返回集合元素的个数 * 删除元素 * public boolean remove(Object o): 删除指定元素, 返回删除是否成功 * 修改元素 * public E set(int index, E, element):修改指定索引处的元素, 返回被修改的元素 */ public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); System.out.println(arr); System.out.println(arr.size()); System.out.println(arr.remove(&quot;hello&quot;)); System.out.println(arr.set(1, &quot;android&quot;)); System.out.println(arr); } } ArrayList 集合的遍历 //集合的遍历 public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); //标准的遍历操作 for(int x=0; x&lt;arr.size(); x++) { String s = arr.get(x); System.out.println(s); } } } IO流从程序角度出发: 输入流, 文件读数据. 输出流 文件写数据 输出流 import java.io.FileWriter; import java.io.IOException; /* * * 相对路径: 相对于当前项目的路径 * 绝对路径：系统盘符 * flush() 和 close()的方法的区别: * flush(): 刷新缓存区. 流对象还可以继续使用 * close(): 先刷新缓冲区, 然后通知系统释放资源. 流对象不可以再被使用. */ public class FileDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;a.txt&quot;); fw.write(&quot;IO流&quot;); fw.flush(); fw.close(); } } 数据换行: /* * 如何实现数据的换行 * \n 可以实现换行, 但是Windows系统自带的记事本打开并没有换行. * Windows识别的换行符不是 &quot;\n&quot;, 而是&quot;\r\n&quot; * 常见的操作系统识别的换行符: * windows:\r\n * linux: \n * mac: \r * * 如何实现文本的追加 * FileWriter fw = new FileWriter(String fileName, boolean append); */ public class FileWirterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;b.txt&quot;, true); //实现的文本的追加 for(int x=0; x&lt;10; x++) { fw.write(&quot;hello&quot;+x); fw.write(&quot;\r\n&quot;); } fw.close(); } } 输入流public class fileDemo{ public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;fr.txt&quot;); int ch = 0; //输入流 标准操作, 读到末尾时候值为-1 while((ch=fr.read())!=-1) { System.out.print((char)ch); } } } 高效的IO流BufferedReader类 BufferedWriter类 public class fileDemo{ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;fr.txt&quot;); String line; while((line=br.readline())!=null) { System.out.print((line); } } } static 的作用 一个JAVA源文件只能包含一个public类的 /* * static 的特点: * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载, 加载到方法区中 * 总结: static修饰的成员变量和成员方法不属于的所有对象. * */ public class StaticDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Person.school = &quot;wyu&quot;; //静态的加载优先与对象, 随着类的加载而加载 //static赋值, 可以使用类名调用, 无需实例化对象. Person p = new Person(&quot;xiaoming&quot;, &quot;21&quot;); } } class Person{ private String age; private String name; static String school; public Person() { } public Person(String age, String name) { super(); this.age = age; this.name = name; } public void printIf() { System.out.println(name+ &quot; &quot; + age+&quot; &quot;+ school); } } 注意事项: /* * static的注意事项: * 静态方法: * 可以调用静态成员变量和成员方法 * 不可以调用非静态成员方法和非静态成员变量 * 非静态的方法: * 全部都可以调用 * 静态的方法不含有this对象. */ public class StaticDemo_01 { public static void main(String[] args) { Student.school = &quot;s&quot;; Student.sleep(); //方法区中 } } class Student{ public String name; static public String school; public void print() { System.out.println(name + school); } static void sleep() { System.out.println(&quot;slepp&quot;); } } static的应用场景: ​ 工具类: Math类的应用, 其方法中全部被static修饰 自定义工具类package myStatic; //自定义工具类的使用 public class StaticDemo_02 { public static void main(String[] args) { int[] arr = {10, 3, 2, 4, 6}; int max = myArray.max(arr); System.out.println(max); } } ----------------------------------------------------------------------------------- package myStatic; //自定义一个工具类 public class myArray { //用 private修饰构造方法, 使class不可以实例化对象 private myArray() { } static int max(int[] arr) { int max = 0; for(int x=0; x&lt;arr.length; x++) { if(max &lt; arr[x]) { max = arr[x]; } } return max; } } 代码块局部代码块 构造代码块 和 静态代码块 代码块的执行顺序: /* * 代码块块的调用顺序: * BlockTest 静态代码块 &gt;&gt;&gt; BlockTest 的主函数调用了 &gt;&gt;&gt; * Phone 静态代码块 &gt;&gt;&gt;Phone 构造代码块 &gt;&gt;&gt;Phone 调用无参构造 * Phone 构造代码块&gt;&gt;&gt;Phone 调用有参构造 */ public class BlockTestDemo { { System.out.println(&quot;BlockTest 构造代码块&quot;); } static { System.out.println(&quot;BlockTest 静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;BlockTest 的主函数调用了&quot;); Phone p = new Phone(); Phone p1 = new Phone(); } } class Phone { private String name; private String prices; { System.out.println(&quot;Phone 构造代码块&quot;); } static { System.out.println(&quot;Phone 静态代码块&quot;);//随着类的加载而加载 } public Phone() { System.out.println(&quot;Phone 调用无参构造&quot;); } public Phone(String name, String prices) { System.out.println(&quot;Phone 调用有参构造&quot;); this.name = name; this.prices = prices; } // 结果显示: // BlockTest 静态代码块 // BlockTest 的主函数调用了 // Phone 静态代码块 // Phone 构造代码块 // Phone 调用无参构造 // Phone 构造代码块 // Phone 调用无参构造 } 继承/* * 继承: 多个类有共同的成员变量和方法, 抽取到另外一个类中(父类), * 再让多个类去继承这个父类, 我们就可以获取得到父类的成员了. */ public class ExtendsDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Dota d = new Dota(); d.sart(); LOL l = new LOL(); l.sart(); } } //抽取多个类的共性, 得到父类 class Game { String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); } } class Dota extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } class LOL extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } 继承中的成员变量的特点 /* * super: 可以获取父类的成员变量和成员方法, 用法和this相同. */ public class ExtendsDemo_01 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Child c = new Child(); c.show(); } } class Dad { String name = &quot;张三&quot;; } class Child extends Dad{ String name = &quot;张四&quot;; void show() { String name = &quot;张五&quot;; System.out.println(super.name); //调用父类的成员变量 System.out.println(this.name); //调用成员变量 System.out.println(name);// 就近原则:谁离我近就用谁 } } 继承中成员方法的特点 重写和重载的区别 继承中的构造方法的执行顺序 /* * 继承中构造方法的执行循序 * 在有子类继承关系的类中, 创建子类对象, 调用子类的构造方法, * 如果子类构造方法的第一行代码没有调用父类的构造方法, 则会默认的调用父类的无参构造. * 可以使用super()在子类构造方法的第一行中调用父类的构造方法 * 总结: * 始终都要调用父类的构造函数 */ public class ExtedndsDemo { public static void main(String[] args) { Child c = new Child(); } } //运行结果: //调用 父类无参构造 //调用 子类有参构造 //调用 子类无参构造 class Dad { public Dad() { System.out.println(&quot;调用 父类无参构造&quot;); } public Dad(int num) { System.out.println(&quot;调用 父类有参构造方法&quot;); } } class Child extends Dad{ public Child() { this(2); //调用子类的有参构造 System.out.println(&quot;调用 子类无参构造&quot;); } public Child(int num) { //调用父类无参构造 System.out.println(&quot;调用 子类有参构造&quot;); } } 继承的优缺点 ​ 优点: 提高了代码的复用性, 代码的可维护性 ​ 缺点:类的耦合性增强了， ​ 开发原则：高内聚低耦合 ​ 内聚：就是自己完成某件事情的能力. ​ 耦合：类与类的关系 抽象类​ /* * abstract 抽象类 * 抽象类不能实例化 * 抽象类有构造函数 * @Override * 在子类继承抽象类中, 需要重写抽象类的方法 */ public class abstractDemo { public static void main(String[] args) { Cat c = new Cat(&quot;Ruby&quot;, 10); c.eat(); c.run(); Dog d = new Dog(&quot;Bruces&quot;, 7); d.eat(); d.run(); } } abstract class Animals { String name; int age; public Animals(String name, int age) { this.name = name; this.age = age; } public abstract void eat(); //提供接口的功能 public void run() { System.out.println(&quot;run&quot;); } } class Cat extends Animals { public Cat(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The cat eats fishing.&quot;); } } class Dog extends Animals { public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The dog eats food.&quot;); } } 接口/* * Java语言是继承是单一继承, 一个子类只能有一个父类(一个儿子只能有一个亲爹) * Java语言给我们提供了一种机制,用于处理继承单一的局限性, 接口 * * 接口: 接口是一个比抽象类还抽象的类, 接口里所有方法全是抽象方法, 接口和类的关系是implements(实现) * interface * * 接口成员特点: * 只有抽象方法 * 只能有常量 * 默认和只能使用public abstract 修饰方法 * 默认使用 public static final 修饰变量 * 注意: * 接口不能创建对象(不能实例化) * 类与接口的关系是实现关系, 一个类的实现一个接口, 必须实现它所有的方法. * * 类与类: 继承关系, 单一继承, 多层继承 * 类与接口: 实现关系, 多实现 * 接口与接口的关系: 继承关系, 多层继承 */ public class interfaceDemo { public static void main(String[] args) { Tiger t = new Tiger(); t.eat(); Demo d = new Demo(); d.function(); d.method(); } } interface Animals { public static final int age = 10; public abstract void eat(); } class Tiger implements Animals { @Override public void eat() { System.out.println(&quot;eat&quot;); } } //接口与接口的关系是单一继承 interface interA { public abstract void method(); } interface interB extends interA{ public abstract void function(); } //类与接口是实现关系, 多实现 //每个接口都需要一个实现类, Demo是interA, interB的实现类 class Demo implements interA, interB { @Override public void function() { } @Override public void method() { } } 接口的优点: ​ 打破了继承的局限性， ​ 对外提供规则 ​ 降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发效率． 分析问题： ​ 分析: 由下至上, 不断向上抽取的过程 ​ 实现: 由上至下, 先实现共性 ​ 使用: 使用具体的子类. ​ /* 抽象类可以继承普通类 */ class Person { String name; int age; public void sleep() { System.out.println(&quot;sleep&quot;); } public void eat() { System.out.println(&quot;eat&quot;); } } abstract class Player extends Person{ public abstract void study(); } 匿名对象匿名对象: 没有名字的对象 应用场景： ​ 当方法只调用一次的时候, 可使用匿名对象 ​ 可以当作参数进行传递 //普通创建对象 Student st = new Student(); //匿名对象 new Student() //匿名对象可以当作参数 function (new Studnet); final​ 自定义常量必须初始化, 可以选择显示初始化或者构造初始化 多态/* * 多态的前提: * 子父类的继承关系 * 方法的重写 * 父类引用指向子类对象 * 动态绑定: * 运行期间调用的方法,是根据具体类型. */ public class Demo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Animals a = new Cat(); //多态的实现 a.eat(); } } class Animals{ public void eat() { System.out.println(&quot;吃东西&quot;); } } class Cat extends Animals { //方法的重写 public void eat() { System.out.println(&quot;猫吃鱼&quot;); } } 多态成员的特点: /*成员变量: 编译时看的是左边, 运行时看的是左边 成员方法: 编译时看的是左边, 运行时看的是右边 静态防范: 编译时看的是左边, 运行时看的也是左边. 总结: 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法)看的都是左边. */ Dad d = new Kid(); //左边是 Dad d //右边是 new Kid() 多态中的向上转型和向下转型 Anmials a =new Dog(); //多态实现, 向上转型, 子类转化为父类 Dog d = (Dog)a; //向下转型, 父类转化为子类 多态的优缺点以及如何实现多态 /* * 多态的优缺点: * 优点: 可以提高可维护性(多态提前保证的), 提高代码的扩展性, * 缺点:无法直接访问子类特有的成员． */ public class Demo02 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); PhoneFactory pf = new PhoneFactory(); //实现多态 pf.createPhone(new XiaoMi()); //调用匿名对象 pf.createPhone(new HongMi()); } } //实现多态. class PhoneFactory { //用父类对象作参数 public void createPhone(Phone p) { p.create(); } } interface Phone { public abstract void create(); } class XiaoMi implements Phone { @Override public void create() { System.out.println(&quot;小米手机&quot;); } } class HongMi implements Phone{ @Override public void create() { System.out.println(&quot;红米手机&quot;); } } 权限修饰符​ public: 当前类, 相同包下不同的类, 不同包下的类 可以访问 ​ default: 当前类, 相同包下的不同类 可以访问 ​ private:当前类 ​ protected: 当前类, 不同包下的类 ​ default 和 protected 的区别: ​ default: 当前包下使用 ​ protected: 让子类对象使用 内部类​ 方法内部类 ​ 局部内部类 ​ 匿名内部类 迭代器迭代器是依赖于集合的， 相当于集合的一个副本，当迭代器在操作的时候， 如果发现和集合不一样， 则抛出异常（并发修改异常） foreach：增强for循环， 一般用于遍历集合或者数组。 List的常用子类​ ArrayList： 底层数据结构是数组， 查询快，增加删除慢 ​ LinkedList： 底层数据结构是链表，查询慢， 增加删除块 多线程多线程的执行方式 /* * 多线程的实现方式： * 方式1：一种方法是将声明为Thread的子类。 该子类应重写Thread类的run方法，接下来可以分配并启动子类的实例。 * * CPU执行程序的随机性 */ public class Demo { public static void main(String[] args) { myThread mt = new myThread(); mt.setName(&quot;Thread 1 &quot;); mt.start(); myThread mt1 = new myThread(); mt1.setName(&quot;Thread 2 &quot;); mt1.start(); myThread mt2 = new myThread(); mt2.setName(&quot;Thread 3 &quot;); mt2.start(); } } 多线程出现数据访问问题： /* 要有多个线程 要有被多个线程所共享的数据 多个线程并发的访问共享数据 */ synchronized: 同步（锁）， 可以修饰代码块和方法， 被修饰和代码块和方法一旦被某个线程访问，则直接被锁住，其他线程无法访问。 同步代码块： synchronized{ ...... } 同步方法： public synchronized void method(); note:2018-10-22 17:51:18 == 与 equals== : 它的作用判断两个对象的地址是否相等, 判断基本数据类型的值是否相等. equals: String 中的 equals() 方法是被重写的, 因为 Object 的 equals 方法是比较对象的内存地址.而 String 的 equals 方法是比较对象的值. 线程, 程序, 进程的基本概念和他们之间关系1. 线程和进程相似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 与线程不同的是同类的多个线程共享同一个内存空间和一组系统资源, 所以系统产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因如此, 线程也被称称为轻量级进程. 2. 程序是含有指令和数据的文件, 被存储在磁盘或者其他的数据存储设备中, 也就是说程序是静态的代码. 3. 进程是程序一次运行过程, 是系统运行的基本单位, 因为进程是动态. 系统运行一个程序即是一个进程从创建, 运行到消亡的过程.简单来说, 一个进程就是一个执行中的程序, 它在计算机中的一个指令接着一个指令的执行, 同时, 每个进程还占某些系统资源如CPU时间, 内存空间, 文件, 输入输出设备的使用权等等. 4. 换句话说, 当程序在执行时, 将会被操作系统载入内存中, 线程是进程划分成的更小的运行单位. 线程和进程最大不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响. 从另一角度出发, 进程属于操作系统的范畴, 主要是同一段时间内, 可以同时执行一个以上的程序, 而线程则是在同一个程序内几乎同时执行一个以上的程序段. 线程的基本状态和基本状态的定义 新建（new): 新创建了一个线程对象. 可运行(runnable):线程对象创建后, 其他线程(比如main线程)调用了该对象的 start() 方法. 该状态的线程位于可运行线程池中, 等待被线程调度选中, 获取CPU的使用权. 运行(running): 可运行(runnable)的线程获得了 CPU 时间片(time slice), 执行程序代码. 阻塞(block): 阻塞状态是指线程因为某种原因放了CPU的使用权, 也即让出了 CPU time slice. 暂时停止运行. 直到线程进入可运行的状态, 才有机会再次获得 CPU time slice 转到运行状态. 阻塞的情况分三种: 等待阻塞 同步阻塞 其他阻塞 死亡: 线程 run(), main()方法执行结束后, 或者因异常退出了run()方法, 则该线程接受了生命周期. 死亡的线程不可再次复生. 在 Java 中定义一个不做事且没有参数的构造方法的作用 Java 程序在执行子类的构造方法之前, 如果没有用super()来调用父类特定的构造方法, 则会调用父类中没有参数的构造方法. 因此父类中只定义了有参数的构造方法, 而在子类的构造方法中又没有的super()来调用父类中特定的构造方法, 则编译时将方法错误, 因为 Java 程序在父类中找不到没有参数的构造方法可执行. 解决方法是咋父类里加上一个不做事且没有参数的构造方法. Java 和 C++的区别都是面向对象的语言， 都支持封装，继承和多态 Java 不提供指针来直接内存，程序内存更加安全 Java 的类是单继承的， C++支持多继承； 虽然 Java 的类不可以多继承， 但是接口可以多继承 Java 有自动内存管理机制， 不需要程序员手动释放无用内存 接口和抽象类的区别： 接口的方法默认是 public， 所有方法在接口中不能有实现，抽象类可有非抽象的方法 接口中实例变量默认是 final 类型， 而抽象类中则不一定 一个类可以实现多个接口， 但最多只能实现一个抽象类 一个类实现接口的话， 要实现接口的所有方法， 而抽象类不一定。 接口不能用 new 实例化， 但可以声明， 必须应用一个实现该接口的的对象 从设计层面来说， 抽象是对类的抽象，是一种模板设计； 接口是行为的抽象， 是一种行为的规范。 静态方法和实例方法 在外部调用静态方法，可以使用“类名.方法名”的方式， 也可以使用“对象.方法名”的方式。 而实例方法只有后面这种方式。 也就是说， 调用静态方法可不需要创建对象。 静态方法在访问本类的成员时， 只允许访问静态成员（即静态成员变量和静态方法）， 而不允许访问实例成员变量和实例方法； 实例方法则无此限制。 对象的相等与指向他们的引用相等，两者有什么不同？ 对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 帮助子类做初始化工作。 注释和注解的区别 Java中的注释和其他编程语言一样，注释的内容不会被编译运行，知识源代码中对代码的解释说明， 提高源代码的可读性。 Java中的注解（Annotation），也叫元数据，是Java 5以后版本引入的一个特性 注解与类、接口、枚举是在同一个层次，可以用来标注包、类、字段、方法、局部变量、方法参数等元素，达到对这些元素的面数和说明。 注解是可以允许 jvm 在运行中读取它，这一点与注释完全不同。 注解作用： 编写文档， 代码分析， 编译检查]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F08%2F28%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[换行：1.方法1： 连续两个以上空格+回车。 首行缩进两个字符：（每个表示一个空格，连续使用两个即可） 1.&amp;ensp;半角的空格 ​ 2.&emsp;全角的空格 字体、字号、颜色 - &lt;font color=red&gt;red&lt;/font&gt; - &lt;font color=blue&gt;blue&lt;/font&gt; - &lt;font color=green&gt;green&lt;/font&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clovers]]></title>
    <url>%2F2018%2F08%2F28%2Fclover%2F</url>
    <content type="text"><![CDATA[快捷键技巧： Ctrl+W关闭页面Ctrl+Tab切换页面]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>clovers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;stromzhang&quot; git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知道自己不知道的]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[入门篇： python 和 java Script 选择 入门语言 学习使用操作系统linux 学习使用编程工具 vs 和 vs code 正式入门 推荐文章： The Key To Accelerating Your Coding Skills 编程技巧方面：怎么把程序写好的书（代码大全）。 java语言学习：Java核心技术卷一， spring: spring in action 操作系统：鸟哥的Linux私房菜 网络协议：HTTPS文档， 数据库设计：慕课网 数据库设计那些事 数据库：MySQL必知必会 前端方面： 编码方面：ASCII, UNICODE, 编程工具方面：JAVA VS CODE 版本管理工具：GIT, 调试前端工具： 数据库设计工具： java语言 综合性实力最强 IDE 版本管理工具 git 调试前端工具 数据库设计工具 程序员修养 英文能力 问问题的能力 写代码的修养 安全防范意识 软件工程和上线规范 编程规范 专业技术篇 编程语言: c, c++, java 理论学科: 算法与数据结构，网络模型，计算机原理，操作系统原理，编译原理，数据库原理。（工人和工程师的差别） 系统知识：Unix, Linux, TCP/IP, C10K 从业方向：底层，大数据，分布式开发等等。 软件设计能力&emsp;&emsp;工程师走向架构师 程序员荒谬之言还是至理名言 如果你把一个技术搞精搞深，你的知识面自然会很广的。 面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会（依据自己兴趣学习） 为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。 不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。 永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。（特别赞同） Teach Yourself Programming in Ten Years——用十年教会自己编程]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>系统知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
