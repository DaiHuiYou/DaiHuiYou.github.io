<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vscode]]></title>
    <url>%2F2019%2F06%2F22%2Fvscode%2F</url>
    <content type="text"><![CDATA[配置流程 通过 ctrl+shift+p 输入 tasks 编辑配置 json， 产生 Tasks.json 通过 ctrl+shift+p 输入 C/C++ 编辑配置 json， 产生 C_Cpp_Properties.json 通过为bug图标中 Add Configuration, 产生 Lanch.json，实在找不到的话，问百度， 是我表达能力实在不好啦 -_-。 自定义任务设置在 Tasks.json 中编辑 Compile 任务 调试参数设置Lanch.json &quot;preLaunchTask&quot;: &quot;Compile&quot; // 说明在执行 Lanch.json 之前，即要先执行名为 Compile 的任务，其功能为代替程序编译过程， 不用ctrl + shift + b 编译，再按 F5 才可以调试。 编译器参数设置C_Cpp_Properties.json是用于配置编译器环境的，包括启动器代号、位数（这些是自定义的）、编译选项、启动设置、编译模式等。 includePath指向C/C++标准库、用户头文件所在位置。 通过 ctrl+shift+p 输入 C/C++ 编辑配置json， 则可以产生 C_Cpp_Properties.json。 配置文件以后直接复制 .vscode 文件 到新的工程文件，就OK了。 链接：https://pan.baidu.com/s/1wfMe5gVy4SPPrpHhlcq3eQ提取码：fszt]]></content>
  </entry>
  <entry>
    <title><![CDATA[c++基础与提高]]></title>
    <url>%2F2019%2F06%2F20%2Fc-%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%8F%90%E9%AB%98%2F</url>
    <content type="text"><![CDATA[c++基础与提高_王桂林老师 一本不错的 C++ 基础讲解，推荐。 链接：https://pan.baidu.com/s/1K8w4IpAwfGTqoUDWcZIxmA提取码：mrch 重载底层的实现 C++ 利用 name manglinig 技术， 来更改函数名， 区分参数不同的同步函数。 实现原理：用 v-c-i-f-l-d 表示 void char int float long double 及其引用。 void func(char a): //func_c(char a) void func(char a, int b, double c); // func_cid(char a, int b, double c) extern “C” name mangling 发生在两个阶段， .cpp编译阶段 和 .h的声明阶段。 只有两个阶段同时进行，才能匹配调用。 C++ 完全兼容 C语言， 那就面临着，完全兼容 C 的类库， 有 .c 文件的类库文件中函数名并没有发生 name mangling 行为， 而我们在包含 .c 文件所对应的 .h 文件时， .h文件要发生 name manling 行为， 因而会发生在链接时时候的错误。 C++ 为了避免上述错误的发生， 重载了关键字 extern。 只需要， 要避免 name manling 的函数前， 加 external “C” 如有多个， 则extern “C”{}； 引用 引用没有定义， 是一种关系型声明。声明它和原有的某一变量（实体）的关系。故而类型与原类型一致，且不分配内存， 与引用的变量有相同的地址。 void swap(int a, int b); //无法实现两数据的交换 void swap(int *p, int *q); //开辟了两个指针空间实现交换 申请内存 C++ 内存申请失败会抛出异常。 //C++ 内存申请失败会抛出异常 try{ int *p = new int[10]; }catch(const std::bad_alloc e) { return -1; } //C++ 内存申请失败不抛出异常版本 int *q = new (std::nothrow)int[10]; if(q == NULL) return -1; new / delete 是关键字， 效率高于 malloc 和 free。 内联函数 C 语言中有宏函数， 宏函数的特点是内嵌到调用代码取，避免了函数调用的开销。 由于宏函数发生在预处理阶段，缺失了语法检查和可能带来的语意猜错。 #if 0 优点：内嵌代码，辟免压栈与出栈的开销 缺点: 代码替换，易使生成代码体积变大，易产生逻辑错误，无类型检查 #endif #define SQR(x) ((x)*(x)) #if 0 优点：高度抽象，避免重复开发，类型检查 缺点: 压栈与出栈，带来开销 #endif inline int sqr(int x) { return x*x; } #endif 类型转换 重新解释类型转换 通常为操作数的位模式提供较底层的重新解释， 也就是说将数据以二进制存在形式的重新解释，在双方向都不可以隐式类型转换，则需要重新解释类型转换。 常类型转换 用来移除对象的常量性（cast away the constness） 使用 const_cast 去除 const 限定的目的不是为了修改它的内容， 使用 const_cast 去除 const 限定， 通常是为了函数能够接受这个实际参数。 动态类型转换 用于多态总的父子类的强制转化。 封装 struct 从单一变量无法完成描述需求的时候，结构体变量类型解决了这个问题，可以将多个类型打包成一体，形成新的类型， 这是 C 语音中的封装的概念。 但是新类型不包含， 对数据类的操作。 所有的操作都是通过函数的方式，去其进行封装。 class 用 class 去封装带行为的类， class 封装的本质，在于将数据和行为， 绑定在一起然后通过对象来完成操作。 this 指针 基于 this 指针的自身引用还被广泛应用与那些支持多重串联调用的函数中。 返回栈上的引用与对象 不管是返回指针还是返回值， return 将 return 之后的值存到 eax 寄存器中， 回到父函数再将返回的值赋给变量。 友元 有时定义一些函数， 这些函数是类的一部分，但有需要频繁访问类的数据成员，这时可以将这些函数定位该类的友元函数，除了友元函数外，还有友元类，两者统称为友元。友元的作用提高了程序的运行的效率（即减少了类型的检测和安全性检查即调用的时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问的私有成员。 友元目的本质，是让其他不属于本类的成员（全局函数，其他类的成员函数），成为类的员而具备了本类成员的属性。 友元不是类成员，但是它可以访问类中私有成员。友元的作用就是提高程序运行效率，但是它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。 代理类 好的软件工程有两个基本原则，一是接口与实现的分析，二是隐藏实现细节。为此，我们向用户提供头文件，而实现在一个CPP 文件中。 但是用户提供的头文件，还有一些 private，虽然不能访问，但还是把私有信息暴露给了客户。 通过向客户提供只知道的类的 public 接口，就可以使客户能够使用类的服务，而无法实现类的细节。 继承 关系定性 is-a / has-a is-a 是一种属于关系 car is a vehicle. has-a 是一种包含、组合关系 继承和组合的区别 public 公有继承 当类的继承方式为公有继承时，基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可访问。 private 私有继承 当类的继承方式为私有继承时，基类中的公有成员和保护成员都已私有成员身份出现在派生类中，而基类的私有成员在派生类中不可访问。 类似组合 protected 保护继承 保护继承中，基类的公有成员和私有成员都已保护成员的身份出现在派生类中，而基类的私有成员不可访问。 派生类的构造 派生类中由基类继承而来的成员的初始化还是有基类的构造函数完成，然后派生类中新增的成员在派生类的构造函数中初始化。 子类构造器中，要么显示的调用父类的构造器(传参)， 那么隐式调用。 发生隐式调用时，父类要有无参构造器或是可以包含无参构造器的默认参数函数。子类对象亦然。 派生类的拷贝构造 派生类的默认拷贝构造器会调用父类中默认或自实现拷贝构造器，若派生类中自实现拷贝构造器，则必须显示的调用父类的拷贝构造器。 派生类的赋值运算符重载 赋值运算符函数不是构造器，所以可以继承，语法上没有构造器的严格一些。 派生类的默认赋值运算符重载函数，会调用父类的默认或自实现函数。派生类若自实现，则不会发生调用行为，也不报错，赋值错误。若要正确，需要显示的调用的父类的构造器。 派生类的友元函数 由于友元函数是并非类成员，因此不能被继承，在某种需求下，可能希望派生类的友元函数能够使用基类中的友元函数，为此可以通过强制类型转换，将派生类的指针或是引用强制转为其类的引用或指针，然后使用转换后的一引用或是指针来调用基类中的友元函数。 派生类析构函数 派生类的析构函数的功能是在该对象消亡之前进行一些必要的清理工作，析构函数没有类型，也没有参数。析构函数的执行与构造函数相反。 子类 -&gt; 成员 -&gt; 基类 虚继承 在多继承中，保存共同的基类的多分同名成员，虽然有时是必要的，可以在不同的数据成员中分别存放不同的数据，但在大多数情况下，是我们不希望出现的。因为保留多分数据成员的拷贝，不仅占有较多的存储空间，还增加了访问的困难。 为此，C++ 提供了， 虚基类和虚继承机制，实现了在多继承中只保留一份共同成员。 虚基类，需要设计和抽象，虚继承，是一种继承的扩张。 多态 C++ 中所谓的多态是指：由继承而产生的相关的不同的类，其对象对同一消息作出不同的相应。 静多态 函数重载， 通过命名倾轧在编译阶段决定，故称为静多态。 动多态 动多态，不是在编辑器阶段决定的，而是在运行阶段决定，故称为动多态。 赋值兼容规则是指在需要基类对象的任何地方都可使用公有派生类的对象来替代。赋值兼容是一种默认的行为，不需要任何的显示的转化步骤。 纯虚函数 含有纯虚函数的类，称为抽象基类，不可实例化。即不能创建对象，存在的意义就是被继承，提供该类的公共接口， Java 中称为 interface 含有虚函数的析构 含有虚函数的类， 析构函数也应该声明为虚函数。 在 delete 父类指针的时候，会调用子类的析构函数，实现完整析构。 设计模型 C++ 中有一种设计原则叫依赖倒置原则，也是基于多态的。 定义：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节搭建起来的架构要稳定的多。 在 c++ 中，抽象指的是抽象类（c++称为接口），细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去设计任何具体的操作， 把展现细节的任务交个他们的实现类去完成。 传统的过程式设计倾向于使高层次的模块依赖于低层次的模块，抽象层依赖于具体的层次。 依赖倒置原则的核心思想是面向接口编程。 代表高层模块的讲负责完成主要的业务逻辑，一旦需要对它进行修改，进入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。 依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程， 也就是理解了依赖倒置原则。 运行时类型信息（RTTI） typeid dynamic_cast 是 C++ 运行时类型信息 RTTI（run time type identification) 重要组成部分。运行时信息，来自于多态，所以以下运算符只用于基于多态的继承体系中。 typeid 运算符 typeid 返回包含操作数数据类型信息的 type_info 对象的一个引用，信息中包括数据类型的名称。 多态实现浅解析 虚函数表 C++ 的多态是通过一张虚函数表来实现的， 这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆写的问题，保证其真实反应的实际的函数，这样，在有虚函数的类的实例中这个表被分配在这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就指明了所应该调用的函数。 Base *b = new Derive(); b-&gt;f(); 当编译器看到这段代码的时候，并不知道 b 真实身份。编译器能作的就是用一段代码来替这段语句。 明确 b 类型 然后通过指针虚函数表的指针 vptr 和偏移量，匹配虚函数的入口地址。 然后根据入口地址调用虚函数。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件工程之美]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E%2F</url>
    <content type="text"><![CDATA[什么是软件？软件的目标用户是面向用户，然而程序是面向硬件的。 看待问题的角度很多时候， 自己在分析问题时往往陷入细节中， 并不能迅速想出解决方案。 类似写作，并不是确定好一个题目， 自己想到哪，写到哪， 往往结果是离题了。好的做法应该是：确定好题目，确定好架构（即你要写的大概的内容），架构好了，最后去写就是了。 当用工程方式去思考，会更多站在整体而非局部去思考， 更有大局观。 everthing is project。 会议的价值你是砍材的，他是放羊的，你和他聊一天，他的羊吃饱了，你的材呢？ 反思在编写自己的函数时，仅仅假设一个特定样本数据的输入， 并满足该函数的输出要求，就马不停蹄实现下一个函数的定义。 完全没有考虑这函数的健壮性，即没有足够的样本数据进行单元测试， 这样的函数犹如建房子的砖瓦「够用就行」。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F06%2F06%2Fleetcode%2F</url>
    <content type="text"><![CDATA[sort() 算法 sort() 时间复杂度 Sort() 因为它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高！ 果断放弃的自己造轮子， 来实现 时间复杂度为 O(n^2) 的冒泡或者选择算法。 ^_^ list.sort() list::iterator it 没有重载 + 运算符，不能 it+5, 只能 it++; 由于算法 sort() 支持随机访问的容器, 即需要满足 it+5类似的操作。所以在list中另外实现成员函数sort() 。 map unordered_map 在 unordered_map 中，键值通常用于唯一标识元素，而映射值是与该键关联的内容的对象。键和映射值的类型可能不同。 在内部，unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。 unordered_map 容器比映射容器更快地通过它们的键来访问各个元素，尽管它们通过其元素的子集进行范围迭代通常效率较低。 关键词：无序的 快速的检索 达到的是更快的访问 但是子集的范围迭代效率低。 vector and deque 都为动态数组，支持随机存取, 具有自动增长空间。 deque 区别与 vector： deque 在头尾都支持插入和弹出。 而 vector 只能在尾部插入和弹出。 stack and queue stack 不支持随机存取（没有 [] operator 重载），不能遍历（没有迭代器），只能通过栈顶获取元素和删除元素。 queue 不能进行遍历， 不支持随机存取； 一端插入，另一端删除。 vector&lt;vector\&gt; 1. vector&lt;vector\&lt;int>&gt; v; 由于vector对 []operator 进行重载, 可以采用 v[i][j] [i] 表示获取一个为vector的元素； [j] 在vector中，获取一个int的值。 2. vector&lt;stack\&gt; vs; 由于stack 不对 []operator 进行重载， vs[i][j] 为错误写法。 运算溢出 防止数据溢出 int res = 100000000; int num = 0; int pop; if(num&lt;INT_MAX/10) num = num*10 + pop; else if(num==INT_MAX &amp;&amp; pop&lt;7) num = num*10 + pop; else if(num&lt;INT_MIN/10) num = num*10 - pop; else if(num==INT_MIN/10 &amp;&amp; pop&lt;8) num = num*10 - pop; else ;]]></content>
  </entry>
  <entry>
    <title><![CDATA[OS]]></title>
    <url>%2F2019%2F05%2F28%2FOS%2F</url>
    <content type="text"><![CDATA[并发和并行 并发： 同一「时间点」顺序执行，同一「时间段」交替重叠。 （本质性上也顺序执行，利用单个 CPU 实现宏观层面的并行） 并行：正真意义上并行，无论微观和宏观上都是并行。完全是多个 CPU 执行。 并发 VS 并行： 单个CPU VS 多个CPU 线程是处理机调度的基本单位 结合我以前的经历，通常单片机的裸机程序的编程都是模块和模块之间的顺序执行，当一个模块因某种原因阻塞，从而导致接下来的模块不能执行而延迟响应，所以不能呈现出良好的实时性。 那么可以通过单片机的「硬件计时」，自己分配处理机的时间片，通过「中断」切换模块和模块之间的执行流程。进而实现模块和模块之间的并发执行。 裸机程序的模块间的并发类似与多线程，理解为模块间是手动分配处理机的执行时间， 而多线程是处理机调度的基本单位，是由操作系统依据特定算法分配线程的处理机执行时间。 只不过单片机未引入操作系统之前，需要自己要分配时间片和确定好中断流程，在操作系统中多线程这不需要这些操作，单纯调用语句就行了。 进程是资源调度的基本单位 单片机通常是执行一个特定的程序（进程）， 不存在进程间的资源争斗问题，一个进程拥有在单片机的全部资源。 我认为多进程的引入是为了充分利用资源。怎么说，属于临界资源的打印机， 一个进程需要打印机资源， 另一个进程也需要打印机资源，并不能让两个进程在同一「时间段」拥有打印机资源。 多进程的实现，在宏观层面上实现进程间的资源共享。当然， 同一时间段， 进程间的资源不能共享。这需要资源分配策略 「 银行家算法的实现 」。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程范式]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[编程范式： 面向对象 强调数据，名词为类，动词为该类的成员方法。 面向过程 整体到局部。 泛型编程 C 的泛型编程的实现 C++ 的泛型编程的实现 函数式编程 C++ 类方法和 C 函数的区别 在变量的角度 在 C 的函数中，只能使用 local variable（函数内部的所有变量），global variable （独立于该函数外的所有变量）。 在C++的 类方法中，可以使用 局部变量，可以使用属于对象的成员变量，可以使用属于类的静态成员变量，以及属于该文件的全局变量。 在数据输出的角度 C 的函数在执行后，通过形参 pointer 来返回结果 或 通过 return 返回结果。结果只能是局部变量的值或者全局变量。 C++的类方法在执行后，可以通过 形参 或者 return 输出 成员变量，静态成员变量， 全局变量，局部变量的值或引用。 对象调用成员方法 和 类调用成员方法： obj.func(): 对象调用成员方法，可能会改变对象状态，也就是说将对象中的成员变量的值因成员方法的调用而所改变。 Class.func(): 类调用成员方法， 由于类无成员变量， 静态成员变量除外。所以 类调用成员方法只是单纯调用函数。 内部类 内部类的拥有外围的所有元素的访问权限 头文件声明和类的声明 C 的头文件的声明 和 C++ 的类的声明类似， 在 C 中，头文件声明变量和函数， 变量可在函数中使用。 在 c++ 中， 类的声明，成员变量和成员函数在 class 中声明， 通常一个文件包含一个类。 类的声明可以当做一个文件。 变与不变的问题 需求不可能是固定的，为了应对需求的改变， 避免以前代码推倒重写，这需要开闭原则（对外支持功能扩展，对已有的代码封闭） 类的成员变量：不变类的成员函数的形参：变 委托模式：接口不变，支持扩展功能。 适配器模式：功能相同，接口不同 策略模式：接口相同，功能不同 代理模式：引用技术，智能指针 装饰模式：不修改原有的代码，进行添加功能]]></content>
      <categories>
        <category>编程范式</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOCKET]]></title>
    <url>%2F2019%2F05%2F20%2FSOCKET%2F</url>
    <content type="text"><![CDATA[TCP连接的粘包问题 由于TCP是面向连接，二进制流传输，由于 Send()是发送给操作系统的缓冲区，并不是立即发送给客户端，等缓冲区有一定大小，再一次性发送给客户端。 所以由于这样的机制，多次消息的发送，可能一次性消息的接受。导致粘包问题，即是多个消息粘在一起发送。 解决方法发送一次消息，等待接受消息，即判断对方是否接受到消息，确定对方接受到了消息，再继续发送下一条消息。 多媒体文件传输 多媒体文件并不是文本文件，采取文本文件读取，对方接受到多媒体文件无法解码。所以文件读取的方式采取是二进制。 传输文件的方法 服务端：读取文件，连续 send()，直到发送完成。等待客户端接受完成消息。 客户端：接受服务端的消息，以二进制的方式存储到文件中，接受完成后，发送服务端接受完成消息。 阻塞和非阻塞 阻塞即是有消息则接受消息，没有消息则一直等待，不去执行其他操作。 在 TCP中 recv() 是采用阻塞方式接受。 非阻塞即有消息接受消息，没有消息则执行其他操作。 多线程实现多个客户端连接 多线程实现多个客户端连接，线程的数量等于客户端的数量， 当客户端连接数量大到一定程序，服务端容易崩溃。 Select模型实现多个客户端连接 select 模型时 Winsock 中最常见的 I/0 模型， 它的中心思想是利用 select 函数，实现多个套接字 I/0 的管理。 利用 select 函数，可以判断套接字上是否存在数据，或则能否向一个套接字写入数据。 只有在条件满足时，才对套接字进行输出操作。 异步 I/0 模型通过调用 WSAAsynocSelect 函数实现，利用这个模型，应用程序可在一个套接字上接受以 windows 消息为基础的网络事件。 ping PING ，使用 ICMP 协议， 基于网络层， 包加上 源IP 和 目的IP， 在 数据链路层中加上源 MAC 地址和目的 MAC 地址，发送到局域网的另一台主机。]]></content>
      <categories>
        <category>SOCKET</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)选择排序// 未优化 template&lt;typename T&gt; void selectionSort1(T arr[], int n) { for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[i]) swap(arr[j], arr[i]); } } return; } // 优化 template &lt;typename T&gt; void selectionSort2(T arr[], int n) { for (int i = 0; i &lt;= n - 1; i++){ int minIndex = i; for (int j = i+1; j &lt;= n - 1; j++) { if (arr[minIndex] &gt; arr[j]) minIndex = j; } swap(arr[minIndex], arr[i]); } return; } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 selectionSort1 : 2.208 s selectionSort2 : 0.108 s 插入排序// 未优化 template&lt;typename T&gt; void InsertionSort1(T arr[], int n) { for (int i = 1; i &lt; n; i++) { for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) { swap(arr[j], arr[j - 1]); } } } // 优化 template&lt;typename T&gt; void InsertionSort2(T arr[], int n) { for (int i = 1; i &lt; n; i++) { T e = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--) arr[j] = arr[j - 1]; arr[j] = e; } return; } 测试 从1万个 0~100 的随机数中，从小到大排序。 InsertionSort1 : 2.653 s InsertionSort2 : 0.064 s 希尔排序// 希尔排序 template&lt;typename T&gt; // n 表示数组 capacity void shellSort(T arr[], int n) { int cnt = n - 1; // 数组元素个数 int tmp = 0; // 临时变量 // d：distance， for (int d = n/2; d&gt;=1; d=d/2) { // 遍历 for (int i = d; i &lt;=cnt; i++) { // 插入排序 tmp = arr[i]; for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) { arr[j + d] = arr[j]; arr[j] = tmp; } } } } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 Insertion Sort : 6.332 s Shell Sort : 0.029 s O(nlogN)快速排序int __partition(int arr[], int l, int r) { int v = arr[l]; int j = l; for (int i = l + 1; i &lt;= r; i++) { if (arr[i] &lt; v) { j++; swap(arr[i], arr[j]); } } swap(arr[j], arr[l]); return j; } void __quickSort(int arr[], int l, int r) { if (l &gt;= r) return; int p = __partition(arr, l, r); __quickSort(arr, l, p - 1); __quickSort(arr, p + 1, r); } // 快速排序 void quickSort(int arr[], int n) { __quickSort(arr, 0, n - 1); } 堆排序void shiftDown(int arr[], int n, int k) { while (2 * k + 1 &lt; n) { int j = 2 * k + 1; if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) { j++; } if (arr[k] &lt; arr[j]) { swap(arr[k], arr[j]); k = j; } else break; } } void heapSort1(int arr[], int n) { // heapify for (int i = (n - 1) / 2; i &gt;= 0; i--) { shiftDown(arr, n, i); } for (int i = n - 1; i &gt; 0; i--) { swap(arr[0], arr[i]); shiftDown(arr, i, 0); } } // n 为数组元素个数 // k 当前要筛选的索引 // arr[0] 为临时存储变量 void shift(int arr[], int n, int k) { while (2 * k &lt; n) { int j = 2 * k; if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if (arr[k] &lt; arr[j]) { // arr[j] 与 arr[k] 交换 arr[0] = arr[j]; arr[j] = arr[k]; arr[k] = arr[0]; k = j; } else break; } } // n 为数组元素个数 // arr[0] 为临时存储变量 void heapSort2(int arr[], int n) { for (int i = (n - 1) / 2; i &gt;= 1; i--) { shift(arr, n, i); } for (int i = n - 1; i &gt;=2; i--) { // arr[i] 与 arr[1] 交换 arr[0] = arr[i]; arr[i] = arr[1]; arr[1] = arr[0]; shift(arr, i, 1); } } 测试 从100 万个 0~100 的随机数中，从小到大排序。 Heap Sort 1 : 2.228 s Heap Sort 2 : 0.248 s]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer]]></title>
    <url>%2F2018%2F12%2F02%2FC%2B%2BPrimer%2F</url>
    <content type="text"><![CDATA[Variables and Basic TypesC++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably. To support 「separate complication」, C++ distinguishes between declaration and definition. The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. 1. Main Function and Library「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main. Standard library collection of types and function that every C++ compiler must support. They also tend to refer to particular part of the library by referring to a library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes. By default, reading cin flushes cout, cout is also flushed when the program end normally. To handle input, we use an object of type istream named cin, This object is also referred to as the standard input. In C++ an expression yields a result. When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1. The word 「nullptr」 is a pointer literal. The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand. To attain a declaration that is not also a definition, add the 「extern」 keyword. An extern that has an initializer is a definition. 2. Variables Initialization Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one. Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class. We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer. Separate compilation lets us split our programs into several files, each of which can be compiled independently. Declaration and Definition To support separate compilation, C++ distinguishes between declarations and definitions. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer: extern int i; // declares but does not define i int j; // declares and defines j Variables must be defined exactly once but can be declared many times. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. Reference A reference is not an object. Instead, a reference is just another name for an already existing object. A reference must be initialized A reference may be bound only to an object, not to a literal or to the result of a more general expression: Unlike a reference, a pointer is an object in its own right. Unlike a reference , a pointer need not be initialized at the time it is defined. references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference. 3. Pointer Pointer Value The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. It can be a null pointer , indicating that it is not bound to any object. Using a Pointer to Access an object When a pointer points to an object, we can use the dereference operator (the * operator) to access that object: We may dereference only a valid pointer that points to an object. Dereferencing a pointer yields the object to which the pointer points. Null Pointers A null pointer does not point to any object. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. nullptr is a literal that has a special type that can be converted to any other pointer type. Modern C++ programs generally should avoid using NULL and use nullptr instead. void* Pointers The type void* is a special pointer type that can hold the address of any object. We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object. Understanding Compound Type Declarations A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types Reference to Pointers A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer. int i = 42; int *p; // p is a pointer to int int *&amp;r = p; // r is a reference to the pointer p r = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i *r = 0; // dereferencing r yields i, the object to which p points; changes i to // the base type of the declaration says that r is a reference to a pointer to an int. It can be easier to understand complicated pointer or reference declarations if you read them from right to left. 4. const QualifierBy Default, const Objects Are Local to a File We want to define the const in one file, and declare it in the other files that use that object. To share a const object among multiple files, you must define the variable as extern. References to const const int ci = 1024; const int &amp;r1 = ci; // ok: both reference and underlying object are const r1 = 42; // error: r1 is a reference to const int &amp;r2 = ci; // error: non const reference to a const object Initialization and Reference to const In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression A Reference to const May Refer to an Object That Is Not const int i = 42; int &amp;r1 = i; // r1 bound to i const int &amp;r2 = i; // r2 also bound to i; but cannot be used to change i r1 = 0; // r1 is not const; i is now 0 r2 = 0; // error: r2 is a reference to const const Pointers and Pointer to const Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored int errNumb = 0; int *const curErr = &amp;errNumb; // curErr will always point to errNumb const double pi = 3.14159; const double *const pip = &amp;pi; // pip is a const pointer to a const object On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. int *p = p3; // error: p3 has a low-level const but p doesn&#39;t p2 = p3; // ok: p2 has the same low-level const qualification as p3 constexpr and Constant Expressions A constant expression is an expression whose value cannot change and that can be evaluated at compile time. Such functions must be simple enough that the compiler can evaluate them at compile time. Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions. Pointers and constexpr const int *p = nullptr; // p is a pointer to a const int constexpr int *q = nullptr; // q is a const pointer to int The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines. constexpr int *np = nullptr; // np is a constant pointer to int that is null int j = 0; constexpr int i = 42; // type of i is const int // i and j must be defined outside any function constexpr const int *p = &amp;i; // p is a constant pointer to the const int i constexpr int *p1 = &amp;j; // p1 is a constant pointer to the int j 5. Dealing with Types Type Aliases Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used. We can define a type alias in one of two ways. Traditionally, we use a typedef typedef char *pstring; const pstring cstr = 0; // cstr is a constant pointer to char const pstring *ps; // ps is a pointer to a constant pointer to char When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char, the base type is char and the is part of the declarator. The auto Type Specifier Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer. The decltype Type Specifier Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression: decltype(f()) sum = x; // sum has whatever type f returns const int ci = 0, &amp;cj = ci; decltype(ci) x = 0; // x has type const int decltype(cj) y = x; // y has type const int&amp; and is bound to x decltype(cj) z; // error: z is a reference and must be initialized decltype and References Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment // decltype of an expression can be a reference type int i = 42, *p = &amp;i, &amp;r = i; decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int decltype(*p) c; // error: c is int&amp; and must be initialized // decltype of a parenthesized variable is always a reference decltype((i)) d; // error: d is int&amp; and must be initialized decltype(i) e; // ok: e is an (uninitialized) int // The type is a reference to the type of the left-hand operand. int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // equal to :int &amp;d = a; Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 6. Defining Our Own Data StructuresIn C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes. Defining the Sales_data Type struct Sales_data { std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body. It is a common mistake among new programmers to forget the semicolon at the end of a class definition. Writing Our Own Header Files In order to ensure that the class definition is the same in each file, classes are usually defined in header files. classes are stored in headers whose name derives from the name of the class. Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations. A Brief Introduction to the Preprocessor The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif. Preprocessor variable names do not respect C++ scoping rules. Preprocessor variables, including names of header guards, must be unique throughout the program. 7. Defined Termsconst reference Colloquial synonym for reference to const. constant expression Expression that can be evaluated at compile time. declaration Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared. definition Allocates storage for a variable of a specified type and optionally initializes the variable. object A region of memory that has a type. A variable is an object that has a name.outer scope Scope that encloses another scope. preprocessor variable Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled. reference An alias for another object. struct Keyword used to define a class. typedef Defines an alias for another type. void* Pointer type that can point to any nonconst type. Such pointers may not be dereferenced. Strings, Vectors, and ArraysC++ defines a rich library of abstract data types. Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections. Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector. The built-in types represent facilities present in most computer hardware, such as numbers or characters. The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly. A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type. 1. Namespace using DeclarationHeaders Should Not Include using Declarations. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts. 2. Library string TypeA string is a variable-length sequence of characters. To use the string type, we must include the string header. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization. string s5 = &quot;hiya&quot;; // copy initialization string s6(&quot;hiya&quot;); // direct initialization string s7(10, &#39;c&#39;); // direct initialization; s7 is cccccccccc The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered. Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator. Adding Literals and strings When we mix strings and string or character literals, at least one operand to each + operator must be of string type Dealing with the Characters in a string In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Processing Every Character? Use Range-Based for If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」. The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in declaration is initialized from the value of the next element in expression. Using a Range for to Change the Characters in a string If we want to change the value of the characters in a string, we must define the loop variable as a reference type. string s(&quot;Hello World!!!&quot;); // convert s to uppercase for (auto &amp;c : s) // for every char in s (note: c is a reference) c = toupper(c); // c is a reference, so the assignment changes the char in s cout &lt;&lt; s &lt;&lt; endl; a subscript The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position. Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1]. The value in the subscript is referred to as 「a subscript」 or 「an index」. The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined. 3. Library vector TypeA vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」. Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called 「instantiation」. vector&lt;int&gt; ivec; // ivec holds objects of type int vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items vector&lt;vector&lt;string&gt;&gt; file; // vector whose elements are vectors 「vector is a template, not a type.」 Types generated from vector must include the element type. NoteConventions for Variable Names：变量名称的约定 separate compilation：独立编译 tend to：倾向于 fits in：适合 so far：目前为止 the indicated value: 指定的值 yields a result : 产生一个结果 bound to (bind to) :绑定 plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析 evaluated : 求…值 do not respect C++ scoping rules: 不遵守作用域规则 be used to： 用于 associative:联合 container:容器，集装箱 derived-Class: 派生类/子类 alias:别名 override: 重写 overloading: 重载 directive:指令 redirect: 重定向 indicator:指示 arguments: 实参 library facility:库功能 (工具库) statements:语句 extensive: 大规模 mechanisms: 机制 string literal: 字符串字面量 semicolon: 分号 block: 代码块 iteration: 重复 comments: 注释 built-in type： 内置类型 backslash： 反斜杠 carriage return： 回车 Escape Sequences: 转义序列 initializer: 初始化 commas： 逗号 type specifier: 类型说明符 Identifiers: 标识符 inclusive：包括 Nested Scopes：嵌套范围 fetch: 获取 type modifiers: 类型修饰符 underlying: 底层 Qualifier: 限定符 plain: 原始,素 synonym: 同义词 groups: 分组 implement：实现 strategy：a plan of action 策略 contents:内容 cover: 介绍 / 覆盖 punctuation: 标点 capitalize: 大写字母 subscript：下标]]></content>
      <categories>
        <category>原版书籍</category>
      </categories>
      <tags>
        <tag>原版书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硅谷来信]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[收获比较大的方面： 学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。 科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 结论可以证实，但不可证伪。为什么呢？ 就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？ 总之， 因为未来的不确定，结论可以证实，不能证伪。 别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。 语录： 对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 2. 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。 3. 编程规范#ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; }]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1. for循环常用写法void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 2. 循序栈和链式栈stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 3. 线性表顺序存储和链式存储单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 4. 基本概念数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 5. 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法 二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历 先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 6. 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。 7. 图线性表中我们把数据元素叫元素，树中的数据元素叫结点，在图中数据元素，我们称之为顶点（Vertex）。 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。同样，在图的结构中，不允许没有顶点，在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。 图中，任意两个顶点你之间都可能有关系，顶点之间的逻辑关系用吧边表示，边集可以是空的。 连通图 在无向图 G 中， 如果对于图中任意两个顶点v1，v2都是连通的，则称 G 是连通图。 无向图中的极大连通子图称为连通分量。 有向图 G 中，如果对于每一对vi， vj， 从vi 到 vj 和 从 vj 到 vi都存在路径，则称 G 是强连通图。 邻接表 一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间的浪费。这个思路同样适用于图的存储，我们把这种数据与链表结合的存储方法称为邻接表。 顶点表的各个结点有 data 和 firstedge 两个域表示， data 是数据域，存储顶点信息，firstedge 是指针域，指向边表的第一个结点。 边表结点有 adjvex 和 next 两个域组成， adjvex 是邻接点域，存储某顶点的邻接点在顶点中的下标。 next 则存储指向表中下一个结点的指针。 有时为了便于确定顶点的入度或以顶点为弧头的弧， 有向图的逆连接表，即对每个顶点 v1 都建立一个链接为 v1 为 弧头的表。 邻接矩阵 图的邻接矩阵存方式是用两个数组来表示图。一个一维数组存图中顶点信息， 一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2018%2F10%2F11%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[多态 多态即多种形态，多态的实现即3步骤：有继承，虚函数重写，父类指针指向子类对象。 那么类中函数的重载（overloading），也是多态，同一函数名的多种状态。 多态实现的原理： 在类的成员方法有virtual关键字，那么在创建类对象时，编译器会把对象添加一个虚函数指针,来指向虚函数表。 虚函数表的作用来存放类中成员方法的虚函数地址。在程序运行时，根据虚函数表才能确定对应执行的操作（动态绑定） 为什么类中的析构函数通常都要添加 virtual 关键字？ 是为了正确调用子类的析构函数，不引发子类对象析构时的错误。 在父类中没有添加virtual的析构函数时，父类指针指向子类对象并析构子类对象时，只调用父类的虚构函数，导致错误的析构。 #include&lt;iostream&gt; using namespace std; class Base { public: Base() {}; //Base的构造函数 ~Base() //Base的析构函数 { cout &lt;&lt; &quot;Output from the destructor of class Base!&quot; &lt;&lt; endl; }; virtual void DoSomething() { cout &lt;&lt; &quot;Do something in class Base!&quot; &lt;&lt; endl; }; }; class Derived : public Base { public: Derived() {}; //Derived的构造函数 ~Derived() //Derived的析构函数 { cout &lt;&lt; &quot;Output from the destructor of class Derived!&quot; &lt;&lt; endl; }; void DoSomething() { cout &lt;&lt; &quot;Do something in class Derived!&quot; &lt;&lt; endl; }; }; int main() { Derived *pTest1 = new Derived(); //Derived类的指针 pTest1-&gt;DoSomething(); delete pTest1; cout &lt;&lt; endl; Base *pTest2 = new Derived(); //Base类的指针 pTest2-&gt;DoSomething(); delete pTest2; return 0; } // 输出结果 1 Do something in class Derived! 2 Output from the destructor of class Derived! 3 Output from the destructor of class Base! 4 5 Do something in class Derived! 6 Output from the destructor of class Base! 运算符重载 运算符重载的左侧的操作数是调用的对象。 所以对于成员方法的运算符重载，那么左侧的操作数是 this，并不是第一个参数。 类型转换 只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。 动态绑定和静态绑定 动态绑定就是程序在执行时才确定具体的操作，我认为动态绑定是动态存储区(heap)申请内存；静态绑定（即在编译时刻已经确定程序的大小）是在静态存储区存放大小。 在 C 中 malloc 实现动态存储区的申请。 在 C++ 中 new 实现动态存储区的申请。 静态绑定的执行效率优于动态绑定的执行效率。 虚函数表的存储空间在哪呢？ 我觉得是动态存储区，因为只有实例化对象时，虚函数表才能生成，并不是编译时刻就确定好。 智能指针 智能指针在结束对象的生存期，智能释放指针指向的存储空间，不会产生内存泄露问题。相对于普通指针，更加安全。 重载和重写 重写与重载： 方法的重写 Overriding 和重载 Overloading 是多态性的不同表现。 重写 Overriding 是父类与子类之间多态性的一种表现， 重载 Overloading 是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同 定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。 左值右值 左值和右值 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 对象的初始化， 和赋值不一样 A a = b; // 调用a的拷贝构造函数 A a; a = b; //调用操作符重载=函数, 类 带指针的类和不带指针的类 class with pointer member 必须有 拷贝构造 和拷贝赋值 &amp; 有不同意义， 取地址和声明参数引用。 对象类型： local objects （auto object）： Complex c2(); static objects：其生命在作用域结束后仍然存在，知道整个程序结束。 global objects heap objects using 编译指令： 在多函数程序中使用using编译指令，这是因为函数都使用了 cout， 因此需要能够访问位于命名空间std的 cout 定义 。 using namespace std； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素 namespace 和 Java 的 包类似 函数原型： 函数原型作为黑盒的函数 函数原型 prototype 成员函数： 成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。 static : static data 要 static 函数处理 static 成员函数 和 成员函数区别：没有 this pointer static 函数调用方式： object 调用 和 class name 调用 Inheritance 继承成员变量 继承成员函数的调用权 vitual pure vitual impure virtual non-virtual 为什么需要原型 原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。 如 double volume = cube（side）； 原型的功能 原型可以帮组编译器完成许多工作。 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:daihuiyou/Material.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;daihuiyou&quot; git config -global user.eamil &quot;daihuiyou.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
