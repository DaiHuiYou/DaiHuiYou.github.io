<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[暗时间]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[暗时间 善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。 如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。 能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？（思维方式） 能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。 因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。（学习习惯） 设计你自己的进度条 进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。 善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。前阵子流行的 GTD 方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。（懂得如何规划） 其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。（对兴趣的偏差） 饿死在干草堆之间的驴子（选择问题） 面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。 但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。 所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。 如何有效地记忆与学习 你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。 俗语有谋事在人，成事在天的说法。其实这话说的是，我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果。不要奢望你努力了就绝对会成功，你不会。更不要以这个理由来作为不去努力的原因，因为不去努力，那就永远不会成功。 生活中一抓一大把。俗语云“公说公有理，婆说婆有理。”你敢于表达自己的观点，他说你喜欢炫耀。你韬光养晦呢，他又说你夹着尾巴做人；你为自己的成就骄傲一下，他说你得意忘形。你低调做人呢，他又说你怎么这么没种；你说彪悍的人生不需要解释，他说你自大狂。你说做人贵有自知之明呢，他又说你丫做人怎恁费劲捏？… 有一个很不错的概念叫做“Unknown Unknown”，大意是如果你不知道一个东西的话，你也不会知道你自己不知道它。很多时候新知识就有这个特性——掌握了之后觉得很明白，掌握之前却觉得“不可能啊”、“这简直没有解嘛”。在这样的认知之下，你自然会高估前方的困难、风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为Unknown Unknown，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。 遇到问题寻找捷径为什么只是小聪明我们在遇到困难的时候会试图去寻找捷径，心里的想法大概是：既然我自己解决可能需要耗费极大的精力，甚至连最终能否解决都无法判断，那么为什么要冒风险花费大量的时间去尝试呢？还不如想想其他法子。比如绕过问题，或者将问题外包给别人。 这很聪明，很经济：用最小的代价解决手头的问题。看上去是一个寻求经济上最优解的法子。 为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。 为了解决一个内存泄漏的bug，你学习了一堆底层知识、了解了一堆调试工具、学习了若干wikipedia页面，表面上看来，仅仅为了解决这一个小bug你的时间花销未免太大了点，然而关键就在于，它的收益远远不止于解决了这一个小bug，下次你遇到任何类似的bug的时候就能够哐当两下就解决之了。 困难的路越走越容易，容易的路越走越难。]]></content>
      <categories>
        <category>share</category>
      </categories>
      <tags>
        <tag>share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高质量C/C++编程指南]]></title>
    <url>%2F2018%2F11%2F10%2F%E9%AB%98%E8%B4%A8%E9%87%8FC-C-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[文件结构 程序的版式 命名规则 表达式和基本语句 常量 函数设计 内存管理 c++函数的高级特性]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F11%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[抽象工厂模式 //抽象工厂模式， 生产一组产品 class Fruit { public: virtual void SayName() = 0; }; class AbstractFactory { public: virtual Fruit *CreateBanana() = 0; virtual Fruit *CreateApple() = 0; }; class NorthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north banana&quot; &lt;&lt; endl; } }; class NorthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s north apple&quot; &lt;&lt; endl; } }; class SouthBanana : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south Banana&quot; &lt;&lt; endl; } }; class SouthApple : public Fruit { public: virtual void SayName() { cout &lt;&lt; &quot;It&#39;s south apple&quot; &lt;&lt; endl; } }; class NorthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new NorthBanana(); } virtual Fruit *CreateApple() { return new NorthApple(); } }; class SouthFactory : public AbstractFactory { public: virtual Fruit *CreateBanana() { return new SouthBanana(); } virtual Fruit *CreateApple() { return new SouthApple(); } }; void main() { AbstractFactory *af = NULL; Fruit *fruit = NULL; af = new NorthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); af = new SouthFactory(); fruit = af-&gt;CreateApple(); fruit-&gt;SayName(); delete fruit; fruit = af-&gt;CreateBanana(); fruit-&gt;SayName(); system(&quot;pause&quot;); } 建造者模式class House { public: void setDoor(string door) { this-&gt;m_door = door; } void setWall(string wall) { this-&gt;m_wall = wall; } void setWindow(string window) { this-&gt;m_window = window; } string getDoor() { cout &lt;&lt; m_door &lt;&lt; endl; return m_door; } string getWall() { cout &lt;&lt; m_wall &lt;&lt; endl; return m_wall; } string getWindow() { cout &lt;&lt; m_window &lt;&lt; endl; return m_window; } private: string m_door; string m_wall; string m_window; }; class Builder { public: virtual void buildWall() = 0; virtual void buildDoor() = 0; virtual void buildWindow() = 0; virtual House* getHouse() = 0; }; class FlatBuilder : public Builder { public: FlatBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Flat door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Flat wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Flat window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class VillaBuilder : public Builder { public: VillaBuilder() { m_house = new House; } virtual void buildDoor() { m_house-&gt;setDoor(&quot;Villa door&quot;); } virtual void buildWall() { m_house-&gt;setWall(&quot;Villa wall&quot;); } virtual void buildWindow() { m_house-&gt;setWindow(&quot;Villa window&quot;); } virtual House *getHouse() { return m_house; } private: House *m_house; }; class Director { public: Director(Builder *build) { m_build = build; } void Construct() { m_build-&gt;buildWall(); m_build-&gt;buildWindow(); m_build-&gt;buildDoor(); } private: Builder *m_build; }; void main() { House *house = NULL; Builder *builder = NULL; Director *director = NULL; builder = new VillaBuilder(); //设计师 指挥 工程队 干活 director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); //返回房子 house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; //请 FlatBuilder 公寓 builder = new FlatBuilder; director = new Director(builder); director-&gt;Construct(); house = builder-&gt;getHouse(); house-&gt;getWindow(); house-&gt;getDoor(); delete house; delete builder; delete director; system(&quot;pause&quot;); return; }]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[歌曲改变人生]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%AD%8C%E6%9B%B2%E6%94%B9%E5%8F%98%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[因为一首歌， 才去看一部电影， 大概只有这部了。 当看到男主生活地越来越好，如电影所说，歌曲真的可以改变人生。女主，除了她美妙的声音，还留下印象是穿搭风格，想起来那时2013年所拍摄的，因为时间落差感，现在看起来这样的穿搭，更nice。 电影中的一群热爱音乐的人，他们因为歌曲而聚在一起，因创作歌曲的过程而彼此成为朋友。我觉的生活，就该如此，找到共同兴趣的人，愉快的玩耍，真好。 看完小感触，自己的兴趣是什么呢， 首先兴趣肯定是使一个人有学习的愉悦感，然后持续地练习，并得到自己和他人的赞赏，才叫做兴趣，至少我认为是这样。 想一想，或者唱歌，虽然我五音不全， 再或者英语，口语很差。现在我回答不了，我希望以后能够找到，并能回答。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[SQL基本概念数据库是一个以某种有组织的方式存储的数据集合. 表是一种结构化的文件, 可用来存储某种特定类型的数据. 表:某种特定类型数据的结构化清单． 模式：关于数据库和表的布局及特定的信息. 表由列组成. 列中存储着表中某部分的信息. 列: 表中的一个字段. 所有表都是由一个或多个列组成的. 数据库中每个列都有相应的数据类型.数据类型定义列可以存储的数据种类. 表中数据都是按行存储的, 所保存的每个记录存储在自己行内. 行：表中的一个记录. 记录和行互相代替. 主键：一列(或一组列), 其值能够唯一区分表中每个行. 唯一标识表中的每行的这个列称为主键. SQL: 是结构化查询语言的缩写. 客户机-服务器应用分为两个不同的部分, 服务器部分是负责所有数据访问和处理的一个软件. 这个软件运行在称为数据服务其的计算机上. 与数据文件打交道的只有服务器软件. 关于数据, 数据添加, 删除和数据更新的所有请求都由服务器软件完成.这些请求或更改来自运行客户机软件的计算机. 客户机是与用户打交道的软件. ​ 客户机和如软件可能安装在两台计算机或一个计算机上. 不管他们在不在相同的计算机上, 为进行所有数据库交互, 客户机软件都要与服务器软件进行通信. ​ 所有这些活动对用户都是透明的. 数据存储在别的地方, 或者数据库服务器为你完成这个处理这一事实是隐藏的. 你不需要直接访问数据文件. 事实上, 多数网络的建立使用户不具有对数据的访问权, 甚至不具有对存储数据的驱动去的驱动器的访问权. 服务器软件为MySQL DBMS. 你可以在本地安装的副本上运行, 也可以连接到运行在你具有访问权的远程服务期上的一个副本. 客户机可以是MySQL提供的工具, 脚本语言, web应用开发语言, 程序设计语言. 熟悉MySQL命令行实用程序, 数据库的基本概念： 列/字段/属性/数据项（column/field/attribute/data item） 行/元组/记录（row/tuple/record） 关系模式： 表名 +表标题（格式） 表／关系：表名＋表标题（格式）＋表内容（值） DataBase：相互之间有关联关系的Table的集合。 数据库： DB 数据库管理系统：DBMS 数据库应用：DBAP 数据库管理员：DBA DBMS提供了一套数据控制语言（DCL）给用户，DBA-&gt;DCL-&gt;DBMS 数据操作语言：DML，提供给用户，以便给用户对数据进行操作 数据控制语言：DCL，用户使用DCL；定义对不同操作的约束，对不同操作者的约束。 数据定义语言：DDL, 定义表名，表标题，列名其结构形式 SQL语言： DML, DCL, DDL， 结构化的数据库语言 数据库语言与高级语言的区别： ​ 一条数据库语言相当于高级语言的一个或多个循环程序。 数据模型——模式——数据 模式：外模式（子模式），概念模式（全局模式，逻辑模式），内模式（存储模式，物理模式） E-C映像 ， C-I映像 三级模式两层映像：实现了逻辑独立性和物理独立性， 数据和应用程序的独立性 数据模型： 关系模型 层次模型 网状模型 关系模型的三个要素： 基本结构 基本操作 完整性约束：实体完整性，参照完整性和用户自定义完整性 关系运算：关系代数和关系演算；关系演算：元组演算和域演算 关系代数：基于集合的运算，即操作的对象和结果都是集合，是一次一集合的操作。而非关系型的数据操作通常是一次一记录的操作 “列“的取值范围“称为 ”域（Domain）” 笛卡尔积的每个元素（d1, d2,…..)称为一个n-元组 元组的每个值叫做一个分量。 笛卡尔积中具有某一方面意义的那些元组被称作一个关系。 关系模式和关系：关系模式是关系的结构，关系是关系模式在某一时刻的数据。 关系是笛卡尔积的子集。 列名（属性名） 列值（来自域） 关系的特性： 列位置的互换性：区分哪一列是靠列名 行位置的互换性：区分哪一行是靠某一或某几列的值 关系是以内容来区的 属性不可再分特性：又被称为关系第一范式 关系的任意两个元组不能完全相同。 Table：可能有重复的元组存在。 关系和Table（表） 大部分相同。 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组总去掉任何一个属性，它就不具有这一性质了，这样的属性称作候选码。 当有多个候选码，可以选定一个作为主码。 DBMS以主码为主要线索管理关系中的各个元组。 主属性：包含在任何一个候选码的属性被称作主属性 外码/外键：两个关系通常是靠外码连接起来的。 关系模型中的完整性： 实体完整性：关系的主码的属性值不能为空 参照完整性：相对于外码 用户自定义完整性：用户针对具体的应用环境定义的完整性的约束条件。 关系代数基本操作：并相容性 并 差 广义笛卡尔积 选择操作 投影操作 关系代数的基本书写思路： 选出将用到的关系/表 做“积”运算 做悬着运算保留所需的行/元组 做投影运算保留所需的列/属性 扩张操作 交运算 连接操作：在乘积操作的基础上，在做一个选择操作。 更名操作 等值连接 自然连接 除运算 关系代数 和 关系演算 关系演算：元组演算和域演算 E-R关系图： 实体表示方框， 属性表示椭圆， 关系表示菱形。 抽象是理解，区分，命名，表达 实体， 属性，联系， 关键字（码） 属性：单一属性和复合属性 关键字/码，实体中能够用其值唯一区分每个实体的属性或属性组合。 参与发生联系的实体的数目，称为联系的度， 联系是多样化的。 实体在联系中的作用称为实体的角色 当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需要显示指明其角色。 实体之间的联系有很多种类。 完全参与联系 部分参与联系 不同层次的型与值 数据模型：概念 命令行]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维力]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%80%9D%E7%BB%B4%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[如何清楚的表达？ 思维力： 阅读摘抄思维力提升是当今时代的要求 知识积累方式变化下的必然要求 框架不仅仅体现了系统的构成元素，还体现了系统各构成元素的之间有机联系， 这种联系就是规律。 系统思维是用框架来系统思考与表达的思维方式。 系统反应了人们对事物的一种认识论： 系统是由两个或两个以上的元素结合而成的有机整体，而且系统的整体不等于其局部的简单相加–不仅要靠考虑系统的构成元素，更要考虑元素之间的联系。 系统思维就是以系统论为基本模式的思维形态， 它的客观一句是事物存在的普遍方式和属性。 框架是系统思维的核心组成部分。 以假设为前提，以事实为基础的工作方法。 世间万物的本质其实是系统，而框架就是对系统构成元素一级元素间有机联系的简化体现。因此人类大脑的在处理信息时本能地想将其组合为能够被认知的框架，以反应对事物的理解。 因此，系统思维在表达上应用的核心就是强调要采用自上而下表达的形式，第一时间传递容易认知的框架给受众，从而使受众更轻松，更有效接受你所传递的信息。 系统思维弥补经验上的不足，加速经验积累。 运用框架解决问题和加速经验的积累。 系统思维提高学习效率，加速知识积累。 我构建了个人的知识体系，我知道自己需要学习什么， 还缺少什么，因此每当我学习新的知识、经历新的事情时，我会不由自主的地了解的新的内容填充进我的知识框架里。随着我构建的知识体系越完整，越秘籍，就好像一张三维的渔网一样， 同一个姿势或同一段经历能够区填充的各自也就越来越多，知识积累的速度也就不停地加快。 麦肯锡结构化思维的内涵（定义）：分析问题的框架。 麦肯锡结构化思维的外延（应用范围）：框定假设的范围 明确问题的构成要素5 W 2 H 分析法， 又称 “七何”分析法 你可以在电话里运用框架跟他一次性确认所有关键要素。 Why What When Where Who How How much 其实很简单，这就是我要教给你的“探究问题本质”的第一种方法——5Why分析法。 5Why分析法的关键：鼓励解决问题的人努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。 因此，我们抛给别人的问题或需求，或别人抛给我们的问题或需要，往往都不是问题本身，而是问题的初步解决方案。 因此，我们在工作、生活和学习中需要多多提醒自己区分清楚问题初步解决方案和问题的本身。 在现实的工作、生活和学习中，很多时候对方提出的问题都是经过他们初步加工后的解决方案，而非真正的问题。将问题的初步解决方案与问题本身混为一谈是最容易犯的错误之一，也是大量时间和精力浪费的根源之一。你需要找到真正的问题，而不是惯性地将初步解决方案当做问题本身来应对。 隐含时间的假设广泛存在于我们的工作、生活和学习中，我相信你听过很多隐含时间假设的论断，也可能因未能显性化问题隐含的时间假设而错过了不少机会。例如，领导给你布置一个相当有挑战性的任务时，你的第一反应是“这个工作需要很强的沟通能力，我的沟通能力不行，因此我不能接这个任务”，还是“这个工作需要很强的沟通能力，目前我的沟通能力不行，正好可以借这个任务锻炼提升”呢？若是前者，你不仅辜负了领导的信任，还丧失了一次提升沟通能力的机会。而后者既可以提升沟通能力，又能够得到领导的青睐，即使任务没圆满完成，你的沟通能力的提升也绝对比你不接受这个任务要高得多 逻辑树是我们运用系统思维分析和解决问题的主要工具逻辑树是一种非常有效的问题/议题分解的方法，其价值主要有以下三点：​ 1.对问题/议题/假设层层有序分解，有助于理清思路，不做重复和无效的思考；​ 2.可有效分解复杂问题/议题，从而简化问题/议题的处理；​ 3.通过将问题/议题分解为更细的问题/议题，有助于团队的协作和分工 80/20法则的作用一个人的时间和精力都是非常有限的，“做好每一件事”几乎不可能，因此必须学会合理分配的时间和精力。面面俱到不如重点突破，把80%的资源花在能出关键效应的20%的方面上，这20%的方面又能带动其余80%的发展。 自上而下的表达三点式表示]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C笔记]]></title>
    <url>%2F2018%2F11%2F01%2FC%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[#include &lt;stdlib.h&gt; #include &lt;string.h&gt; //sizeof(s) 是计算指针的大小， 大小为4 //sizeof(a) 是计算字符串的大小，包括\0 //strlen(a) 是计算字符串的大小，不包括\0 //常用字符串复制 //char *dst = (char *)malloc(strlen(str) + 1); //strcpy(dst, str); void main(int args, char const *argv[]) { char * s = &quot;aaaaaa&quot;; char a[] = &quot;aaaaaa&quot;; printf(&quot;%d\r\n&quot;, sizeof(a)); printf(&quot;%d\r\n&quot;, sizeof(s)); printf(&quot;%d\r\n&quot;, strlen(s)); printf(&quot;%d\r\n&quot;, strlen(a)); //7 //4 //6 //6 //请按任意键继续. . . system(&quot;pause&quot;); } c的封装 链表的删除 ： 删除链表其中一个结点 链表的清除： 删除链表所有的结点。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java笔记]]></title>
    <url>%2F2018%2F10%2F22%2FJava%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[== 与 equals== : 它的作用判断两个对象的地址是否相等, 判断基本数据类型的值是否相等. equals: String 中的 equals() 方法是被重写的, 因为 Object 的 equals 方法是比较对象的内存地址.而 String 的 equals 方法是比较对象的值. 线程, 程序, 进程的基本概念和他们之间关系1. 线程和进程相似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 与线程不同的是同类的多个线程共享同一个内存空间和一组系统资源, 所以系统产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因如此, 线程也被称称为轻量级进程. 2. 程序是含有指令和数据的文件, 被存储在磁盘或者其他的数据存储设备中, 也就是说程序是静态的代码. 3. 进程是程序一次运行过程, 是系统运行的基本单位, 因为进程是动态. 系统运行一个程序即是一个进程从创建, 运行到消亡的过程.简单来说, 一个进程就是一个执行中的程序, 它在计算机中的一个指令接着一个指令的执行, 同时, 每个进程还占某些系统资源如CPU时间, 内存空间, 文件, 输入输出设备的使用权等等. 4. 换句话说, 当程序在执行时, 将会被操作系统载入内存中, 线程是进程划分成的更小的运行单位. 线程和进程最大不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响. 从另一角度出发, 进程属于操作系统的范畴, 主要是同一段时间内, 可以同时执行一个以上的程序, 而线程则是在同一个程序内几乎同时执行一个以上的程序段. 线程的基本状态和基本状态的定义 新建（new): 新创建了一个线程对象. 可运行(runnable):线程对象创建后, 其他线程(比如main线程)调用了该对象的 start() 方法. 该状态的线程位于可运行线程池中, 等待被线程调度选中, 获取CPU的使用权. 运行(running): 可运行(runnable)的线程获得了 CPU 时间片(time slice), 执行程序代码. 阻塞(block): 阻塞状态是指线程因为某种原因放了CPU的使用权, 也即让出了 CPU time slice. 暂时停止运行. 直到线程进入可运行的状态, 才有机会再次获得 CPU time slice 转到运行状态. 阻塞的情况分三种: 等待阻塞 同步阻塞 其他阻塞 死亡: 线程 run(), main()方法执行结束后, 或者因异常退出了run()方法, 则该线程接受了生命周期. 死亡的线程不可再次复生. 在 Java 中定义一个不做事且没有参数的构造方法的作用 Java 程序在执行子类的构造方法之前, 如果没有用super()来调用父类特定的构造方法, 则会调用父类中没有参数的构造方法. 因此父类中只定义了有参数的构造方法, 而在子类的构造方法中又没有的super()来调用父类中特定的构造方法, 则编译时将方法错误, 因为 Java 程序在父类中找不到没有参数的构造方法可执行. 解决方法是咋父类里加上一个不做事且没有参数的构造方法. Java 和 C++的区别都是面向对象的语言， 都支持封装，继承和多态 Java 不提供指针来直接内存，程序内存更加安全 Java 的类是单继承的， C++支持多继承； 虽然 Java 的类不可以多继承， 但是接口可以多继承 Java 有自动内存管理机制， 不需要程序员手动释放无用内存 接口和抽象类的区别： 接口的方法默认是 public， 所有方法在接口中不能有实现，抽象类可有非抽象的方法 接口中实例变量默认是 final 类型， 而抽象类中则不一定 一个类可以实现多个接口， 但最多只能实现一个抽象类 一个类实现接口的话， 要实现接口的所有方法， 而抽象类不一定。 接口不能用 new 实例化， 但可以声明， 必须应用一个实现该接口的的对象 从设计层面来说， 抽象是对类的抽象，是一种模板设计； 接口是行为的抽象， 是一种行为的规范。 静态方法和实例方法 在外部调用静态方法，可以使用“类名.方法名”的方式， 也可以使用“对象.方法名”的方式。 而实例方法只有后面这种方式。 也就是说， 调用静态方法可不需要创建对象。 静态方法在访问本类的成员时， 只允许访问静态成员（即静态成员变量和静态方法）， 而不允许访问实例成员变量和实例方法； 实例方法则无此限制。 对象的相等与指向他们的引用相等，两者有什么不同？对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作。 注释和注解的区别Java中的注释和其他编程语言一样，注释的内容不会被编译运行，知识源代码中对代码的解释说明， 提高源代码的可读性。 Java中的注解（Annotation），也叫元数据，是Java 5以后版本引入的一个特性 注解与类、接口、枚举是在同一个层次，可以用来标注包、类、字段、方法、局部变量、方法参数等元素，达到对这些元素的面数和说明。 注解是可以允许 jvm 在运行中读取它，这一点与注释完全不同。 注解作用： 编写文档， 代码分析， 编译检查]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[for循环常用写法date: 2018-09-27 11:03:38 插入元素: 删除元素: void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 循序栈和链式栈date: 2018-09-25 15:54:15 stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 线性表顺序存储和链式存储date: 2018-09-23 19:46:15 单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 基本概念date: 2018-09-22 14:22:10 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 ​ //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 二叉树表示算数表达式： 先序遍历： 前缀表示法 中序遍历： 中缀表示法 后序遍历： 后缀表示法 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++]]></title>
    <url>%2F2018%2F10%2F11%2FC%2B%2B%2F</url>
    <content type="text"><![CDATA[匿名对象date: 2018-09-20 17:15:00 匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。 class AA { public: AA() { cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl; } ~AA() { cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl; } }; void main() { //AA a = AA(); //产生一个匿名对象， 有一个变量去接，不会调用析构函数。 AA b; //调用拷贝构造函数。 b = AA(); //匿名对象， 会调用拷贝构造函数和析构函数。 //func(); system(&quot;pause&quot;); } 异常date: 2018-09-21 14:28:22 抛出异常是跨函数的。 c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。 栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。 异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。 void func() thorw(A, B, C, D) { } 知识点date: 2018-09-20 21:51:18 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 字符串常量/字面量 拷贝构造函数：是一种特殊的构造函数，他在构建对象时， 是使用同一类中之前创建的对象来初始化新创建的对象。 迭代器： 是一种检查容器内元素并遍历元素的数据类型，可以代替下标访问vector对象的元素。迭代器是便利容器的同一方法。 容器： 任何数据类型都能存储。 引用引用分为普通引用和常引用 //常引用 //常引用当函数参数 ,可以传字面量或者实参 void func1(const int&amp; num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } //普通引用当函数参数， 传实参 void func2(int &amp;num) { cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl; } void main() { int a = 10; int c = a; //引用当右值， 把变量的值赋值给变量 int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。 cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl; cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl; //字面量常引用 const int&amp; tmp = 123; //分配内存 cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl; cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl; //普通引用 //int&amp; var = 123; //不自动分配内存， 编译错误 int var = 123; func1(123); //可以传进字面量 func1(var); //可以传进变量 func2(var); //只能传进变量. cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 常量必须初始化 重载和重写date: 2018-09-20 08:28:05 重写与重载： 方法的重写Overriding和重载Overloading是多态性的不同表现。 重写Overriding是父类与子类之间多态性的一种表现， 重载Overloading是一个类中多态性的一种表现。 如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。 子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同； 如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同 定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。 左值右值date: 2018-09-19 21:34:18 左值和右值 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。 对象的初始化， 和赋值不一样 A a = b; // 调用a的拷贝构造函数 A a; a = b; //调用操作符重载=函数, 类模板date: 2018-09-19 15:41:31 #include &quot;iostream&quot;//类模板的本质， 两次编译 using namespace std; template &lt;typename T&gt; class Teacher { public : static T a; private: }; template &lt;typename T&gt; T Teacher&lt;T&gt;::a = 0; void main() { Teacher&lt;int&gt; t1; t1.a = 10; t1.a++; t1.a++; Teacher&lt;char&gt; t2; t2.a = &#39;a&#39;; t2.a++; t2.a++; cout &lt;&lt; t2.a &lt;&lt; endl; //两个静态变量， 不一样， 属于不同内存空间 cout &lt;&lt; t1.a &lt;&lt; endl;//类模板机制的本质， 两次编译 cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 线性链表date: 2018-09-18 17:29:04 泛型编程date: 2018-09-17 22:11:16 指针作引用date: 2018-09-11 20:17:36 结构体作函数参数date: 2018-09-11 14:49:20 //结构体作函数参数 struct Teacher { char name[60]; int age; }; void printTeacher1(Teacher t1) { cout &lt;&lt; t1.age &lt;&lt; endl; } void printTeacher2(Teacher &amp;t2) { t2.age = 20; cout &lt;&lt;t2.age&lt;&lt; endl; } void printTeacher3(Teacher *t3) { t3-&gt;age = 30; cout &lt;&lt; t3-&gt;age &lt;&lt; endl; } void main() { Teacher t1; t1.age =10; printTeacher1(t1); printTeacher2(t1); //引用方式，结构体作函数参数 printTeacher3(&amp;t1); //作用与指针间接赋值一样。 system(&quot;pause&quot;); return; } Type &amp;name = var;//等效于C语言 Type *const name = var; 引用作函数参数， 当左值和右值。 当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址而已 引用就是给内存取多个门牌号（多个别名） 运算符date: 2018-09-11 07:21:16 //struct 和 class完成的功能一样 //布尔类型 bool类型 //关于左值（必须是一个变量，即有内存空间） //111 = 33；（111不能当左值， 不是一个变量，没有内存空间） //三目运算符， C返回是一个数（不能当左值）， C++返回是一个变量（能当左值） void main() { bool b1, b2, b3; b1 = 10; b2 = -10; b3 = 0; cout &lt;&lt; &quot;sizeof(bool)&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl; cout &lt;&lt; b1 &lt;&lt; endl; cout &lt;&lt; b2 &lt;&lt; endl; cout &lt;&lt; b3 &lt;&lt; endl; system(&quot;pause&quot;); return; } //结果显示： //sizeof(bool)1 //1 //1 //0 //请按任意键继续. . . const 和 #define 相同之处 #define 是单纯的文本替换， 作用域具有全局性 #undef 限制作用域 引用的基本用法 C++的引用: 已定义变量再起个别名 Type&amp; name = var; //引用作函数参数: 与指针类似 void myswap1 (int a, int b) //不能间接赋值 { int c = 0; c = a; a = b; b = c; } void myswap2(int *a, int *b) //指针做函数参数， 实现间接赋值。 { int c = 0; c = *b; *b = *a; *a = c; } void myswap3(int &amp;a, int &amp;b) //引用做函数参数， 实现间接赋值。 { int c = 0; c = a; a = b; b = c; } void main() { int a = 10; int b = 20; myswap1(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; myswap2(&amp;a, &amp;b); printf(&quot;a = %d, b = %d\n&quot;, a, b); myswap3(a, b); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; system(&quot;pause&quot;); return; } /*结果显示: 10 20 a = 20, b = 10 10 20 请按任意键继续. . . */ 函数返回值当左值右值 int&amp; func(void) { int a = 10; return a; } void main() { int a = func(); //将栈变量的值赋值给a. int &amp;b = func(); //传递栈变量的地址 cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; endl; //显示乱码 system(&quot;pause&quot;); } 类date: 2018-09-10 17:49:28 #include &quot;iostream&quot; using namspace std; void main() { cout&lt;&lt;&quot;hello.\n&quot;&lt;&lt;endl; system(&quot;pause&quot;): retun; } //endl 相当于 \n 类是一种数据类型， 是固定大小内存块的别名 定义一个类，是一个抽象的概念， 不会分配内存 using namespace std; C中的命名空间，只有一个全局作用域。C语言中所有的全局标识符共享一个作用域。 命名空间 C++中提出了命名空间的概念： 不同命名空间中的标识符可以同名而不会发生冲突 命名空间可以相互嵌套 全局作用域也叫默认命名空间。 namespace namespaceA { int age = 10; } namespace namespaceB { int age = 20; namespace namespaceC { struct Teacher { int age; }; } } void main() { cout &lt;&lt; &quot;hell.&quot; &lt;&lt; endl; using namespace namespaceA; using namespace namespaceB; cout &lt;&lt; namespaceA::age&lt;&lt;endl; cout &lt;&lt; namespaceB::age&lt;&lt;endl; using namespaceB::namespaceC::Teacher ; //注意事项， 缺少namespace Teacher t1; t1.age = 30; cout &lt;&lt; t1.age &lt;&lt;endl; system(&quot;pause&quot;); return; } ​]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java]]></title>
    <url>%2F2018%2F10%2F10%2FJava%2F</url>
    <content type="text"><![CDATA[java中类名第一个字母都是大写的. 常量分类: 字符型常量: “HelloWorld” 整形常量: 12 小数常量: 0.21 布尔常量: true 空常量: null 数据类型分类: 基本数据类型 注意: 整数默认是int 类型, 浮点数默认是double类型 定义long类型数据的时候, 要加L或者l 定义float类型数据的时候, 要加F或者f 引用数据类型(类, 接口, 数组) 标识符 标识符常见命名规则: 包(就是文件夹, 用于对类进行管理) 全部小写, 举例：com, com.itheima 类 一个单词的首字母大写 多个单词每个单词的首字符大写 方法和变量 一个单词首字母小写 多个单词组成, 从第二个单词开始每个单词的首字母大写. 变量定义和注意事项 变量未赋值, 不能直接使用 变量只在它所属的范围内有效,变量属于它所在的那对大括号 一行上可以定义多个变量, 但是不建议 类型转换 隐式转换 byte, short, char – int –long – float – double 从小变大 强制转换 目标类型 变量名 = (目标类型) (被转换的数据); 建议: 数据作运算，结果应该是什么类型，就用什么类型接受，不要随意转换类型，否则会有精度的损失． 字符串参与加法运算public class OperatorDemo01 { public static void main(String[] args) { int a = 10; int b = 20; System.out.println(a + b + &quot;hello wolrd.&quot;); System.out.println(&quot;hello wolrd&quot; + a + b); System.out.println(&quot;hello world&quot; + a); } } 赋值运算符 注意:扩展的赋值运算符，隐含了强制类型转换． short s = 1; s += 1; //s = (short)(s+1); System.out.println(s); 逻辑运算符 &amp; 和 &amp;&amp;的区别: 相同点: &amp;&amp; 和 &amp; 的结果一样, || 和 | 的结果一样 不同点: &amp; 左边无论是什么, 右边都会执行. &amp;&amp;有短路效果, 左边为FALSE,右边都不执行. 键盘录入 Scanner 导入包中类 : import java.util.Scanner; //快捷键(推荐) Ctrl + shift + o 分配内存，定义对象 Scanner sc = new Sanner(System.in); 产生随机数Random r = new Random(); //产生随机数 for(int i=0; i&lt;10; i++) { int ret = r.nextInt(10); //随机数的范围为[0, 10), 包括0, 不包括10; System.out.println(ret); } int ret = r.nextInit(100) + 1; // 随机数的范围:[1, 100]; Java 中的内存分配 Java 程序在运行时, 需要在内存中分配空间. 为了提高运算效率, 就对空间进行了不同区域的划分, 因为每一片区域都有特定的处理数据方式和内存管理方式. 栈 存储局部变量 堆 存储new出来的东西 方法区(面向对象进阶讲) 本地方法区(和系统相关） 寄存器（给 cpu 使用)- 数组的动态初始化和静态初始化 //动态初始化 int [] myArray = new int[3]; //静态初始化 int [] myArray2 = new int[] {1,2,3}; //简化格式:int[] myArray2 = {1,2,3}; 引用类型: 类, 接口, 数组 输出内容System.out.println(); //输出内容并换行 System.out.print(); //只输出内容,不换行. 方法的形参 基本数据类型: 形参的改变 不影响 实际参数． 引用数据类型: 形参的改变直接 影响 实际参数． 一个对象的内存图 方法共用的内存图 成员变量和局部变量的区别 在类中的位置不同 成员变量： 类中，方法外． 局部变量： 方法中或者方法声明中（形式参数） 在内存中的位置不同 成员变量：在堆内存分配 局部变量: 在栈内存分配 生命周期不同 成员变量随着对象的创建而存在，随着对象的消失而消失 局部变量随着方法的调用而存在，随着方法的调用完成而消失． 初始化值的问题 成员变量有默认值 局部变量没有默认值，必须先定义，赋值，才可以使用． 类名作形式参数和返回值String类 /* * 通过构造方法创建字符串对象和直接赋值方式创建字符串对象的区别 * 通过构造方法创建字符串对象在堆内. * 直接赋值方式创建对象在方法区的常量池. * * ==: * 基本数据类型:：比较是基本数据类型的值是否相等 * 引用数据类型: 比较是引用数据类型的地址值是否相等. * */ public class StringDemo { public static void main(String[] args) { String s1 = new String(&quot;Hello&quot;); System.out.println(&quot;s1 &quot; + s1); System.out.println(&quot;----------&quot;); String s2 = &quot;Hello&quot;; System.out.println(&quot;s2 &quot; + s2); System.out.println(&quot;----------&quot;); System.out.println(&quot;s1 == s2 : &quot; + (s1==s2)); String s3 = &quot;Hello&quot;; System.out.println(&quot;s3 == s2: &quot; + (s3 == s2)); } } 内存图: String类的判断功能 Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. /* * Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 * 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. * String类的判断功能: * boolean equals(Object obj); 比较字符串的内容是否相同 * boolean equalsIgnoreCase(String str); 比价字符串的内容是否相同, 忽略大小写 * boolean startsWith(String str); 比较字符创对象是否以指定的str开始. * boolean endsWith(String str); 比较字符创对象是否以指定的str结尾. * * */ public class StringDemo { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;hello&quot;; String s3 = &quot;Hello&quot;; System.out.println(&quot;s1 == s2 :&quot; + s1.equals(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equals(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.equalsIgnoreCase(s2)); System.out.println(&quot;s1 == s3 :&quot; + s1.equalsIgnoreCase(s3)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.startsWith(&quot;he&quot;)); System.out.println(&quot;-------------&quot;); System.out.println(&quot;s1 == s2 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;s1 == s3 :&quot; + s1.endsWith(&quot;llo&quot;)); System.out.println(&quot;-------------&quot;); } String类的获取功能 /* * String类的获取功能 * int length():获取字符串长度, 其他也就是字符个数. * char charAt(int index); 获取指定索引处的字符 * int indexOf(String str); 获取str在字符串对象中第一次出现的索引 * String substring(int start); 从start开始截取字符串 * String substring(int start, int end); 从start到end之间截取字符串, 包括start, 不包括end * * */ public class StringDemo { public static void main(String[] args) { String s = &quot;helloworld&quot;; System.out.println(s.length()); System.out.println(&quot;-----------&quot;); System.out.println(s.charAt(0)); System.out.println(s.charAt(1)); System.out.println(&quot;-----------&quot;); System.out.println(s.indexOf(&quot;ell&quot;));//获取str在字符串对象中第一次出现的索引 System.out.println(&quot;------------&quot;); System.out.println(s.substring(5)); System.out.println(&quot;------------&quot;); System.out.println(s.substring(0, 5));//从start到end之间截取字符串, 包括start, 不包括end } } String类的转换功能 /* char[] toCharArray(): 把字符串转换为字符数组 String toLowerCase(): 把字符串转换为小写字符串 String toUpperCase(): 把字符串转换为大写字符串 */ String类的其空格和分割功能 /* String trim(): 去除字符串两端的空格 String[] spilt(String str): 按照指定符号分割字符串,注意返回的是字符数组 */ public class StringDemo { public static void main(String[] args) { String s = &quot; aa,bb,cc&quot;; String tmpStr = s.trim(); //去除字符串两端的空格, 不包括中间空格 System.out.println(tmpStr); System.out.println(&quot;---------&quot;); String[] strArray = tmpStr.split(&quot;,&quot;);//返回值是字符串数组. for(int i=0; i&lt;strArray.length; i++) { System.out.println(strArray[i]); } } } StringBulder类 作用: 如果对字符串进行拼接操作，每次拼接，都会构建新的String的字符串对象, 即耗时,又浪费空间.而StringBuilder 可以解决这个问题. 内存分配示意图: 常用方法: /* * StringBuilder: 是一个可变的字符串. 字符串数组缓冲类 * * String 和 StringBuilder的区别 * String: 是内容是固定的. * StringBilder: 是内容可变的 * * StringBuilder的常用方法: * public String append(任意类型); * public String reverse(String str); */ public class StringDemo { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); System.out.println(&quot;容量为:&quot; + sb.capacity()); System.out.println(&quot;长度为: &quot; + sb.length()); StringBuilder sb2 = sb.append(&quot;hello&quot;); //返回本身对象的地址 System.out.println(sb); System.out.println(sb2); System.out.println(sb == sb2); //链式编程 sb.append(123).append(123).append(123); System.out.println(sb); System.out.println(&quot;------------&quot;); //public String reverse(String str) sb.reverse(); System.out.println(sb); } } String 和 StringBuilder 相互转换. /* String 和 StringBuilder的相互转换 StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;String public String toString(); 通过toString()就可以实现把StringBuilder转换成String String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;StringBuilder StringBuilder(String str); 通过构造方法, 将String转换成StringBuilder */ public class StringDemo { public static void main(String[] args) { //StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String StringBuilder sb = new StringBuilder(); sb.append(&quot;hello&quot;); String s = sb.toString(); System.out.println(s); //String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; StringBuilder String ss = &quot;hello&quot;; StringBuilder sb2 = new StringBuilder(ss); System.out.println(sb2); } } 自动生成方法/* * * 快速自动生成构造方法 Set() 和 Get()方法. * 右键: source * Generate Constructor from Superclass 无参构造方法 * Generate Constructor using Fields 有参构造方法 * Generate constructor Getter and Setters .. */ public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { super(); this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 对象数组内存图 集合类 集合类的特点: 长度可变 ArrayLIst 集合的增加 删除 修改 查找的方法 /* * * 获取元素 * public E get (int index): 返回指定索引处的元素 * 集合长度 * public int size():返回集合元素的个数 * 删除元素 * public boolean remove(Object o): 删除指定元素, 返回删除是否成功 * 修改元素 * public E set(int index, E, element):修改指定索引处的元素, 返回被修改的元素 */ public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); System.out.println(arr); System.out.println(arr.size()); System.out.println(arr.remove(&quot;hello&quot;)); System.out.println(arr.set(1, &quot;android&quot;)); System.out.println(arr); } } ArrayList 集合的遍历 //集合的遍历 public class ObjectDemo { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;hello&quot;); arr.add(&quot;world&quot;); arr.add(&quot;Java&quot;); //标准的遍历操作 for(int x=0; x&lt;arr.size(); x++) { String s = arr.get(x); System.out.println(s); } } } IO流从程序角度出发: 输入流, 文件读数据. 输出流 文件写数据 输出流 import java.io.FileWriter; import java.io.IOException; /* * * 相对路径: 相对于当前项目的路径 * 绝对路径：系统盘符 * flush() 和 close()的方法的区别: * flush(): 刷新缓存区. 流对象还可以继续使用 * close(): 先刷新缓冲区, 然后通知系统释放资源. 流对象不可以再被使用. */ public class FileDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;a.txt&quot;); fw.write(&quot;IO流&quot;); fw.flush(); fw.close(); } } 数据换行: /* * 如何实现数据的换行 * \n 可以实现换行, 但是Windows系统自带的记事本打开并没有换行. * Windows识别的换行符不是 &quot;\n&quot;, 而是&quot;\r\n&quot; * 常见的操作系统识别的换行符: * windows:\r\n * linux: \n * mac: \r * * 如何实现文本的追加 * FileWriter fw = new FileWriter(String fileName, boolean append); */ public class FileWirterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(&quot;b.txt&quot;, true); //实现的文本的追加 for(int x=0; x&lt;10; x++) { fw.write(&quot;hello&quot;+x); fw.write(&quot;\r\n&quot;); } fw.close(); } } 输入流public class fileDemo{ public static void main(String[] args) throws IOException { FileReader fr = new FileReader(&quot;fr.txt&quot;); int ch = 0; //输入流 标准操作, 读到末尾时候值为-1 while((ch=fr.read())!=-1) { System.out.print((char)ch); } } } 高效的IO流BufferedReader类 BufferedWriter类 public class fileDemo{ public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new FileReader(&quot;fr.txt&quot;); String line; while((line=br.readline())!=null) { System.out.print((line); } } } static 的作用 一个JAVA源文件只能包含一个public类的 /* * static 的特点: * 被所有的对象所共享 * 可以使用类名调用 * 静态的加载优先于对象 * 随着类的加载而加载, 加载到方法区中 * 总结: static修饰的成员变量和成员方法不属于的所有对象. * */ public class StaticDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Person.school = &quot;wyu&quot;; //静态的加载优先与对象, 随着类的加载而加载 //static赋值, 可以使用类名调用, 无需实例化对象. Person p = new Person(&quot;xiaoming&quot;, &quot;21&quot;); } } class Person{ private String age; private String name; static String school; public Person() { } public Person(String age, String name) { super(); this.age = age; this.name = name; } public void printIf() { System.out.println(name+ &quot; &quot; + age+&quot; &quot;+ school); } } 注意事项: /* * static的注意事项: * 静态方法: * 可以调用静态成员变量和成员方法 * 不可以调用非静态成员方法和非静态成员变量 * 非静态的方法: * 全部都可以调用 * 静态的方法不含有this对象. */ public class StaticDemo_01 { public static void main(String[] args) { Student.school = &quot;s&quot;; Student.sleep(); //方法区中 } } class Student{ public String name; static public String school; public void print() { System.out.println(name + school); } static void sleep() { System.out.println(&quot;slepp&quot;); } } static的应用场景: ​ 工具类: Math类的应用, 其方法中全部被static修饰 自定义工具类package myStatic; //自定义工具类的使用 public class StaticDemo_02 { public static void main(String[] args) { int[] arr = {10, 3, 2, 4, 6}; int max = myArray.max(arr); System.out.println(max); } } ----------------------------------------------------------------------------------- package myStatic; //自定义一个工具类 public class myArray { //用 private修饰构造方法, 使class不可以实例化对象 private myArray() { } static int max(int[] arr) { int max = 0; for(int x=0; x&lt;arr.length; x++) { if(max &lt; arr[x]) { max = arr[x]; } } return max; } } 代码块局部代码块 构造代码块 和 静态代码块 代码块的执行顺序: /* * 代码块块的调用顺序: * BlockTest 静态代码块 &gt;&gt;&gt; BlockTest 的主函数调用了 &gt;&gt;&gt; * Phone 静态代码块 &gt;&gt;&gt;Phone 构造代码块 &gt;&gt;&gt;Phone 调用无参构造 * Phone 构造代码块&gt;&gt;&gt;Phone 调用有参构造 */ public class BlockTestDemo { { System.out.println(&quot;BlockTest 构造代码块&quot;); } static { System.out.println(&quot;BlockTest 静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;BlockTest 的主函数调用了&quot;); Phone p = new Phone(); Phone p1 = new Phone(); } } class Phone { private String name; private String prices; { System.out.println(&quot;Phone 构造代码块&quot;); } static { System.out.println(&quot;Phone 静态代码块&quot;);//随着类的加载而加载 } public Phone() { System.out.println(&quot;Phone 调用无参构造&quot;); } public Phone(String name, String prices) { System.out.println(&quot;Phone 调用有参构造&quot;); this.name = name; this.prices = prices; } // 结果显示: // BlockTest 静态代码块 // BlockTest 的主函数调用了 // Phone 静态代码块 // Phone 构造代码块 // Phone 调用无参构造 // Phone 构造代码块 // Phone 调用无参构造 } 继承/* * 继承: 多个类有共同的成员变量和方法, 抽取到另外一个类中(父类), * 再让多个类去继承这个父类, 我们就可以获取得到父类的成员了. */ public class ExtendsDemo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Dota d = new Dota(); d.sart(); LOL l = new LOL(); l.sart(); } } //抽取多个类的共性, 得到父类 class Game { String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); } } class Dota extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } class LOL extends Game{ /* String agend; double version; public void sart() { System.out.println(&quot;游戏开始了&quot;); } public void end() { System.out.println(&quot;游戏关闭了&quot;); }*/ } 继承中的成员变量的特点 /* * super: 可以获取父类的成员变量和成员方法, 用法和this相同. */ public class ExtendsDemo_01 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Child c = new Child(); c.show(); } } class Dad { String name = &quot;张三&quot;; } class Child extends Dad{ String name = &quot;张四&quot;; void show() { String name = &quot;张五&quot;; System.out.println(super.name); //调用父类的成员变量 System.out.println(this.name); //调用成员变量 System.out.println(name);// 就近原则:谁离我近就用谁 } } 继承中成员方法的特点 重写和重载的区别 继承中的构造方法的执行顺序 /* * 继承中构造方法的执行循序 * 在有子类继承关系的类中, 创建子类对象, 调用子类的构造方法, * 如果子类构造方法的第一行代码没有调用父类的构造方法, 则会默认的调用父类的无参构造. * 可以使用super()在子类构造方法的第一行中调用父类的构造方法 * 总结: * 始终都要调用父类的构造函数 */ public class ExtedndsDemo { public static void main(String[] args) { Child c = new Child(); } } //运行结果: //调用 父类无参构造 //调用 子类有参构造 //调用 子类无参构造 class Dad { public Dad() { System.out.println(&quot;调用 父类无参构造&quot;); } public Dad(int num) { System.out.println(&quot;调用 父类有参构造方法&quot;); } } class Child extends Dad{ public Child() { this(2); //调用子类的有参构造 System.out.println(&quot;调用 子类无参构造&quot;); } public Child(int num) { //调用父类无参构造 System.out.println(&quot;调用 子类有参构造&quot;); } } 继承的优缺点 ​ 优点: 提高了代码的复用性, 代码的可维护性 ​ 缺点:类的耦合性增强了， ​ 开发原则：高内聚低耦合 ​ 内聚：就是自己完成某件事情的能力. ​ 耦合：类与类的关系 抽象类​ /* * abstract 抽象类 * 抽象类不能实例化 * 抽象类有构造函数 * @Override * 在子类继承抽象类中, 需要重写抽象类的方法 */ public class abstractDemo { public static void main(String[] args) { Cat c = new Cat(&quot;Ruby&quot;, 10); c.eat(); c.run(); Dog d = new Dog(&quot;Bruces&quot;, 7); d.eat(); d.run(); } } abstract class Animals { String name; int age; public Animals(String name, int age) { this.name = name; this.age = age; } public abstract void eat(); //提供接口的功能 public void run() { System.out.println(&quot;run&quot;); } } class Cat extends Animals { public Cat(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The cat eats fishing.&quot;); } } class Dog extends Animals { public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(&quot;The dog eats food.&quot;); } } 接口/* * Java语言是继承是单一继承, 一个子类只能有一个父类(一个儿子只能有一个亲爹) * Java语言给我们提供了一种机制,用于处理继承单一的局限性, 接口 * * 接口: 接口是一个比抽象类还抽象的类, 接口里所有方法全是抽象方法, 接口和类的关系是implements(实现) * interface * * 接口成员特点: * 只有抽象方法 * 只能有常量 * 默认和只能使用public abstract 修饰方法 * 默认使用 public static final 修饰变量 * 注意: * 接口不能创建对象(不能实例化) * 类与接口的关系是实现关系, 一个类的实现一个接口, 必须实现它所有的方法. * * 类与类: 继承关系, 单一继承, 多层继承 * 类与接口: 实现关系, 多实现 * 接口与接口的关系: 继承关系, 多层继承 */ public class interfaceDemo { public static void main(String[] args) { Tiger t = new Tiger(); t.eat(); Demo d = new Demo(); d.function(); d.method(); } } interface Animals { public static final int age = 10; public abstract void eat(); } class Tiger implements Animals { @Override public void eat() { System.out.println(&quot;eat&quot;); } } //接口与接口的关系是单一继承 interface interA { public abstract void method(); } interface interB extends interA{ public abstract void function(); } //类与接口是实现关系, 多实现 //每个接口都需要一个实现类, Demo是interA, interB的实现类 class Demo implements interA, interB { @Override public void function() { } @Override public void method() { } } 接口的优点: ​ 打破了继承的局限性， ​ 对外提供规则 ​ 降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发效率． 分析问题： ​ 分析: 由下至上, 不断向上抽取的过程 ​ 实现: 由上至下, 先实现共性 ​ 使用: 使用具体的子类. ​ /* 抽象类可以继承普通类 */ class Person { String name; int age; public void sleep() { System.out.println(&quot;sleep&quot;); } public void eat() { System.out.println(&quot;eat&quot;); } } abstract class Player extends Person{ public abstract void study(); } 匿名对象匿名对象: 没有名字的对象 应用场景： ​ 当方法只调用一次的时候, 可使用匿名对象 ​ 可以当作参数进行传递 //普通创建对象 Student st = new Student(); //匿名对象 new Student() //匿名对象可以当作参数 function (new Studnet); final​ 自定义常量必须初始化, 可以选择显示初始化或者构造初始化 多态/* * 多态的前提: * 子父类的继承关系 * 方法的重写 * 父类引用指向子类对象 * 动态绑定: * 运行期间调用的方法,是根据具体类型. */ public class Demo { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); Animals a = new Cat(); //多态的实现 a.eat(); } } class Animals{ public void eat() { System.out.println(&quot;吃东西&quot;); } } class Cat extends Animals { //方法的重写 public void eat() { System.out.println(&quot;猫吃鱼&quot;); } } 多态成员的特点: /*成员变量: 编译时看的是左边, 运行时看的是左边 成员方法: 编译时看的是左边, 运行时看的是右边 静态防范: 编译时看的是左边, 运行时看的也是左边. 总结: 编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法)看的都是左边. */ Dad d = new Kid(); //左边是 Dad d //右边是 new Kid() 多态中的向上转型和向下转型 Anmials a =new Dog(); //多态实现, 向上转型, 子类转化为父类 Dog d = (Dog)a; //向下转型, 父类转化为子类 多态的优缺点以及如何实现多态 /* * 多态的优缺点: * 优点: 可以提高可维护性(多态提前保证的), 提高代码的扩展性, * 缺点:无法直接访问子类特有的成员． */ public class Demo02 { public static void main(String[] args) { System.out.println(&quot;hello world&quot;); PhoneFactory pf = new PhoneFactory(); //实现多态 pf.createPhone(new XiaoMi()); //调用匿名对象 pf.createPhone(new HongMi()); } } //实现多态. class PhoneFactory { //用父类对象作参数 public void createPhone(Phone p) { p.create(); } } interface Phone { public abstract void create(); } class XiaoMi implements Phone { @Override public void create() { System.out.println(&quot;小米手机&quot;); } } class HongMi implements Phone{ @Override public void create() { System.out.println(&quot;红米手机&quot;); } } 权限修饰符​ public: 当前类, 相同包下不同的类, 不同包下的类 可以访问 ​ default: 当前类, 相同包下的不同类 可以访问 ​ private:当前类 ​ protected: 当前类, 不同包下的类 ​ default 和 protected 的区别: ​ default: 当前包下使用 ​ protected: 让子类对象使用 内部类​ 方法内部类 ​ 局部内部类 ​ 匿名内部类 迭代器迭代器是依赖于集合的， 相当于集合的一个副本，当迭代器在操作的时候， 如果发现和集合不一样， 则抛出异常（并发修改异常） foreach：增强for循环， 一般用于遍历集合或者数组。 List的常用子类​ ArrayList： 底层数据结构是数组， 查询快，增加删除慢 ​ LinkedList： 底层数据结构是链表，查询慢， 增加删除块 多线程多线程的执行方式 /* * 多线程的实现方式： * 方式1：一种方法是将声明为Thread的子类。 该子类应重写Thread类的run方法，接下来可以分配并启动子类的实例。 * * CPU执行程序的随机性 */ public class Demo { public static void main(String[] args) { myThread mt = new myThread(); mt.setName(&quot;Thread 1 &quot;); mt.start(); myThread mt1 = new myThread(); mt1.setName(&quot;Thread 2 &quot;); mt1.start(); myThread mt2 = new myThread(); mt2.setName(&quot;Thread 3 &quot;); mt2.start(); } } 多线程出现数据访问问题： /* 要有多个线程 要有被多个线程所共享的数据 多个线程并发的访问共享数据 */ synchronized: 同步（锁）， 可以修饰代码块和方法， 被修饰和代码块和方法一旦被某个线程访问，则直接被锁住，其他线程无法访问。 同步代码块： synchronized{ ...... } 同步方法： public synchronized void method();]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软考]]></title>
    <url>%2F2018%2F10%2F03%2F%E8%BD%AF%E8%80%83%2F</url>
    <content type="text"><![CDATA[第 1 章 计算机系统基础知识基本的计算机硬件系统由运算器, 控制器, 存储器, 输入设备和输出设备组成. 运算器和控制器以及其相关部件已被集成到一起, 统称为中央处理单元(CPU) 移码表示法: 是在数X上增加一个偏移量来定义的, 常用与表示浮点数中的阶码. 移码:不管正负数, 只要将其补码的符号位取反即可. 例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101 十进制数与字符的编码表示: 数值, 文字, 英文字母都被认为是字符, 任何字符进入计算机时, 都必须转换成二进制表示形式, 成为字符编码. 用4位二进制代码表示以为十进制数, 称为二-十进制编码, 简称BCD编码. 直接存储器存取(Direct Memory Access, DMA) 方式的基本思想是通过硬件控制实现主存与I/O设备之间的直接数据传送. 数据的传送过程由 DMA 控制器( DMAC ) 进行控制, 不需要 CPU 的干预. CPU 所能完成的操作是由其执行的指令决定的, 这些指令成为机器指令. CPU 能执行的所有机器指令的集合称为该 CPU 的指令系统. 指令系统是计算机硬件与软件之间的接口. 指令是指挥计算机完成各种操作的基本命令. 一般来说, 一条指令包括两个基本组成部分: 操作码和地址码. 操作码说明指令的功能机操作性质. 地址码用来指出指令的操作对象, 它指出操作数或操作数的地址及指令结果的地址. 操作码用二进制编码来表示, 该字段越长, 所能表示的指令就越多. 寻址方式: 就是如何对指令中的地址字段进行解释, 以获得操作数的方法或获得程序转移地址的方法, 操作数的位置可能在指令中, 寄存器中, 存储中或 I/O 端口. 常用的寻址方式有立即寻址, 直接寻址, 寄存器寻址, 寄存器间接寻址等. 磁盘存储器的主要技术指标： 道密度：沿盘面半径方向单位长度内磁盘的数目， 单位是道/毫米 位密度：磁道圆周上单位长度存储的二进制位的个数，单位是位/毫米 存储容量：总的盘面数 x 每面的磁道数 x 每道扇区数 x 每个扇区存储的字节数。 平均访问时间： 平均寻道（址）时间 +平均等待时间 数据传输率： 单位时间内写入或读出的字节数。 数据传输率 = 每道扇区数 x 每个扇区包括的字节数 x 磁盘的转数 第 2 章 操作系统基础知识操作系统是计算机系统中必不可少的核心系统软件, 其他软件的(编辑程序, 汇编乘车, 编译程序, 数据库管理程序等系统软件, 以及大量的应用的软件)是建立在操作系统的基础上的. 操作系统的作用是通过资源管理提高计算机系统的效率. 操作系统的 4 个特征是并发性, 共享性, 虚拟性和不确定性. 从资源管理的观点来看, 操作系统的功能可分为5大部分: 处理机管理, 文件管理, 存储管理, 设备管理和作业管理. 处理机管理, 实质上是对处理机的执行时间进行管理, 采用多道程序等技术将CPU 的时间合理地分配给每个任务. 主要包括进程控制, 进程同步, 进程通信和进程调度. 处理机管理也称为进程管理, 其核心是如何合理地分配处理机的时间, 提高系统的效率. 在计算机系统中有多个并发执行的程序, 采用 程序 这个静态概念已经不能描述程序执行时的动态变化过程, 所以引入了 进程 . 基本概念程序执行时的特征.进程 (Process) 是程序的一次执行. 进程通常有程序, 数据和进程控制模块 (Process Control Block, PCB ) 组成. 进程控制模块是进程存在的唯一标志. 进程的状态及其状态键的转换 三态模型, 在多道程序系统中, 进程的运行是走走停停的, 在处理器上交替运行, 状态也不断地发生变化, 因此一般有三种基本状态: 运行, 就绪和阻塞, 也成为三态模型. 运行: 当一个进程在处理机上运行时，称为进程处理运行状态．显然，对于单处理机系统，处理运行状态的进程只有一个． 就绪：一个进程获得了除处理机外的一切说需要的资源，一旦得到处理机即可运行，则称为进程处于就绪状态． 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生而暂时停止运行， 这时及时把处理机分配给进程，这时及时把处理机分配给该进程，他也无法运行，故称为该进程处于堵塞状态． 进程控制 进程控制是对系统中所有进程从创建到消亡的全过程实施有效的控制．在操作系统中通过设置一套控制机构堆进程实施控制，其主要功能包括创建一个新进程，撤销一个已经运行完的进程，改变进程的状态，实现进程间的通信．进程控制是由操作系统内核中的原语实现的． 原语是指由若干条机器指令组成，用于完成特定功能的程序段， 进程通信 在多道程序环境的系统中，存在多个可并发执行的进程，因此进程间必然存在资源共享和相互合作的问题．进程通信是指各个进程交换信息的过程． 进程间的同步:是指进程间完成一项任务时直接发生相互作用的关系. 进程间的互斥: 在多道程序系统中, 各进程可以共享各类资源, 但有些资源一次只能供一个进程使用, 称为临界资源. 如打印机. 进程间的互斥是指系统中各进程互斥使用临界资源. 临界区是进程中对临界资源实施操作的那段程序. 有空即进. 无空则等 有限等待 让权等待 信号量机制: 是一种有效的进程同步与互斥工具. 整形信号量与 PV 操作 信号量是一个整形变量, 根据控制对象的不同被赋予不同的值. 公用信号量. 实现进程间的互斥, 初值为 1 或资源的数目 私用信号量. 实现进程间的同步, 初值为 0 或某个正整数. 信号量 S 的物理意义: 若 S &gt;= 0, 表示某资源的可用数; 若 S &lt;０，则其绝对值表示阻塞队列中等待该资源的进程数． 对系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互斥有关． PV 操作是实现进程同步与互斥的常用方法. P 操作和 V操作是低级通信原语, 在执行期间不可分割. 其中, P 操作表示申请一个资源, V 操作表示释放一个资源. 高级通信: 为了提高通信效率, 能传递大量数据, 减轻程序的复杂度, 系统引入了高级通信方式. 高级通信方式主要分为 共享存储模式, 相互通信的进程共享某些数据结构 ( 或存储区), 实现进程之间的通信. 消息传递模式, 进程间的数据交换以消息为单位, 程序员直接利用系统提高的一组通信命令 (原语) 来实现通信. 如Send(A), Receive(A) 管道通信: 管道是用于连接一个读进程和一个写进程, 以实现它们之家你通信的共享文件 (pipe文件)，向管道提供输入的发送数据（即写进程), 以字符流的形式将大量的数据送入管道; 而接受进程可从管道接受大量的数据. 直接和间接通信 直接通信是将消息直接发送给制定进程. 间接通信是以信箱为媒体来是实现通信的, 接受信件的进程只需设疑一个信箱, 若干个进程都可以向同一个进程发送信件. 进程调度​ 进程调度方式是指当有更高优先级的进程到来时, 如何分配 CPU. 调度方式分为可剥夺和不可剥夺两种. 三级调度 调度算法: 常用的进程调度算法有先来先服务， 时间片轮转， 优先级调度和多级反馈调度算法． 死锁 在计算机系统中有各种互斥资源(如磁带机, 打印机和绘图仪) 和 软件资源(如进程表, 临界区等), 若两个进程互相要求对方已占用的资源. 所谓死锁, 是指两个以上的进程互相要求使用对方已经占有的资源而导致无法继续运行的现象. 进程推进顺序不当, 同类资源分配不当, PV 操作使用不当等情况都可能造成死锁. 线程 传统的进程有两个基本属性: 可拥有资源的独立单位, 可独立调度和分配的基本单位. 由于在进程的创建, 撤销和切换中, 系统必须为之付出较大的时空开销, 因此在系统中的设置的进程数目不宜过多, 进程切换不宜太高, 这就是限制了并发程度的提高. 引入了线程后, 将传统进程的两个基本属性分开, 线程作为调度和分配的基本单位, 进程作为独立分配资源的单位. 用户可以通过创建线程来完成任务, 以减少程序并发执行时付出的时空开销. 进程: 资源分配的最小单位 线程: 程序执行的最小单位. 线程是进程中的一个实体, 是被系统独立分配和调度的基本的单位. 线程基本上不拥有资源, 只拥有一点运行中必不可少的资源. 它可与同属一个进程的其他线程共享进程所拥有的全部资源. 存储管理 存储器管理的对象是(主存, 内存). 存储管理的主要功能包括分配和回收住存空间, 提高主存的利用率, 扩充主存, 对主存信息实现有效保护. 文件管理 文件是就有符号名的, 在逻辑上具有完整意义的一组相关信息项的集合. 第 3 章 数据库基础知识 文件系统是操作系统中的一个子系统, 它按一定的规则将数据组织成为一个文件, 应用程序通过文件系统堆文件的数据进行存取和加工. 文件系统对数据管理的, 实际上是通过应用程序和数据之间的一种接口实现. 文件系统的最大特点是解决了应用程序和数据之间的一个公共接口问题, 使得应用程序采用统一的存取方法来操作数据. 数据库系统是由计算机软件, 硬件资源组成的系统, 它实现了大量关联数据有组织地, 动态第存储, 方便用户访问. 它与文件系统的重要区别是数据的充分共享, 交叉访问, 与应用程序高度独立. 数据模型 模型是对现实世界特征的模拟和抽象, 数据模型是对现实世界数据特征的抽象. 第 4 章 多媒体基础知识色调:指颜色的类别， 如红色，绿色和蓝色等不同颜色． 第 5 章 网络基础知识 数据在网络中是以”包”的形式传递, 但不同网络的”包”的格式不同. 因此, 在不同的网络间传送数据时, 就需要网络间的连接设备充当翻译工作. 中继器: 可以”延长”网络的距离, 在网路传输中其到放大的作用. 数据经过中继器, 不需要进行数据包的转换. 中继器连接的两个网络在逻辑上是同一个网络. 中继器工作物理层, 对高层协议完全透明. 集线器: 集线器是中继器的一种, 区别仅在于集线器能够提供更多的端口服务, 所有集线器又称多口中集器. 集线器主要用于优化网络布线结构, 简化网络管理. 集线器是对网络进行集中管理的最小单元, 只是分配带宽, 可以放大和中转信号. ​ 使用集线器的优点是:当网络系统中某条线路或某结点出现故障时， 不会影响网上其他结点的正常工作，因为它提高了多通道的通信，大大提高了网络通信速度． 网桥： 当一个单位有多个LAN, 或一个LAN由于通信距离受限无法覆盖所有结点而不得不使用多个局域网时, 举要将这些局域网互联起来, 以实现局域网之间的通信. ​ 使用网桥可扩展局域网的范围, 网桥的每个端口与一个网段(这里说所的网段就是普通局域网)相连. ​ 网段:一般指一个计算机网络使用同一物理层设备，能够直接通信那那一部分．例如，从192.168.0.1到192.168.255.255这之间就是一个网段。 交换机： ​ 交换机提高了另一种提高数据传输速率的方法． 第 7 章 软件工程基础知识 面向对象的基本概念 １.对象 ２.消息：对象之间进行通信的一种构造叫做信息。 当一个消息发送给某个对象时，包含要求接受对象去执行某些活动的信息。接受到信息的对象经过解释，然后给予响应。这种通信机制叫做消息传递。发送消息的对象不需要知道接受消息的对象如何响应应该请求。 ３.类：一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述了一组对象的共同行为和属性。把一组对象的共同特征加以抽象并存在一个类中，而是面向对象技术最重要的一点，是否建立了一个丰富的类库，是衡量一个面向对象程序设计语言成熟与否的重要标志。 ４.继承：是父类和子类之间共享数据和方法的机制。 ５.多态：对象收到消息时，要给予响应。不同的对象收到同一消息可以进行不同的响应，产生完全不同的结果，这种现象叫做多态。 ６.动态绑定：绑定是一个把过程调用和响应调用需要执行的代码加以结合过程。 软件测试的目的及原则 ​ 软件测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。 ​ 测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。 维护： 改正性维护是指诊断和改正在使用过程中发现的软件错误； 适应性维护是值修改软件以适应环境的变化 完善性维护是根据用户的要求改进或扩充软件是它更完善 预防性维护是指修改软件为将来的维护活动预先做准备。 常见的软件生存模型： 瀑布模型：一个待开发的系统需求是完整的、简明的、一致的 增量模型：假设将需求分段为一系列的增量产品。 演化模型：针对事先不能完整定义需求的软件开发，是在一个快速开发的基础上，根据用户在使用模型的过程中提出的意见和建议对原型进行改进。 螺旋模型：将瀑布模型和演化模型结合。 喷泉模型： 软件过程：生产一个最终满足需求并且达到工程目标的团建产品所需的步骤。过程是活动的集合，活动是任务的集合。 软件能力成熟度模型：CMM。 CMM将软件过程改进分为5个成熟度： 初始级，可重复级，已定义级，已管理级，优化级。 软件调试：试探发， 回溯法，对分查找法，归纳法，演绎法 第 8 章 数据结构与算法 ​ 数据结构是指数据元素的集合及元素间的相互关系的构造方法。 ​ 矩阵是很多科学与工程计算领域研究的数学对象。在数据结构中主要讨论如何在尽可能节省存储空间的情况下，使矩阵的各种运算能搞笑地运行。 第 12 章 Java 程序设计语言 /* 这里将main方法定义公共方法的目的是为了让Java解释器能够调用此方法 而定义为静态static，因为调用main方法的时候还不存在任何对象，main方法只能属于类，而不能和对象相关联。 */ public class Demo { public static void main(String[] args) { } } StringBuffer 字符串： 类StringBuffer的对象也表示字符串，与String不同的是， StringBuffer是线程安全的可变的字符序列， StringBuffer对象引用的字符串能够通过特定的方法调用被直接修改。 StringBuilder 字符串 ​ StringBuilder 是 Java1.5引入的一个可变的字符序列，提供了和 StringBuffer 相同的API， 但是不保证同步（非线程安全），在只有一个线程时替代 StringBuffer 使用。 StringBuilder 的大多数实现要比 StringBuffer快速， 推荐优先使用 StringBuilder 。 Java程序中不需要明确删除一个对象，因为Java有自动的垃圾回收机制。 当一个对象没有任何变量引用时， 该对象的生存期结束，其存储空间由系统自动回收。 包： ​ 定义包： package ​ 引入包： import来引入包 注解@override 表示子类 getValue() 是覆盖了父类的 getValue()， 如果程序员不小心拼写错误， 或者方法签名对不上被覆盖的方法， 编译器就会发生错误提示。 接口： 也是实现代码重用的一种方式， Java不支持多重继承， 接口是顺应多重继承的需要的而产生的， 以另一种方式实现多重继承，接口实际是一组抽象方法和常量的集合。 异常： ​ 异常分为两种： Error 和 Exception。 编程程序时应该考虑异常的产生和处理。 通常， 程序不需处理 Error 类型的异常， 但是应关注 Exception 类型的异常。 文件输入、输出和流 ​ 一个流是一个输入设备或输出设备的抽象表示， 一般分为字符流和字节流。 字节流：字节流处理单元为8位的字节，数据源中如何含有非字符数据的二进制的数据，如音频，图片，歌曲文件等， 就是字节流来处理输入/输出。 所有的字节流都是抽象基类 InputStream 或者 OutputStream 的子类， 这两个类是抽象的， 不能直接创建其对象来创建一个流， 而要通过他们的子类来创建一个流。 集合类：Java提供了容纳对象（或者对象的句柄）的多种形式，以设计好的类库形式提供了读数据进行有效管理的数据结构和算法， 如链表、二叉树、栈和散列表等。 Java集合框架分为集合和映射两组， 分别从两个基本接口继承而来： Collection 和 Map， 他们是相互独立的， 包含了常用的数据结构 考点第 1 章 CPU包括运算器，控制器，寄存器三大部分。 时钟周期是最基本，最小的时间单位。指令周期 &gt; 机器周期 &gt; 时钟周期 海明码是利用奇偶性来检错和纠错的校验方法。 在同一时间处理二进制数的位数称为字长。通常称处理字长为8位数据的CPU为8位CPU。 光盘格式中，不能多次擦除重写数据的是 CD-R 地址总线的宽度决定了CPU可以访问的物理地址空间，简单地说就说CPU到底能够使用多大容量的内存。 在微型计算中，通常用主频来描述CPU的运算速度；对计算机磁盘工作影响最小的因素是噪声。 CPU执行算术运算或者逻辑运算时，算术运算部件(ALU)将计算结果保存在累加器AC中。 PCI 是系统总线， USB 是串行总线， IEEE-1394也是高速串行接口标准， IEEE-488是并行外部总线。 若指令系统中设置了专用I/0操作指令，则I/0接口可以独立编址。 第 2 章 操作系统的定义 操作系统的作用 操作系统的特征：并发性，共享性，虚拟性和不确定性， 4个基本特征。虚拟性是操作系统的重要特征，所谓虚拟是把物理上的一台设备变成逻辑上的多台设备。 不确定性：通常一个程序的初始条件相同时，无论何时运行，结构都应该相同。但由于操作系统并发执行系统内的各种进程。 操作系统的功能： ​ 1.处理机管理负责解决如何把CPU时间合理地、动态地分配给程序运行的基本单位–进程，是处理机得到充分利用。 ​ 2.存储管理：存储器是运行程序或存放工作数据的部件，存储管理的工作的主要是对内存存储器进行分配，扩充和保护。 ​ 3.设备管理 ​ 4.文件管理 存储器的功能是保存数据 虚拟地址：数据的存放地址是友符号决定的， 故又称为符号名地址，或者成为名地址。 地址重定位：是指程序的逻辑地址转换成主存的物理地址的过程。在可执行文件装入时需要解决可执行文件中的地址和主存地址的对应关系。 存储管理：分区存储管理，分页存储管理，分段存储管理，段页式存储管理和虚拟存储管理、其中存储管理是把主存中的用户区划分成若干个区域，每个区域分配給一个用户作用使用，并限定他们只能在自己的区域运行。按划分的不同方式，可分为固定分区，可变分区和重定位分区。 分页式存储管理： ​ 分页管理：将一个进程的地址空间划分为若干个大小相等的区域，称为页。相应的，将内存空间划分成与页相同的大小的物理块，成为块或页框。 分段存储管理： ​ 作业的地址空间被划分成若干个段，每个段是一组完整的逻辑信息，如有主程序段，子程序段，数据段和堆栈段等，每个段都有自己的名字，都是从0开始编址的一段连续的地址空间，各段的长度是不等的。 虚拟存储器管理： ​ 存储管理策略的基础是局部原理——进程往往会不均匀地，高度局部化地访问主存。 ​ 虚拟存储器的定义：一个作业在运行之前，没必要全部装入内存中，而仅将当前要运行的那部分分页面或段先装入主存启动运行，其余部分暂时时留在磁盘上。 虚拟存储器具有请求调入功能和置换功能，仅能把作业的一部分装入内存便可运行作业的存储器系统，能从逻辑上对主存容量进行扩充。 设备管理： ​ DMA 技术：在外围设备和主存之间开辟直接的数据交换通路。在内存与输入/输出设备间传送一个数据块的过程中，不需要CPU的任何干涉，只需要CPU在过程中开始启动和过程结束时处理，实际操作由DMA硬件直接执行完成。 ​ 缓冲技术：硬件缓冲是利用专门的硬件寄存器作为缓冲区；软件缓冲是利用操作系统的管理，用主存中一个或多个区域作为缓冲区，进而可以形成缓冲池。 磁盘调度： 对磁盘的存储访问一般要有三部分时间。 首先要将磁头移动到相应的磁道或柱面上，这个时间叫做寻寻道时间。信息在磁盘和内存之间的实际传送时间叫做传送时间。磁盘调度的目的是平均寻道时间最少。 数据库概念模式：是数据库中全部数据的逻辑结构和特征的描述，由若干个概念记录类型组成。 外模型：是用户与数据库系统的接口 软件工程基础知识 风险分析：风险控制，风险预测，风险控制。风险回避，损失控制，风险转移和风险保留。 常见的生命周期模型： 软件生命周期六个阶段：问题的定义及规划，需求分析，软件设计，程序编码，软件测试，运行维护 软件工具：软件开发工具， 软件维护工具， 软件管理和软件支持工具。 UML图：统一建模语言是用来对软件密集系统进行可视化建模的一种语言。 UML图：用例图，静态图，行为图，状态图，交互图，实现图。 类之中的关系：UML中规定，类中共有4中基本关系：依赖， 关联，泛化，实现。 面向对象分析模型5个层次：主题层，对象类层，结构层， 属性层和服务层。 结构化设计方法：是一种面向数据流的方法 相对对象建模得到的模型包含对象的三个要素：静态结构，交互次序和数据交互。 面向对象设计原则：封装，信息隐蔽，高内聚，低耦合。 耦合关系 内容耦合：一组模块都访问同一个公共数据环境。 外部耦合：一组模块都访问同一个全局简单变量而不是同一全局数据结构。 控制耦合：一个模块把控制信息传递给另一个模块，对其功能进行控制。 标志耦合：一组模块通过参数传递记录信息，这组模块就是标记模块，注释：事实上模块共享了某一数据结构的子结构，而不是简单的变量。 数据耦合：一个模块访问另一个模块彼此之间通过数据参数来交换输入，输出信息。 非直接耦合：两个模块之间没有直接关系，它们间的联系完全通过主模块的控制和调用来实现的。 软件质量管理和质量保证 ​ 功能性、可靠性、易用性、效率、可维护性、可移植性。这六中质量特性都由质量特性（第一层6个），子特性（第二次21个）和度量 三个层次组成。 测试分类： ​ 黑盒测试：是一种功能测试，就是将被测试系统看成一个黑盒，单纯从外界取得输入后进行输出。 ​ 白盒测试：逻辑测试，也叫结构测试，它把程序看成白盒，即测试时了解被测对象的内部逻辑结构，并且以程序内部的设计结构及具体的代码实现为基础来设计测试用例。 软甲测试分四步： ​ 单元测试，集成测试，系统测试，确认测试。 软件工程是计算机软件的一个重要的分支和研究方向。 软件生存周期：可行性分析和项目开发计划，需求分析，软件设计，编码，测试和维护6个阶段。 软件开发项目管理是指在软件生存周期中软件管理者所今进行的一系列活动，是软件系统或软件产品按原定的计划和质量要求如期完成。 软件开发项目管理：进度管理，成本管理，质量管理，人员管理，资源管理，标准化管理。 成本估算，风险分析，进度管理，人员管理。 风向分析的主要活动有风险识别，风险估算，风险管理策略，风险解决和风险监督。 面向对象 = 对象 + 分类 + 继承 + 通过消息的通信 多态是指同一个操作作用于不同的对象可以有不同的解释，产生不同的执行结果。 与多态密切相关的一个概念是动态绑定，传统的程序设计语言，把过程调用与目标代码的连接放在程序运行前进行，而动态绑定则是把这种连接推辞到运行时才进行。 软件测试方法： 静态测试又称为代码审查。通过对程序静态结构的检查，找出编译时不能发现的错误。 动态测试： 白盒测试：完全了解程序的内部结构和处理过程，它，根据程序的内部逻辑来设计程序用例，检查程序的逻辑通路是否都按预订的要求正确地工作。 黑盒测试：完全不考虑程序的内部结构和处理过程，而只是测试软件的外部特性。 软件测试的主要过程： 单元测试，也称为模块测试，通常采用白盒测试 组装测试，也称为集成测试，它是由各模块组装而成的程序进行测试，主要检查模块间的接口和通信。通常采用黑盒测试。 确认测试，检查软件的功能，性能以及其他特征是否与用户的需求一致。通常采用黑盒测试 系统测试：和其他因素结合在一起，进行信息系统的各种组装测试的确认测试，主要目的是通过与系统的需求相比较，来发现所开发的系统与用户需求不符合和矛盾的地方。 软件调试： 试探法，回溯法，对分查找法，归纳法，演绎法。 软件测试的目的及原则，软件测试是发现软件中错误和缺陷的主要手段。]]></content>
      <categories>
        <category>考试</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F08%2F28%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[换行：1.方法1： 连续两个以上空格+回车。 首行缩进两个字符：（每个表示一个空格，连续使用两个即可） 1.&amp;ensp;半角的空格 ​ 2.&emsp;全角的空格 字体、字号、颜色 - &lt;font color=red&gt;red&lt;/font&gt; - &lt;font color=blue&gt;blue&lt;/font&gt; - &lt;font color=green&gt;green&lt;/font&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[clovers]]></title>
    <url>%2F2018%2F08%2F28%2Fclover%2F</url>
    <content type="text"><![CDATA[快捷键技巧： Ctrl+W关闭页面Ctrl+Tab切换页面]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>clovers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;stromzhang&quot; git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知道自己不知道的]]></title>
    <url>%2F2018%2F08%2F28%2F%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%2F</url>
    <content type="text"><![CDATA[入门篇： python 和 java Script 选择 入门语言 学习使用操作系统linux 学习使用编程工具 vs 和 vs code 正式入门 推荐文章： The Key To Accelerating Your Coding Skills 编程技巧方面：怎么把程序写好的书（代码大全）。 java语言学习：Java核心技术卷一， spring: spring in action 操作系统：鸟哥的Linux私房菜 网络协议：HTTPS文档， 数据库设计：慕课网 数据库设计那些事 数据库：MySQL必知必会 前端方面： 编码方面：ASCII, UNICODE, 编程工具方面：JAVA VS CODE 版本管理工具：GIT, 调试前端工具： 数据库设计工具： java语言 综合性实力最强 IDE 版本管理工具 git 调试前端工具 数据库设计工具 程序员修养 英文能力 问问题的能力 写代码的修养 安全防范意识 软件工程和上线规范 编程规范 专业技术篇 编程语言: c, c++, java 理论学科: 算法与数据结构，网络模型，计算机原理，操作系统原理，编译原理，数据库原理。（工人和工程师的差别） 系统知识：Unix, Linux, TCP/IP, C10K 从业方向：底层，大数据，分布式开发等等。 软件设计能力&emsp;&emsp;工程师走向架构师 程序员荒谬之言还是至理名言 如果你把一个技术搞精搞深，你的知识面自然会很广的。 面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会（依据自己兴趣学习） 为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。 不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。 永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。（特别赞同） Teach Yourself Programming in Ten Years——用十年教会自己编程]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>系统知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>摘抄</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
