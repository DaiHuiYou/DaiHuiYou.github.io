<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F06%2F06%2Fleetcode%2F</url>
    <content type="text"><![CDATA[1. 两数相加 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *h1 = l1; ListNode *h2 = l2; ListNode *h3 = new ListNode(0); ListNode *pos = h3; int res = 0; int carry = 0; bool first = true; // 两个链表相加，想象拉裤子拉链的情况。 ^_^ while(h1!=NULL &amp;&amp; h2!=NULL){ // 两个链表之间的共同位 res = h1-&gt;val + h2-&gt;val + carry; if(first){ // 第一次执行 pos-&gt;val = res % 10; carry = res / 10; first = false; } else { ListNode *pNode = new ListNode(0); pNode-&gt;val = res % 10; carry = res / 10; pos-&gt;next = pNode; pos = pos-&gt;next; } h1 = h1-&gt;next; h2 = h2-&gt;next; } // 当 h1.len &gt; h2.len if(h1!=NULL){ while(h1!=NULL){ ListNode *pNode = new ListNode(0); res = h1-&gt;val + carry; pNode-&gt;val = res % 10; carry = res / 10; pos-&gt;next = pNode; pos = pos-&gt;next; h1 = h1-&gt;next; } } // 当 h1.len &lt; h2.len if(h2!=NULL){ while(h2!=NULL){ ListNode *pNode = new ListNode(0); res = h2-&gt;val + carry; pNode-&gt;val = res % 10; carry = res / 10; pos-&gt;next = pNode; pos = pos-&gt;next; h2 = h2-&gt;next; } } if(carry!=0){ // 最后一位相加 ListNode *pNode = new ListNode(carry); pos-&gt;next = pNode; pos = pos-&gt;next; carry = 0; } return h3; } }; 2. 从排序数组中删除重复项给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 class Solution { public: int removeDuplicates(vector&lt;int&gt;&amp; nums) { int index = 0; if(nums.size() == 0) return 0; for(int i=1; i&lt;nums.size(); i++) { if(nums[index] != nums[i]) { index++; nums[index] = nums[i]; } } return index+1; } };]]></content>
  </entry>
  <entry>
    <title><![CDATA[OS]]></title>
    <url>%2F2019%2F05%2F28%2FOS%2F</url>
    <content type="text"><![CDATA[并发和并行并发： 同一「时间点」顺序执行，同一「时间段」交替重叠。 （本质性上也顺序执行，利用单个 CPU 实现宏观层面的并行） 并行：正真意义上并行，无论微观和宏观上都是并行。完全是多个 CPU 执行。 并发 VS 并行： 单个CPU VS 多个CPU 线程是处理机调度的基本单位结合我以前的经历，通常单片机的裸机程序的编程都是模块和模块之间的顺序执行，当一个模块因某种原因阻塞，从而导致接下来的模块不能执行而延迟响应，所以不能呈现出良好的实时性。 那么可以通过单片机的「硬件计时」，自己分配处理机的时间片，通过「中断」切换模块和模块之间的执行流程。进而实现模块和模块之间的并发执行。 裸机程序的模块间的并发类似与多线程，理解为模块间是手动分配处理机的执行时间， 而多线程是处理机调度的基本单位，是由操作系统依据特定算法分配线程的处理机执行时间。 只不过单片机未引入操作系统之前，需要自己要分配时间片和确定好中断流程，在操作系统中多线程这不需要这些操作，单纯调用语句就行了。 进程是资源调度的基本单位单片机通常是执行一个特定的程序（进程）， 不存在进程间的资源争斗问题，一个进程拥有在单片机的全部资源。 我认为多进程的引入是为了充分利用资源。怎么说，属于临界资源的打印机， 一个进程需要打印机资源， 另一个进程也需要打印机资源，并不能让两个进程在同一「时间段」拥有打印机资源。 多进程的实现，在宏观层面上实现进程间的资源共享。当然， 同一时间段， 进程间的资源不能共享。这需要资源分配策略 「 银行家算法的实现 」。]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序设计]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[程序设计：面向对象： 强调数据，名词为类，动词为该类的成员方法。 面向过程：整体到局部。 C++ 类方法和 C 函数的区别 在变量的角度 在 C 的函数中，只能使用 local variable（函数内部的所有变量），global variable （独立于该函数外的所有变量）。 在C++的 类方法中，可以使用 局部变量，可以使用属于对象的成员变量，可以使用属于类的静态成员变量，以及属于该文件的全局变量。 在数据输出的角度 C 的函数在执行后，通过形参 pointer 来返回结果 或 通过 return 返回结果。结果只能是局部变量的值或者全局变量。 C++的类方法在执行后，可以通过 形参 或者 return 输出 成员变量，静态成员变量， 全局变量，局部变量的值或引用。 对象调用成员方法和类调用成员方法：obj.func(): 对象调用成员方法，可能会改变对象状态，也就是说将对象中的成员变量的值因成员方法的调用而所改变。 Class.func(): 类调用成员方法， 由于类无成员变量， 静态成员变量除外。所以 类调用成员方法只是单纯调用函数。 内部类 内部类的拥有外围的所有元素的访问权限 头文件声明和类的声明C 的头文件的声明 和 C++ 的类的声明类似， 在 C 中，头文件声明变量和函数， 变量可在函数中使用。 在 c++ 中， 类的声明，成员变量和成员函数在 class 中声明， 通常一个文件包含一个类。 类的声明可以当做一个文件。 变与不变的问题 需求不可能是固定的，为了应对需求的改变， 避免以前代码推倒重写，这需要开闭原则（对外支持功能扩展，对已有的代码封闭） 写新代码，就不要修改旧的代码。 类的成员变量：不变 类的成员函数的形参：变 委托模式：接口不变，支持扩展功能。 适配器模式：功能相同，接口不同 策略模式：接口相同，功能不同 代理模式：引用技术，智能指针 装饰模式：不修改原有的代码，进行添加功能]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SOCKET]]></title>
    <url>%2F2019%2F05%2F20%2FSOCKET%2F</url>
    <content type="text"><![CDATA[1. TCP连接的粘包问题由于TCP是面向连接，二进制流传输，由于 Send()是发送给操作系统的缓冲区，并不是立即发送给客户端，等缓冲区有一定大小，再一次性发送给客户端。 所以由于这样的机制，多次消息的发送，可能一次性消息的接受。导致粘包问题，即是多个消息粘在一起发送。 解决方法 发送一次消息，等待接受消息，即判断对方是否接受到消息，确定对方接受到了消息，再继续发送下一条消息。 2. 多媒体文件传输多媒体文件并不是文本文件，采取文本文件读取，对方接受到多媒体文件无法解码。所以文件读取的方式采取是二进制。 传输文件的方法 服务端：读取文件，连续 send()，直到发送完成。等待客户端接受完成消息。 客户端：接受服务端的消息，以二进制的方式存储到文件中，接受完成后，发送服务端接受完成消息。 3. 阻塞和非阻塞阻塞即是有消息则接受消息，没有消息则一直等待，不去执行其他操作。 在 TCP中 recv() 是采用阻塞方式接受。 非阻塞即有消息接受消息，没有消息则执行其他操作。 4. 多线程实现多个客户端连接多线程实现多个客户端连接，线程的数量等于客户端的数量， 当客户端连接数量大到一定程序，服务端容易崩溃。 5. Select模型实现多个客户端连接select 模型时 Winsock 中最常见的 I/0 模型， 它的中心思想是利用 select 函数，实现多个套接字 I/0 的管理。 利用 select 函数，可以判断套接字上是否存在数据，或则能否向一个套接字写入数据。 只有在条件满足时，才对套接字进行输出操作。 异步 I/0 模型通过调用 WSAAsynocSelect 函数实现，利用这个模型，应用程序可在一个套接字上接受以 windows 消息为基础的网络事件。 6. pingPING ，使用 ICMP 协议， 基于网络层， 包加上 源IP 和 目的IP， 在 数据链路层中加上源 MAC 地址和目的 MAC 地址，发送到局域网的另一台主机。]]></content>
      <categories>
        <category>SOCKET</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[O(n^2)1 . 选择排序// 未优化 template&lt;typename T&gt; void selectionSort1(T arr[], int n) { for (int i = 0; i &lt; n; i++) { for (int j = i + 1; j &lt; n; j++) { if (arr[j] &lt; arr[i]) swap(arr[j], arr[i]); } } return; } // 优化 template &lt;typename T&gt; void selectionSort2(T arr[], int n) { for (int i = 0; i &lt;= n - 1; i++){ int minIndex = i; for (int j = i+1; j &lt;= n - 1; j++) { if (arr[minIndex] &gt; arr[j]) minIndex = j; } swap(arr[minIndex], arr[i]); } return; } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 selectionSort1 : 2.208 s selectionSort2 : 0.108 s 2. 插入排序// 未优化 template&lt;typename T&gt; void InsertionSort1(T arr[], int n) { for (int i = 1; i &lt; n; i++) { for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) { swap(arr[j], arr[j - 1]); } } } // 优化 template&lt;typename T&gt; void InsertionSort2(T arr[], int n) { for (int i = 1; i &lt; n; i++) { T e = arr[i]; int j; for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--) arr[j] = arr[j - 1]; arr[j] = e; } return; } 测试 从1万个 0~100 的随机数中，从小到大排序。 InsertionSort1 : 2.653 s InsertionSort2 : 0.064 s 3. 希尔排序// 希尔排序 template&lt;typename T&gt; // n 表示数组 capacity void shellSort(T arr[], int n) { int cnt = n - 1; // 数组元素个数 int tmp = 0; // 临时变量 // d：distance， for (int d = n/2; d&gt;=1; d=d/2) { // 遍历 for (int i = d; i &lt;=cnt; i++) { // 插入排序 tmp = arr[i]; for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) { arr[j + d] = arr[j]; arr[j] = tmp; } } } } 测试 从 1 万个 0~100 的随机数中，从小到大排序。 Insertion Sort : 6.332 s Shell Sort : 0.029 s O(nlogN)1. 归并排序2. 快速排序int __partition(int arr[], int l, int r) { int v = arr[l]; int j = l; for (int i = l + 1; i &lt;= r; i++) { if (arr[i] &lt; v) { j++; swap(arr[i], arr[j]); } } swap(arr[j], arr[l]); return j; } void __quickSort(int arr[], int l, int r) { if (l &gt;= r) return; int p = __partition(arr, l, r); __quickSort(arr, l, p - 1); __quickSort(arr, p + 1, r); } // 快速排序 void quickSort(int arr[], int n) { __quickSort(arr, 0, n - 1); } 3. 堆排序void shiftDown(int arr[], int n, int k) { while (2 * k + 1 &lt; n) { int j = 2 * k + 1; if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) { j++; } if (arr[k] &lt; arr[j]) { swap(arr[k], arr[j]); k = j; } else break; } } void heapSort1(int arr[], int n) { // heapify for (int i = (n - 1) / 2; i &gt;= 0; i--) { shiftDown(arr, n, i); } for (int i = n - 1; i &gt; 0; i--) { swap(arr[0], arr[i]); shiftDown(arr, i, 0); } } // n 为数组元素个数 // k 当前要筛选的索引 // arr[0] 为临时存储变量 void shift(int arr[], int n, int k) { while (2 * k &lt; n) { int j = 2 * k; if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1]) j++; if (arr[k] &lt; arr[j]) { // arr[j] 与 arr[k] 交换 arr[0] = arr[j]; arr[j] = arr[k]; arr[k] = arr[0]; k = j; } else break; } } // n 为数组元素个数 // arr[0] 为临时存储变量 void heapSort2(int arr[], int n) { for (int i = (n - 1) / 2; i &gt;= 1; i--) { shift(arr, n, i); } for (int i = n - 1; i &gt;=2; i--) { // arr[i] 与 arr[1] 交换 arr[0] = arr[i]; arr[i] = arr[1]; arr[1] = arr[0]; shift(arr, i, 1); } } 测试 从100 万个 0~100 的随机数中，从小到大排序。 Heap Sort 1 : 2.228 s Heap Sort 2 : 0.248 s]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mfc]]></title>
    <url>%2F2018%2F12%2F23%2Fmfc%2F</url>
    <content type="text"><![CDATA[基本概念：​ API函数： Windows操作系统提供给应用程序编程的接口 ​ Windows 应用程序 API 函数是通过 C 语言实现的，所有主要的 Windows 函数都在 Windows.h 头文件中进行了声明。 ​ 在 Windows 应用程序中， 窗口通过窗口句柄（HWND）来标识的，我们要对某个窗口进行操作，首先就要得到这个窗口的句柄。 ​ WinMain是Windows程序的入口， Main是Doc程序的入口 ​ 消息与消息队列： Windows程序设计是一种事件驱动的方式驱动程序设计模式，主要基于消息的。每个 Windows 应用程序开始执行后，系统都会为程序创建一个消息队列， 这个消息队列用来存放创建的窗口的消息。然后应用程序通过消息循环不但地从消息队列中取出消息，并进行相应。在这个处理过程中， 操作系统也会给引用程序 “ 发送消息”。 所谓“ 发送消息”，实际上操作系统调用程序中一个专门负责处理消息的函数，这个函数称为窗口过程。 ​ 实例句柄（hInstance）：表示该程序当前运行的实例的句柄，这是一个数值。当程序在Windows下运行时，它唯一标识运行中的实例（注意，只有运行中的程序实例，才有实例句柄）。一个应用程序可以运行多个实例，每运行一个实例，系统都会给该实例分配一个句柄值，并通过hInstance参数传递给 WinMain 函数。 ​ 窗口句柄（hwnd) ​ 消息循环：在创建窗口，显示窗口、更新窗口后，我们需要编写一个消息循环，不断地从消息队列中取出消息，并进行效应。 ​ MFC 是以 C++ 的类的形式封装了 Windows API， 并且包含一个应用程序框架，以减少应用程序开发人员的工作量。 过程 设计窗口 注册窗口 创建窗口 显示窗口和更新窗口 消息循环队列 处理窗口过程 建立消息循环 MSG msg; while (GetMessage(&amp;msg, NULL, 0, 0)) { TranslateMessage(&amp;msg); //用于翻译、处理和转换消息并把新消息投放到消息队列中，并且过程不会影响原来的消息队列 DispatchMessage(&amp;msg); //将消息传递给操作系统，让操作系统调用窗口回调函数，来对消息进行处理 } 窗口过程函数： //窗口过程函数 LRESULT CALLBACK WinProc( HWND hWnd, //信息所属的窗口句柄 UINT uMsg, //消息类型 WPARAM wParam, //附加信息(如键盘按键) LPARAM lParam //附加信息(如鼠标点击坐标) ) { switch (uMsg) { case WM_KEYDOWN: //键盘按下 MessageBox(hWnd, TEXT(&quot;键盘按下&quot;), TEXT(&quot;键盘&quot;), MB_OK); break; case WM_DESTROY: PostQuitMessage(0); break; default: //以windows默认方式处理 return DefWindowProc(hWnd, uMsg, wParam, lParam); } return 0; } MFC入门：​ CWinApp 应用程序类： MFC 应用程序的核心就是基于 CWinApp类的应用程序对象。CWinApp提供了消息循环来检索消息并将消息调度给应用程序窗口。 ​ 一个 MFC 程序可以有且仅有一个应用程序对象，此对象必须声明为全局范围有效，以便它在程序开始时即在内存中实例化。 ​ 将消息映射添加到一个类中所做的全部工作 ​ MFC 中后缀名为 Ex 的函数都是扩展函数 ​ 在 MFC 中，以 Afx 为前缀的函数都是全局函数，可以在程序的任意地方调用他们。 消息映射CWinApp 提供了消息循环来检索消息并将消息调度给应用程序的窗口。 灰色的代码是mfc生成的，不是你自己写的。通常是控件声明、消息映射宏或者消息响应函数的定义等等。这些不能删掉。 //{{AFX_DATA_MAP ... //}}AFX_DATA_MAP 组件数据与组件间的映射 //{{AFX_MSG_MAP ... //{{AFX_MSG_MAP 消息与处理函数间的映射 消息映射是一个将消息和成员函数相互关联的表。比如，框架窗口接受到一个鼠标左击消息，MFC将搜索该窗口的消息映射，如果存在，然后就调用对应的处理函数。 调用 CWinApp 的 InitInstance 函数后，WinMian 函数调用 CWinApp 类的Run函数，通常默认为 CWinThread：：Run（） ， 用来得到应用程序的消息循环，或者称为消息列队。 视图类 CFrameWnd 是从 CWnd （窗口基类) 派生出来的。CFrameWnd 模仿框架窗口行为，我们可以把框架窗口作为顶层窗口看待，它是应用程序与外部世界的主要接口。 MFC 应用程序的核心就是基于 CWinApp 类的应用程序对象。CWinApp 提供了消息循环来检索消息并将消息调度给应用程序窗口。它还包括可被覆盖的、用来自定义应用程序行为的主要虚函数。 一个 MFC 程序可以有且仅有一个应用程序对象，此对象必须声明为在全局范围内有效，以便它在程序开始时即在内存中被实例化。 数据的存储和加载由文档类来完成，数据的显示和修改由视图类来完成。 CView 类 也派生于 CWnd 类，框架窗口是视图窗口的一个父窗口。主框架窗口（CFrameWnd）是整个应用程序外框所包括的部分，即图中粗框以内的内容，而视类窗口只是主框架中空白的地方。 CString 要使用 CString, 需要在工程引用头文件：#include &lt;afx.h&gt;,一般放到stdafx.h预编译头中．另外需要在项目属性中选择＂在共享 DLL 中使用 MFC ＂. 3) TEXT（_T）宏 MFC 中的 TEXT 宏可以自动适应字符类型，如果定义了预处理器程序符号_UNICODE，那么编译器将使用Unicode字符，如果没用定义该预处理器程序符号，那么编译器将使用ANSI字符。 对话框：CDialogDlg：对话框类，从CdialogEx继承过来的，在程序运行时看到的对话框就是它的一个具体对象。 DoDataExchange 函数：该函数主要完成对话框数据的交换和校验。 OnInitDialog 函数：相当于对对话框进行初始化处理。 模态和非模态 当模态对话框显示时，程序会暂停执行，直到关闭这个模态对话框之后，才能执行程序中的其他任务。 当非模态对话框显示时，运行转而执行程序中的其他任务，而不用关闭这个对话框。 创建对话框放在主对话框类的构造函数或 OnCreate() 函数，目的只创建一次对话框： UpdateData() 函数 UpdateData(true); // 用于将屏幕上控件中的数据交换到变量中。 UpdateData(false); // 用于将数据在屏幕中对应控件中显示出来。 关联控件变量： 单文档视图对象是用来显示文档对象的内容， 函数 GetDocument() 用户获取当前文档对象的指针 m_pDocument. 函数 OnDraw() 是一个虚函数， 负责文档对象的数据在用户视图区显示输出。 数据的储存和加载由文档来完成，数据的显示和修改则由视类来完成。 框架窗口是视窗口的父窗口，那么视类窗口就应该始终覆盖在框架类窗口之上。 创建单文档应用程序的一般步骤 利用 AppWizard 创建应用程序框架 在文档内中声明保存文档数据所需要数据对象 完成文档类的 OnNewDocument 函数，初始化新文档 完成文档类的 Serialize 函数，保持和加载文档数据 完成视类的 OnInitialUpdate 函数，初始化显示 完成视类的 OnDraw 函数，显示当前文档内容 在视类中加入可以使用户编辑文档数据所需的代码 UpdateAllViews 当更新了Doc类的内容，一般都用这个把更新的内容可视化 OnCreate() 是生成结构的，而 OnInitialUpDate 是对结构进行初始化。两个一个相当于硬件一个相当于软件，功能和作用完全不同。但是是相互密切联系。 int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) //创建窗体的工具栏，状态栏等 _T宏若定义了_UNICODE ， 则为 Unicode 编码， 若定义 _ASCII ， 则了 ASCII 编码。 为了实现代码与字符集无关。 Windows GDI( Graphics Device Interface 图形设备接口)在 Windows 中， 只要有相应的 Windows 驱动程序， 你所编写的代码就可在任一图像的适配器运行。 MFC 设备描述表类， CWind::GetDC, 专门用途的设备描述表类， CPaintDC， CClientDCC 鼠标和键盘当用户在菜单栏上单击一个项目时， 会自动拉下一个菜单， 并在菜单中的某个项目选定后给应用程序程序发送一个 WM_COMMAND 消息。 菜单创建菜单方法： 向应用程序资源文件（resource file）中添加一个菜单模板。 resource file 是一个脚本式文本文件， 它定义应用程序的资源。 加速键也引发 WM_COMMAND 消息。 加速键资源表： 将菜单项ID 和键或某些键组合对应起来。 MFC 集合类 调试 TRACE 宏将从列表中获得的字符串输出到调试输出窗口。 数组类 CArray 类， 它实际上是一个模板类，利用它可以创建任何数据类型的类型安全数组。 动态调整大小。 array.SetSize(10); SetAt(), SetAtGrow(); InsertAt 和 RemoveAt 函数使得数组添加和删除元素项非常简便， 但是消耗资源。 链表类 MFC 的模板类 CList 实现了一般的链表， 用它可以定义处理任何数据类型。 优势： 插入、删除操作高效。 CList&lt;CPoint, CPoint &amp;&gt; list; 第一个模板参数指定了数据类型（CPoint 对象）， 第二个参数指出参数列表中列表项的传送方式（通过引用）。 映射表 映射表的工作方式： 最大化操作效率的关键是最小化查找要检查项目的数量。 哈希表是数组和链表的结合体， 结合了数组的快速查询的有限又能融合链表方便快捷的增加删除元素的优势。 类型指针类 Ptr 和 ob 的 MFC 集合类可以方便地实现保存一般（void）指针的容器和保存指向 MFC 对象指针的容器。 CTypedPtrArray // 管理指针数组 CTypedPtrList // 管理指针链表 CTypedPtrMap // 管理使用指针作为项目或关键字的映射表。 所有保存指针的 MFC 集合类， 它们从数组、列表或映射表删除指针， 但绝不会删除指针所指的项目。 文件 I/O 和串行化 CFile 类 调用函数前加”::”，代表调用的是全局函数，不是类自己的成员函数. 串行化基础 在文件上写一对整数， 名为 a 和 b， 为了实现这个要求 一种方法是对每一个整数都调用 CFile::Write(). 另一种方法是创建一个 CArchive 对象， 并把它与该 CFile 对象关联起来，然后运用 &lt;&lt; 运算符把整数串行化到档案中。 编写可串行化类 序列化和反序列化序列化在面向对象的程序设计中出现的，它基于对象是可以连续的思想， 在程序退出或者启动的时候，可以把对象顺序的存储在磁盘或者从磁盘读出，可出和读出对象的过程叫做序列化。 序列化机制分为序列化和反序列化，序列化是把内存中的对象以二进制文件的形式存储在磁盘中。 反序列化是把序列化后生成的文件恢复到内存。 如果应用程序没有进行直接磁盘操作的输入输出，而是依靠序列化的过程，那么就不必直接使用 CFile 对象。 要实现一个能够序列化的类,必须要经过一下几步 1.这个类必须间接火直接地由 CObject 派生而来 2.定义一个不带参数的构造函数 3.在头文件中,必须有如下声明: DECLARE_SERIAL( Your name of class) 4.在源文件中开头有如下声明 IMPLEMENT_SERIAL (Your nameofclass,CObject,1) 其中的第三个参数代表版本号 5.必须重载基类中的序列化函数Serialize 经过以上五步,一个带有存储功能的类就诞生了 CObject 类 在 CObject 类中定义了基本的序列化协议和功能。 序列化的类可以直接或间接从 CObject 类派生， 类的声明中必须包含 DECLARE_SERIAL 宏调用， 实现文件也必须有与之对应的宏。 CObject 类提供了一个 Serialize（CArchive &amp;ar）的函数， 告诉程序，在序列化的时候我们需要保存类的哪些成员变量。 CArchive 对象 MFC 库中文档类的 Serialize 函数 和 CFile 对象之间有一个 CArchive 对象。 该对象为 CFile 对象缓冲数据并保持一个内部标志，来指明是存储或者加载对象。 MFC 应用程序框架负责 CFile 和 CArchive 对象构造及关联。 在自动生成的菜单 FileOpen 和 FileSave 等过程中， 应用程序框架会调用文档的 Serialize 函数， 我们可以在该函数处理特定类对象的序列化。 CObArray 对象 CObArray 对象类似与数组的类，它可以实现动态保存 CObject 的对象。我们在程序中将所有要保存的类的对象都实现在存储在 CObArray 类的对象 m_ObArray 中， 文档串行化中的 CArchive 重载的操作符。ar&lt;&lt;其实就是向文件写入 对话框的样式为下层 学生文件类，文件定义一个全局对象。 学生记录类包括： 个人信息类， 分数类， 电话号码类， 地址类。 操作符重载 &lt;&lt; / &gt;&gt; 个人信息类： 姓名， 性别， 出生日期，民族，国籍，学历 分数类：语文，英语，数学，物理 电话号码类： 手机，家庭电话，学校电话 地址类： 家庭地址， 学校地址 文档视图结构文档视图结构： 是程序中数据于它的显示的形式和用户交互分离出来。 文档仅仅是程序数据的抽象表示。 CView::GetDocument 函数 视图对象只有一个与之相联系的文档对象，它所包含的 GetDocument 函数允许应用程序由视图得到与之相关联的文档。 CDocument::UpdateAllViews 函数 如果文档中的数据发生了改变，那么所有视图都必须被通知到，以便它们能够对所显示的数据进行相应的更新。 CView::OnUpdate 函数 当应用程序调用了 CDocument::UpdateAllViews 函数，应用程序框架就会相应地调用各视图的 OnUpdate 函数 CView::OnInitialUpdate 函数 当应用程序被启动时，该 CView 函数会自动调用 CDocument::OnNewDocument 函数 设置设置文档数据成员初始值的地方。 开始，序列化读出文件信息。指定文档后， 调用文档对象 CDocument::OnOpenDocument() 虚函数 虚函数如果语法允许你产生一个不应该有的抽象对象，或如果语法不支持「把所有形状（不管什么形状）都 display 出来」的一般化动作，这就是个失败的语言。 为了支持这种能力，C++ 提供了所谓的虚函数（virtual function）。 Win 32 API 包含成千上万个函数， 应用程序可以调用它们执行多种任务，例如：创建一个窗口、画条线、以及对文件进行输入/输出处理。 在 C 语言中， 窗口过程一般作为一个巨大的函数实现，该函数包含一个很大的 switch 语句为每一个消息都提供一个选项。 消息以调用一个窗口过程的形式以表明自己的存在。 窗口句柄是一个唯一标识窗口的32位值。在内部，该值引用一个数据结构， Windows 在其中存储着有关窗口的信息， 例如窗口的大小、风格极其在屏幕上的位置。 消息 ID 是用来标识消息类型的一个数值。 Windows 是一个事件驱动、基于消息的操作系统。 消息是在系统中发生的任何事情的核心，对于一个应用程序，几乎没有哪个操作不是接受消息的直接的结果。 LIST 实现降序 class score_msg { public: int id; string name; int ranking; int total; float chinese; float math; float english; float physics; public: bool operator &gt; (score_msg b) const { return this-&gt;total &gt; b.total; } bool operator &lt; (score_msg b) const { return this-&gt;total &lt; b.total; } }; // 排序操作 greater&lt;score_msg&gt; pt; file.sls.sort(pt);]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++Primer]]></title>
    <url>%2F2018%2F12%2F02%2FC%2B%2BPrimer%2F</url>
    <content type="text"><![CDATA[Variables and Basic TypesC++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably. To support 「separate complication」, C++ distinguishes between declaration and definition. The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. 1. Main Function and Library「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main. Standard library collection of types and function that every C++ compiler must support. They also tend to refer to particular part of the library by referring to a library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes. By default, reading cin flushes cout, cout is also flushed when the program end normally. To handle input, we use an object of type istream named cin, This object is also referred to as the standard input. In C++ an expression yields a result. When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1. The word 「nullptr」 is a pointer literal. The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand. To attain a declaration that is not also a definition, add the 「extern」 keyword. An extern that has an initializer is a definition. 2. Variables Initialization Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one. Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class. We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer. Separate compilation lets us split our programs into several files, each of which can be compiled independently. Declaration and Definition To support separate compilation, C++ distinguishes between declarations and definitions. To obtain a declaration that is not also a definition, we add the extern keyword and may not provide an explicit initializer: extern int i; // declares but does not define i int j; // declares and defines j Variables must be defined exactly once but can be declared many times. To use a variable in more than one file requires declarations that are separate from the variable’s definition. To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files that use that variable must declare—but not define—that variable. Reference A reference is not an object. Instead, a reference is just another name for an already existing object. A reference must be initialized A reference may be bound only to an object, not to a literal or to the result of a more general expression: Unlike a reference, a pointer is an object in its own right. Unlike a reference , a pointer need not be initialized at the time it is defined. references are not objects, they don’t have addresses. Hence, we may not define a pointer to a reference. 3. Pointer Pointer Value The types must match because the type of the pointer is used to infer the type of the object to which the pointer points. It can be a null pointer , indicating that it is not bound to any object. Using a Pointer to Access an object When a pointer points to an object, we can use the dereference operator (the * operator) to access that object: We may dereference only a valid pointer that points to an object. Dereferencing a pointer yields the object to which the pointer points. Null Pointers A null pointer does not point to any object. Older programs sometimes use a preprocessor variable named NULL, which the cstdlib header defines as 0. nullptr is a literal that has a special type that can be converted to any other pointer type. Modern C++ programs generally should avoid using NULL and use nullptr instead. void* Pointers The type void* is a special pointer type that can hold the address of any object. We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object. Understanding Compound Type Declarations A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types Reference to Pointers A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer. int i = 42; int *p; // p is a pointer to int int *&amp;r = p; // r is a reference to the pointer p r = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i *r = 0; // dereferencing r yields i, the object to which p points; changes i to // the base type of the declaration says that r is a reference to a pointer to an int. It can be easier to understand complicated pointer or reference declarations if you read them from right to left. 4. const QualifierBy Default, const Objects Are Local to a File We want to define the const in one file, and declare it in the other files that use that object. To share a const object among multiple files, you must define the variable as extern. References to const const int ci = 1024; const int &amp;r1 = ci; // ok: both reference and underlying object are const r1 = 42; // error: r1 is a reference to const int &amp;r2 = ci; // error: non const reference to a const object Initialization and Reference to const In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression A Reference to const May Refer to an Object That Is Not const int i = 42; int &amp;r1 = i; // r1 bound to i const int &amp;r2 = i; // r2 also bound to i; but cannot be used to change i r1 = 0; // r1 is not const; i is now 0 r2 = 0; // error: r2 is a reference to const const Pointers and Pointer to const Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const. We use the term top-level const to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that const as a low-level const. The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored int errNumb = 0; int *const curErr = &amp;errNumb; // curErr will always point to errNumb const double pi = 3.14159; const double *const pip = &amp;pi; // pip is a const pointer to a const object On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects. int *p = p3; // error: p3 has a low-level const but p doesn&#39;t p2 = p3; // ok: p2 has the same low-level const qualification as p3 constexpr and Constant Expressions A constant expression is an expression whose value cannot change and that can be evaluated at compile time. Such functions must be simple enough that the compiler can evaluate them at compile time. Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions. Pointers and constexpr const int *p = nullptr; // p is a pointer to a const int constexpr int *q = nullptr; // q is a const pointer to int The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines. constexpr int *np = nullptr; // np is a constant pointer to int that is null int j = 0; constexpr int i = 42; // type of i is const int // i and j must be defined outside any function constexpr const int *p = &amp;i; // p is a constant pointer to the const int i constexpr int *p1 = &amp;j; // p1 is a constant pointer to the int j 5. Dealing with Types Type Aliases Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used. We can define a type alias in one of two ways. Traditionally, we use a typedef typedef char *pstring; const pstring cstr = 0; // cstr is a constant pointer to char const pstring *ps; // ps is a pointer to a constant pointer to char When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char, the base type is char and the is part of the declarator. The auto Type Specifier Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer. The decltype Type Specifier Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable. For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand. The compiler analyzes the expression to determine its type but does not evaluate the expression: decltype(f()) sum = x; // sum has whatever type f returns const int ci = 0, &amp;cj = ci; decltype(ci) x = 0; // x has type const int decltype(cj) y = x; // y has type const int&amp; and is bound to x decltype(cj) z; // error: z is a reference and must be initialized decltype and References Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment // decltype of an expression can be a reference type int i = 42, *p = &amp;i, &amp;r = i; decltype(r + 0) b; // ok: addition yields an int; b is an (uninitialized) int decltype(*p) c; // error: c is int&amp; and must be initialized // decltype of a parenthesized variable is always a reference decltype((i)) d; // error: d is int&amp; and must be initialized decltype(i) e; // ok: e is an (uninitialized) int // The type is a reference to the type of the left-hand operand. int a = 3, b = 4; decltype(a) c = a; decltype(a = b) d = a; // equal to :int &amp;d = a; Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression. 6. Defining Our Own Data StructuresIn C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes. Defining the Sales_data Type struct Sales_data { std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body. It is a common mistake among new programmers to forget the semicolon at the end of a class definition. Writing Our Own Header Files In order to ensure that the class definition is the same in each file, classes are usually defined in header files. classes are stored in headers whose name derives from the name of the class. Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations. A Brief Introduction to the Preprocessor The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs. Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header. Preprocessor variables have one of two possible states: defined or not defined. The #define directive takes a name and defines that name as a preprocessor variable. #ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined. If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif. Preprocessor variable names do not respect C++ scoping rules. Preprocessor variables, including names of header guards, must be unique throughout the program. 7. Defined Termsconst reference Colloquial synonym for reference to const. constant expression Expression that can be evaluated at compile time. declaration Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared. definition Allocates storage for a variable of a specified type and optionally initializes the variable. object A region of memory that has a type. A variable is an object that has a name.outer scope Scope that encloses another scope. preprocessor variable Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled. reference An alias for another object. struct Keyword used to define a class. typedef Defines an alias for another type. void* Pointer type that can point to any nonconst type. Such pointers may not be dereferenced. Strings, Vectors, and ArraysC++ defines a rich library of abstract data types. Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections. Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector. The built-in types represent facilities present in most computer hardware, such as numbers or characters. The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly. A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type. 1. Namespace using DeclarationHeaders Should Not Include using Declarations. If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts. 2. Library string TypeA string is a variable-length sequence of characters. To use the string type, we must include the string header. When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the =, we use direct initialization. string s5 = &quot;hiya&quot;; // copy initialization string s6(&quot;hiya&quot;); // direct initialization string s7(10, &#39;c&#39;); // direct initialization; s7 is cccccccccc The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered. Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator. Adding Literals and strings When we mix strings and string or character literals, at least one operand to each + operator must be of string type Dealing with the Characters in a string In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c. The c indicates that the header is part of the C library. Processing Every Character? Use Range-Based for If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」. The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in declaration is initialized from the value of the next element in expression. Using a Range for to Change the Characters in a string If we want to change the value of the characters in a string, we must define the loop variable as a reference type. string s(&quot;Hello World!!!&quot;); // convert s to uppercase for (auto &amp;c : s) // for every char in s (note: c is a reference) c = toupper(c); // c is a reference, so the assignment changes the char in s cout &lt;&lt; s &lt;&lt; endl; a subscript The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position. Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1]. The value in the subscript is referred to as 「a subscript」 or 「an index」. The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined. 3. Library vector TypeA vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」. Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions. The process that the compiler uses to create classes or functions from templates is called 「instantiation」. vector&lt;int&gt; ivec; // ivec holds objects of type int vector&lt;Sales_item&gt; Sales_vec; // holds Sales_items vector&lt;vector&lt;string&gt;&gt; file; // vector whose elements are vectors 「vector is a template, not a type.」 Types generated from vector must include the element type. NoteConventions for Variable Names：变量名称的约定 separate compilation：独立编译 tend to：倾向于 fits in：适合 so far：目前为止 the indicated value: 指定的值 yields a result : 产生一个结果 bound to (bind to) :绑定 plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析 evaluated : 求…值 do not respect C++ scoping rules: 不遵守作用域规则 be used to： 用于 associative:联合 container:容器，集装箱 derived-Class: 派生类/子类 alias:别名 override: 重写 overloading: 重载 directive:指令 redirect: 重定向 indicator:指示 arguments: 实参 library facility:库功能 (工具库) statements:语句 extensive: 大规模 mechanisms: 机制 string literal: 字符串字面量 semicolon: 分号 block: 代码块 iteration: 重复 comments: 注释 built-in type： 内置类型 backslash： 反斜杠 carriage return： 回车 Escape Sequences: 转义序列 initializer: 初始化 commas： 逗号 type specifier: 类型说明符 Identifiers: 标识符 inclusive：包括 Nested Scopes：嵌套范围 fetch: 获取 type modifiers: 类型修饰符 underlying: 底层 Qualifier: 限定符 plain: 原始,素 synonym: 同义词 groups: 分组 implement：实现 strategy：a plan of action 策略 contents:内容 cover: 介绍 / 覆盖 punctuation: 标点 capitalize: 大写字母 subscript：下标]]></content>
      <categories>
        <category>原版书籍</category>
      </categories>
      <tags>
        <tag>原版书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硅谷来信]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[收获比较大的方面： 学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。 科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 结论可以证实，但不可证伪。为什么呢？ 就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？ 总之， 因为未来的不确定，结论可以证实，不能证伪。 别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。 语录： 对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法精解]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[编程规范 #ifndef LIST_H #define LIST_H /* funciton process result */ typedef enum Result_ { FALSE = -1, TRUE = 0 }Result; /* Define a structure for linked lists */ typedef struct ListElmt_ { void *data; struct ListElmt_ *next; }ListElmt; /* Define a structure for linked lists */ typedef struct List_ { int size; ListElmt *head; ListElmt *tail; int (*match)(const void *key1, const void *key2); void(*destroy)(void *data); }List; /* Public Interface */ void list_init(List *list, void(*destroy)(void *data)); void list_destory(List *list); int list_ins_next(List *list, ListElmt *element, const void *data); int list_rem_next(List *list, ListElmt *element, void **data); void list_destory(List *list); /* role : inline function*/ #define list_size(list) ((list)-&gt;size) #define list_head(list) ((list)-&gt;head) #define list_tail(list) ((list)-&gt;tail) #define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0) #define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0) #define list_data(list) ((list)-&gt;data) #define list_next(list) ((list)-&gt;next) #endif /* list.c */ #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &quot;list.h&quot; /* list_init */ void list_init(List * list, void(*destroy)(void *data)) { /* Initialize the list. */ list-&gt;size = 0; list-&gt;destroy = destroy; list-&gt;head = NULL; list-&gt;tail = NULL; return; } /* list_destory */ void list_destory(List *list) { void *data; /* Remove each element */ while (list_size(list) &gt; 0) { if (list_rem_next(list, NULL, (void**)&amp;data) == 0 &amp;&amp; list-&gt;destroy != NULL){ /* Call a user-defined function to free dynamically data */ list-&gt;destroy(data); } } /* No operations are allowed now, but clear the structure as a precautions */ memset(list, 0, sizeof(List)); return; } /* list_ins_next */ /* The ListElmt *element has the next pointer information , the next pointer is not null */ int list_ins_next(List * list, ListElmt * element, const void * data) { ListElmt *new_element; /* Allocate storage for the element */ if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) { return -1; } /* Insert the element into the list */ new_element-&gt;data = (void *)data; if (element == NULL) { /* Handle insertion at the head of the list */ if (list_size(list) == 0) list-&gt;tail = new_element; new_element-&gt;next = list-&gt;head; list-&gt;head = new_element; } else { /* Handle insertion somewhere other than at the head */ if (element-&gt;next == NULL) list-&gt;tail = new_element; new_element-&gt;next = element-&gt;next; element-&gt;next = new_element; } /* Adjust the size of the list to account for the inserted element */ list-&gt;size++; return 0; } /* list_rem_next */ int list_rem_next(List *list, ListElmt *element, void **data) { ListElmt *old_element; /* Do not allow removal an empty list */ if (list-&gt;head == NULL) return -1; /* Remove the element from the list */ if (element == NULL) { /* Handle removal from the head of the list */ *data = list-&gt;head-&gt;data; //Generic pointer old_element = list-&gt;head; list-&gt;head = list-&gt;head-&gt;next; if (list_size(list) == 1) list-&gt;tail = NULL; } else { /* Handle removal from somewhere other than the head */ if (element-&gt;next == NULL) return -1; *data = element-&gt;next-&gt;data; old_element = element-&gt;next; element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember. } /* Free the storage allocated by the abstract datatype */ free(old_element); /* Adjust the sizeof the list to account for the removal element */ list-&gt;size--; return 0; } 使用链表的例子： 页帧管理​ 泛型指针 很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型 泛型指针和句柄的差别个人理解： 设计者： 设计函数的人 调用者： 调用函数的人 void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。 句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暗时间]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%9A%97%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[暗时间 善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。 如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“暗时间”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。 能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？（思维方式） 能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。 因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。 设计你自己的进度条 进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。 善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。前阵子流行的 GTD 方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。 其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。 饿死在干草堆之间的驴子（选择问题） 面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。 但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。 所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。 如何有效地记忆与学习 你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。 整理笔记：经常整理你的笔记——如果你没有做笔记，现在就开始——整理之前的笔记一来巩固已经淡化的记忆，二来给你重新审视知识的机会。我常常发现对知识的首次记忆往往是有偏颇的，或者只看到了一个方面，或者只关注了一个点，一段时间之后再回来看往往能够和这段时间以来的一些新思考和知识结合起来，得到更多的东西。留心一下你会发现记忆实际上是很脆弱的东西，而且我们对事物的首次理解几乎肯定是不深入的。 书写：将一段时间学习的知识按照一个主题系统地“串”起来大大地丰富了知识之间的关联，平添无数提取线索。 学习密度与专注力 其实，在大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家。而生活中太多的分散注意力的因素：游戏、篮球、选修课、女朋友… 要想集中注意力对一个单一的目标猛下功夫，其实还是相当有难度的。这个难度并非来自自制力，如果一个人要靠自制力去强迫自己不受干扰，那只能说还是寻常人(mediocre)。真正的效率源自于内心对一个东西强烈的热忱，也就是我们俗称的追求，这时候从表层意识到深层意识都关注在这件事情上面，脑细胞高度活跃，才能创造最大的效率。 专注力为什么会对学习效率造成这么大的影响。这来源于两个方面，一是专注于一件事情能让表层意识全功率运作，这个是显式的效率。第二点，也是更重要的，它还能够使你的潜意识进入一种专注于这件事情的状态。如果表层意识和潜意识都能专注同一件事情，也就是俗称的完全投入，这个时候的效率就能double。此外这种专注成了一种习惯之后，就容易在很短时间之内把自己的潜意识带入到一种关注的“惯性”中，于是即便表层意识的注意力已经移开了，然而潜意识仍在继续关注原来的问题。比如你可能有这样的经历，学习一首歌曲，一开始的时候并没有完全学会，然后你就去忙别的事情了，一个星期之后想起这首歌曲，居然发现原来难学会的几个地方突然会哼了；或者思考一个问题，一开始的时候总有一个地方没有思考出来，然后你就先放着了，几天之后回想这个问题，突然发现一切都清晰了。这就是潜意识的效率，它能在你不知不觉中把时间利用起来。 一个习惯于专注事情的人不管做什么事情都容易并迅速进入一种专注的状态。既然是一种习惯，就能够培养，金出武雄在《像外行一样思考，像专家一样实践——科研成功之道》里面提到“思维体力”的概念，所谓思维体力就是能够持续集中注意力的时间，注意力造就非凡专家，天才来源于长期的专注的训练。培养你的思维体力，是成为非凡专家的一个必要条件。除了培养专注的习惯之外，还可以通过另一个充分条件来实现专注力，即做自己喜欢做的事。我们从小对自己喜欢做的事情都是极其专注的，当然，即使长大了之后，仍然还是某种程度上保留了这种专注的能力，只不过因为种种外界因素，长久专注的能力反而削弱了，要考虑房子，要考虑业绩，要考虑小孩，要考虑医疗保险…这些让人焦虑的事情会积压在潜意识当中，总是在影响你专注做事，削弱你人生的效率。 一直以来伴随我的一些学习习惯学习与思考 Google &amp; Wiki（遇到问题做的第一件事情，也是学习某个东西做功课（homework）最先用到的东西。 做读书笔记。一是将自己阅读的时候的思考（包括闪念）总结下来，二是将书中的好例子摘抄下来。（这个习惯是一年前才养成的，发现受益极大。）有了 google note，笔记可以加上tag，非常便于回顾，加深理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上（后两者常常也是相关的）。 提到思考，我有一个小习惯。利用走路和吃饭的时候思考，还有睡觉前必然要弄一个问题放在脑子里面，在思考中迷糊入睡。发现这样一来往往在不知不觉中多出来大量的思考时间。 将思考成为习惯还有一个很大的好处——避免焦虑。 重要的事情营造比较大的时间块来完成。比如一本好书，或者一个重要的知识点，最好不要切得太琐碎了看，否则看了后面忘了前面。不利于知识的组织&amp;联系。 多看心理学与思维的书，因为它们是跨学科的。知识分两种，一是我们通常所谓的知识，即领域知识。二是关于我们的大脑吸收知识的机制的知识，后者不妨称为元知识。虽说这也是领域知识，但跟其它的领域知识不同的是，它指导着我们学习其它所有的领域知识。 学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。 获得的多少并不取决于读了多少，而取决于思考了多少、多深。 善于利用小块时间，也就是《奇特的一生》中所说的“时间下脚料”，如何利用前面有几个方法。同时，也善于创造整块时间（如通过要事优先）。 时间管理 学习和思考的过程中常问自己的几个问题： 你的问题到底是什么？. OK，到现在为止，我到底有了什么收获呢？时常反省和注意自己的思维过程。养成反驳自己的想法的习惯。 重视知识的本质：对于程序员来说这一点尤其重要，程序员行业的知识芜杂海量，而且总是在增长变化。很多人感叹跟不上新技术。应对这个问题的办法只能是：抓住不变量。大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时。算法数据结构永远都不过时。基本的程序设计理论永远都不过时。良好的编码习惯永远都不过时。分析问题和解决问题的能力永远都不过时。强大的学习能力和旺盛的求知欲永远都不过时。你大脑的思维方式永远都不过时。 重视积累的强大力量，万事提前准备：计划订长一点，自然就可以多获得准备的时间。设想你若干年后会在做什么事情，需要哪些技能，现在就开始准备。一个5年计划便可以让你获得从现在开始的5年准备时间。5年中每天腾出半个到一个小时专心于某一件事情，认准一个方向，每次走一点，其实不要说5年，两年就会发现会起到宏大的效应。 抬起头来：人的思维是非常容易只见树木不见森林的（否则这个成语从哪来的呢？）。时不时抬起头来审视一下自己正在做的事情，问一问它（对现在或未来）有什么价值，是不是你真正希望做的。你学到的东西到底是什么？它们重要吗？你需要在这个时候学习这些吗？（见第2条）。你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。仅仅遵循兴趣是不够的，人会对很多次要的东西产生兴趣，并一头钻进去浪费好多时间。所以判断一个东西值不值得学习是很重要的。（兴趣偏差） 有时间吗？总结总结最近得到的新知识吧。一般来说，我在一段时间内学习的一些东西总是会在这段时间内一直在脑子里打转，一有时间空隙（譬如走路，吃饭）它们就会自己蹦出来，促使我去进一步思考和总结。永远不要认为对一个知识的把握足够深刻，“理解”的感觉很多时候只是假象。学会反问自己对知识到底把握了多少，是很有价值的。 有时间吗？看本书吧。（传统的）阅读和思考永远优于所谓的在互联网上汲取新知识，后者往往浅表、不系统、乃至根本没价值。 制定简要的阅读计划：选出最近认为对你最有价值的书，先总览一下，决定阅读的顺序（哪些章节可以优先阅读）。然后每天看一点。并利用走路、吃饭、乘车或其他不适合带着书和笔的时间来总结看过的内容，建立知识结构，抽取知识本质，与以往的大脑中的知识建立联系。 阅读方法 趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去。万事开头难，因为从不了解到了解基本的一些事实，是一个新知识暴涨的阶段，这个时候的困难是最大的。有人熬不过去，觉得困难太大就放弃了。 根据主题来查阅资料，而不是根据资料来查阅主题。以前读书的时候是一本一本的读，眼里看到的是一本一本的书，现在则是一章、甚至一节一节的读，眼中看到的不是一本一本的书，而是一堆一堆的章节，一个一个的知识主题，按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。 学习一个东西之前，首先在大脑中积累充分的“疑惑感”。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到解答之后印象就越深刻。记得大学里面的课本总是瀑布式地把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完了很快又忘掉了，为什么？因为没有带着疑问去学习。 有选择地阅读。很多人觉得我读书速度很快，其实我只是有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读。二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的（譬如《黑天鹅》），那么1. 现象是什么？2. 解释是什么？3. 支撑这个解释的理由是什么？4. 例子是什么？一般来说，这一二三四用不了多少字就可以写完了（如果假设只举一到两个精到的例子的话），这样的无废话著作的典型是《合作的进化》；那为什么有些书，明明核心观点就那点东西（顶多加上几个精要的例子罢了）却写得长得要命呢？因为人的思维都有一个“联想”的特点，写着写着就容易旁逸斜出，而且作者自己也往往觉得引申出去挺牛逼，有时候很多与主题无关的废话就掺和进来了；那么，阅读的时候就应该有选择性地滤掉这些不相干的废话；此外还有一种可能性就是大量冗余的例子。一般来说组织得比较好的书会有详细且一目了然的目录和索引，根据目录首先就可以滤掉一部分（比如某个子章节的内容你以前是看过的），然后有时候作者还会举很多冗余的例子，如果你已经觉得印象够深刻了这些例子完全可以不看（一些书就非常厚道地对每个观点只辅以一两个最最经典的例子，譬如《与众不同的心理学——如何正视心理学》，这样的书我最是喜欢）。（有选择阅读） 知识结构 抓住不变量： 把知识分为essential的和non-essential的。对于前者采取提前深入掌握牢靠的办法，对于后者采取待用到的时刻RTM (Read the manual)方法（用本）。 思维改变生活 如何区分essential和non-essential的知识想必绝大多数时候大家心里都有数，我举几个例子：对程序员来说，硬件体系结构是essential的，操作系统的一些重要的实现机制是essential的，主流编程范式（OO、FP）是为了满足什么需求出现的（出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景）。这些我认为都是essential的。我想补充一点的是，并不是说硬件体系结构就要了解到逻辑门、晶体管层面才行（其实要了解到这个层面代价也很小，一两本好书就行了），也并不是说就要通读《Computer Architecture: Quantitative Approach》才行。而是关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）。《Computer Systems: A Programmer’s Perspective》就是为此目的，针对程序员的需求总结出那些essential knowledge的好书。（写下来，理性分析） 我们对于事物的思考深度常常是不够的，在浅层次的思考了之后，如果我们的情绪系统或者直觉已经给出了倾向，那么很少有人会继续深入地思考，而开始转向着手行动。这种匆忙的态度往往是失败的起源，在碰壁了之后，我们被动地“让事实告诉了我们”某方案是行不通的，让事实替代我们进行了思考和推理，我们从失败当中获得了信息，知道了为什么之前的方法是不恰当的，这就是一些时候我们认为要亲身经历才能明白的原因。然而，这并不意味着任何时候我们都只能“做了之后才发现…”，人类最强大的能力就是社会学习—— 普通人从自己的错误中学习，聪明人从别人的错误中学习。 人类最强大的另一个能力则是归纳和推理—— A few lines of reasoning can change the way we see the world. (via) 我们可以仔细地，理性地思考、权衡各个选择的利弊，而不仅仅满足于情绪上的判断。 假设我们面临两个选择，A和B，我们可以结合别人的经历，利用自己的推理能力，去分别推断A或B选项带来的各种各样可能的利弊，对于其中不确定的因素我们或者可以进一步从别人那里收集更多的信息来使得判断更靠谱，或者可以对风险的上下界进行一些估计，总之，我们尽量去让我们大脑中假想的角色去经历失败——我们通过推理发现某条路行不通，就避免了现实中去碰一鼻子灰。 书写是为了更好地思考 我经常在走路和睡前总结所学过的内容，思考遗留的问题，一段时间的阅读和思考之后，一个总体的知识框架就会逐渐浮现在脑海中。然后我会将它书写下来，然而，我往往非常惊讶地发现，当我书写的时候，新的内容仍然源源不断的冒出来，就像我的键盘自己也会思考一样。（总写学过的知识） 遇到问题为什么应该自己动手 有一个很不错的概念叫做“Unknown Unknown”，大意是如果你不知道一个东西的话，你也不会知道你自己不知道它。很多时候新知识就有这个特性——掌握了之后觉得很明白，掌握之前却觉得“不可能啊”、“这简直没有解嘛”。在这样的认知之下，你自然会高估前方的困难、风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为Unknown Unknown，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。（不知道自己不知道的） 用最小的代价解决手头的问题”——这里的问题在于，难道我们计算收益的时候仅仅考虑是否解决了手头的问题吗？如果解决的过程中得到了其他的收益呢？为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。（额外的收益） 什么才是你的不可替代性&amp;核心竞争力知识技能组合是具有相当程度的不可替代性的： 专业领域技能：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。 跨领域的技能：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind 等等 学习能力：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。 性格要素：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等。 鱼是最后一个看到水的 《设计模式》被许多初学者奉为圭臬，认为那些看上去精巧的东西才是真正牛13的，值得学习的。而且，更聪明一点的人甚至会唯恐学的东西还不够复杂，因为越是复杂的东西搞出来越是有成就感。然而事实是，把简单的事情搞复杂的人比比皆是，把复杂的事情搞简单的人凤毛麟角。（不要把简单事情搞复杂） 避免思维被一门语言束缚的最好办法就是“学习其它语言”。 知其所以然 包含了多得多的知识：记一个算法，就只有一个算法。一个萝卜一个坑。就好比背99乘法表只能解决乘法问题一样。而记背后的思想，却有助于解决一类问题。思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。算法诞生过程中的思路往往包含了比实际算法更本质得多的知识，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。（分析推理） 重在分析推理，而不是联想：学了一大通算法和数据结构之后的一个副作用就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的思维捷径，在任何时候都会抢占大脑的工作记忆，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维最重要的特征。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。 习惯 也许，对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败而领悟的，还是看到书上或听到别人说的）写下来，并常常拿出来翻看。事实上，我的经验是，在写下来的时候我们的大脑会进入到理性分析模块，进一步检验和推理那些道理，我们越是对一个道理审视的详细、深入、全面，大脑中留下的印象深刻，从记忆加工的角度来说，这叫深度加工，带来的结果就是该记忆与更多的提取线索相关联，于是便能够在更多的场景下被唤起（而不是被以往的习惯直接覆盖） note: 俗语有谋事在人，成事在天的说法。其实这话说的是，我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果。不要奢望你努力了就绝对会成功，你不会。更不要以这个理由来作为不去努力的原因，因为不去努力，那就永远不会成功。 生活中一抓一大把。俗语云“公说公有理，婆说婆有理。”你敢于表达自己的观点，他说你喜欢炫耀。你韬光养晦呢，他又说你夹着尾巴做人；你为自己的成就骄傲一下，他说你得意忘形。你低调做人呢，他又说你怎么这么没种；你说彪悍的人生不需要解释，他说你自大狂。你说做人贵有自知之明呢，他又说你丫做人怎恁费劲捏？…]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[for循环常用写法date: 2018-09-27 11:03:38 void main() { int i = 0; int a[20]; int len = 10; int pos = 5; i = i - 1; /*结果:i = -1; 不是溢出.*/ printf(&quot;i = %d\n&quot;, i); /*数组赋值*/ for (i = 0; i &lt; len; i++) a[i] = i + 1; printf(&quot;\n&quot;); /*逆序打印*/ for (i = len-1; i &gt;=0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*插入元素, 往后移动元素(倒序循环)*/ for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/ { a[i+1] = a[i]; /*表示最后要插入a[6] = a[5] */ } a[5] = 0; len = len + 1; /*逆序打印*/ for (i = len-1; i &gt;= 0; i--) printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); /*删除元素, 往前移动(正序循环)*/ for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/ { a[i] = a[i+1]; } len = len - 1; /*逆序打印*/ for (i = len - 1; i &gt;= 0; i--) //倒序循环 printf(&quot;%d &quot;, a[i]); printf(&quot;\n&quot;); printf(&quot;\n&quot;); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } /* 总结: 符号要注意区分, 正序循环&lt; 和 倒序循环&gt; A: 正序循环 for(i=0; i&lt;len; i++) for(i=1; i&lt;=len; i++) B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号 for(i=len; i&lt;0; i--) */ 循序栈和链式栈date: 2018-09-25 15:54:15 stack的采用模型： 线性表的链式存储：头插法 线性表的顺序存储：尾插法 线性表顺序存储和链式存储date: 2018-09-23 19:46:15 单独把结点的指针域 声明成结构体数据类型， 指针指向谁， 就把谁的地址赋给指针。 note: wrong: current-&gt;next = node-&gt;next; node = current-&gt;next; // what is wrong? node is not pointer filed and can&#39;t be assigned. right: node-&gt;next = current-&gt;next; current-&gt;next = node; LinkList Test FrameWork #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &quot;linklist.h&quot; typedef struct Teahcer { LinkListNode *node; int age; int name[64]; }Teacher; void main() { int len = 0; int i = 0; Teacher *tmp = NULL; LinkList *list = NULL; //note: list is handle that is void type. list = LinkListCreate(); Teacher t1, t2, t3, t4, t5; t1.age = 31; t2.age = 32; t3.age = 33; t4.age = 34; t5.age = 35; list = LinkListCreate(); LinkListInsert(list, (LinkListNode*)&amp;t1, 0); LinkListInsert(list, (LinkListNode*)&amp;t2, 0); LinkListInsert(list, (LinkListNode*)&amp;t3, 0); LinkListInsert(list, (LinkListNode*)&amp;t4, 0); LinkListInsert(list, (LinkListNode*)&amp;t5, 0); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); //note: This function deletes LinkList element at the position. LinkListDeleteElement(list, 2); printf(&quot;After delete element. \n &quot;); len = LinkListGetLength(list); for (i = 0; i &lt; len; i++) { tmp = (Teacher*)LinkListGetElement(list, i); if (tmp != NULL) { printf(&quot;age: %d &quot;, tmp-&gt;age); } } printf(&quot;\n&quot;); LinkListClear(list); printf(&quot;hello.&quot;); system(&quot;pause&quot;); } linklist.h #pragma once #ifndef _LINKLIST_H #define _LINKLIST_H #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #endif /* LinkList API */ typedef void LinkList; typedef struct _tag_LinkListNode { struct _tag_LinkListNode *next; }LinkListNode; //Node type It&#39;s a great heavest for me.. LinkList *LinkListCreate(); int LinkListClear(LinkList *list); LinkListNode * LinkListGetElement(LinkList *list, int pos); int LinkListInsert(LinkList *list, LinkListNode *node, int pos); int LinkListDeleteElement(LinkList *list, int pos); int LinkListGetLength(LinkList *list); linklist.c #include &quot;linklist.h&quot; typedef struct _tag_LinkList { LinkListNode header; int length; }TLinkList; //It&#39;s still LinkListNode type. LinkList *LinkListCreate() { TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory. if (ret == NULL) { return NULL; } ret-&gt;length = 0; ret-&gt;header.next = NULL; return ret; } int LinkListClear(LinkList *list) { if (list == NULL) { return 0; } TLinkList *tlist = (TLinkList *)list; free(tlist); return 0; } LinkListNode * LinkListGetElement(LinkList *list, int pos) { int i = 0; TLinkList *tlist = NULL; LinkListNode *current = NULL; LinkListNode *ret = NULL; tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type); current = &amp;tlist-&gt;header; if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } ret = current-&gt;next; return ret; } int LinkListInsert(LinkList *list, LinkListNode *node, int pos) { int i = 0; TLinkList *tlist = (TLinkList*)list; //transfrom LinkListNode *current = NULL; LinkListNode *ret = NULL; current = &amp;tlist-&gt;header; for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++) { current = current-&gt;next; } //insert elememt; ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element; current-&gt;next = node; node-&gt;next = ret; tlist-&gt;length++; return 0; } int LinkListDeleteElement(LinkList *list, int pos) { int i = 0; LinkListNode *current = NULL; LinkListNode *ret = NULL; TLinkList *tlist = (TLinkList *)list; current = &amp;tlist-&gt;header; if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length) { return NULL; } for (i = 0; i &lt; pos; i++) { current = current-&gt;next; } ret = current-&gt;next; current-&gt;next = ret-&gt;next; return 0; } int LinkListGetLength(LinkList *list) { int ret = 0; TLinkList *tlist = (TLinkList* )list; ret = tlist-&gt;length; return ret; } 基本概念date: 2018-09-22 14:22:10 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。 数据项：一个数据元素可以由若干个数据项组成。 数据对象： 是性质相同的数据元素的集合，是数据的子集。 抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。 逻辑结构：集合结构，线性结构，树形结构，图形结构 物理结构：顺序存储结构，链接存储结构。 好的算法还应该具备时间效率高和存储量低的特点。 线性阶： int i; for(i=0; i&lt;n; i=+) { } //对数阶： int count = 1; while (count &lt; n) { count = count * 2; } //平方阶： int i, j; for (i = 0; i &lt; n; i++) { for (j = 0; j &lt; n; j++) { } } //时间复杂（m*n): int i, j; for (i = 0; i &lt; n; i++) { for (j = i; j &lt; n; j++) { /*时间复杂度*/ } } //数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2; /* 最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。 平均时间是所有情况中最有意义的，因为他是期望的运行时间。 一般没有特殊说明的情况下， 都是指最坏时间复杂度。 /* 可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。 线性表的抽象数据类型 : 时间复杂度 空间复杂度 时间换空间 空间换时间 二叉树定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。 基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树） 二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。 满二叉树：每层都“充满”了结点。 完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。 性质： 对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2. 可以通过数组下标，隐藏地找到其左孩子和右孩子。 不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。 二叉树的表示法二叉树的二叉链表 表示法 二叉树的三叉链表 表示法： 添加了 Parent Position 二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。 ​ //二叉链 表示法 typedef struct BitNode { int data; struct BitNode *lchild, *rchild; }BitNode, *BitNode; //三叉链表 typedef struct TriNode { int data; struct TriNode *lchild, *rchild; struct TriNode *parent; }TriNode, *TriNode; //双亲表示法 #define MAX_TREE_SIZE 100 typedef struct BPTNode { int data; int parentPosition; char LRTag; }BPTNode; typedef struct BPTree { BPTNode nodes[MAX_TREE_SIZE]; int num_node; int root; }BPTree; 二叉树遍历先序遍历： DLR， 先根再左再右 中序遍历： LDR， 先左再根再右 后序遍历： LDR，先左再右再根 总结： 顺序都是相对于根（root）来说的。 二叉树表示算数表达式： 先序遍历： 前缀表示法 中序遍历： 中缀表示法 后序遍历： 后缀表示法 对遍历的分析： 1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。 从虚线的出发点到终点的路径上，每个结点经过3次。 第 1 次经过时访问 = 先序遍历 第 2 次经过时访问 = 中序遍历 第 3 次经过时访问 = 后序遍历 树的非递归中序遍历/* 步骤1： 如果结点有左子树，该结点入栈； 若果结点没有左子树，访问该结点 步骤2： 如果结点有右子树，重复步骤1； 如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1 如果栈为空，表示遍历结束。 */ #include &lt;iostream&gt; using namespace std; #include &quot;stack&quot; typedef struct BitNode { int data; struct BitNode *lchild; struct BitNode *rchild; }BitNode; //参数列表: BitNode *T, stack(BitNode *&gt; &amp;s //返回值: BitNode * BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) { //&amp;s 引用类型 if (T == NULL) { return NULL; } while (T-&gt;lchild != NULL) { //如果有左子树， 该结点入栈，并指向左子树。 s.push(T); T = T-&gt;lchild; } //如果没有左子树， 返回该结点。 return T; } void inOrder(BitNode *T) { BitNode *t = NULL; stack&lt;BitNode *&gt;s; t = goLeft(T, s); while (t) { printf(&quot;%d &quot;, t-&gt;data); // 访问该结点 //如果t有右子树，重复步骤1 if (t-&gt;rchild != NULL) { t = goLeft(t-&gt;rchild, s); } // 如果t没有右子树，根据栈顶提示，回退 else if (!s.empty()) { t = s.top(); s.pop(); } // 如果没有右子树， 并且栈为空 else { t = NULL; } } } void main() { BitNode t1, t2, t3, t4, t5; memset(&amp;t1, 0, sizeof(BitNode)); memset(&amp;t2, 0, sizeof(BitNode)); memset(&amp;t3, 0, sizeof(BitNode)); memset(&amp;t4, 0, sizeof(BitNode)); memset(&amp;t5, 0, sizeof(BitNode)); t1.data = 1; t2.data = 2; t3.data = 3; t4.data = 4; t5.data = 5; t1.lchild = &amp;t2; t1.rchild = &amp;t3; t2.lchild = &amp;t4; t3.lchild = &amp;t5; printf(&quot;\r\n 非递归遍历 \r\n&quot;); inOrder(&amp;t1); cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; system(&quot;pause&quot;); } 通过中序遍历和先序遍历可以确定一个树 通过中序遍历和后序遍历可以确定一个树 通过先序遍历和后序遍历不能确定一个树 单独先序遍历。 二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。 图线性表中我们把数据元素叫元素，树中的数据元素叫结点，在图中数据元素，我们称之为顶点（Vertex）。 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。同样，在图的结构中，不允许没有顶点，在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。 图中，任意两个顶点你之间都可能有关系，顶点之间的逻辑关系用吧边表示，边集可以是空的。 连通图 在无向图 G 中， 如果对于图中任意两个顶点v1，v2都是连通的，则称 G 是连通图。 无向图中的极大连通子图称为连通分量。 有向图 G 中，如果对于每一对vi， vj， 从vi 到 vj 和 从 vj 到 vi都存在路径，则称 G 是强连通图。 邻接表 一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间的浪费。这个思路同样适用于图的存储，我们把这种数据与链表结合的存储方法称为邻接表。 顶点表的各个结点有 data 和 firstedge 两个域表示， data 是数据域，存储顶点信息，firstedge 是指针域，指向边表的第一个结点。 边表结点有 adjvex 和 next 两个域组成， adjvex 是邻接点域，存储某顶点的邻接点在顶点中的下标。 next 则存储指向表中下一个结点的指针。 有时为了便于确定顶点的入度或以顶点为弧头的弧， 有向图的逆连接表，即对每个顶点 v1 都建立一个链接为 v1 为 弧头的表。 邻接矩阵 图的邻接矩阵存方式是用两个数组来表示图。一个一维数组存图中顶点信息， 一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C]]></title>
    <url>%2F2018%2F10%2F10%2FC%2F</url>
    <content type="text"><![CDATA[链表date: 2018-09-10 13:57:09 链表是一种结构体， 包括数据域和指针域。 链表是一种物理存储单元上非连续的线性存储结构。 链表遍历 动态库date: 2018-09-06 17:20:42 h头文件是编译时必须的， lib库是链接时需要的， dll动态链接库是运行时需要的。 .h .lib .dll三者的关系是： h文件作用是：声明函数接口 lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址 dll文件作用是：函数可执行文件 动态库是底层函数的调用入口。动态库与测试框架相结合。 void SockInit(void *handle)： handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数； 被调函数将传进来的参数handle 强制转换相应的数据类型。 文件操作date: 2018-09-06 11:44:51 文件句柄： 就是内存块的首地址或者资源首地址。 测试框架 和 分层模块的区别 结构体date: 2018-09-05 13:53:11 //结构体定义 typedef struct Teacher { char name[30]; int age; }Teacher; Teacher *SortTeacher(int num) //堆区分配内存 { Teacher *pArray = NULL; pArray = (Teacher *) malloc(sizeof(Teacher) *num); if(pArray == NULL) { printf(&quot;pArray = NULL.&quot;); } return pArray. } //返回值 //优化 int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } *pArray = temp; return 0; } 用结构体套一级指针 //结构体定义 typedef struct Teacher { char name[30]; int age; char *id; //需要分配内存空间才有效。 }Teacher; int CreateTeahcer_good( Teacher **pArray, int num) // 用二级指针修改一级指针的值 { Teacher * temp; int i = 0; temp = (Teacher *)malloc(sizeof(Teacher)*num); if(temp == NULL) { return -1; printf(&quot;堆区分配失败.&quot;); } for(i=0; i&lt;num; i++) { temp[i].id = (char *)malloc(sizeof(char)*120); } *pArray = temp; return 0; } //需要两次释放堆内存 void freeMem(Teacher *pArray) { if(pArray == NULL) { printf(&quot;error.&quot;); } if(pArray-&gt;id != NULL) { free(pArray-&gt;id); pArray-&gt;id = NULL; } free(pArray); pArray = NULL; } /* 结构体嵌套二级指针 C语言的高效（数组作函数的参数的退化现象） 指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。 什么时候用一级指针，什么时候用二级指针。 被调用函数分配内存，供主调函数使用，二级指针。 主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件： - 2个变量（通常一个实参，一个形参） - 建立关系，实参取地址赋给形参 - *p形参区间接修改形参的值 不断修改指针变量的值 越界场景： char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39; 总结: 函数调用时，用n级指针（形参）改变n-1级指针（实参）的值 /* const 的用法date: 2018-09-04 09:17:33 //const char *p 指针所指向的内存不能被修改 void getMem(const char *p) { p++; //*p = 1; } //char *const p 指针变量的值的不能被修改。 void getMem2(char *const p) { //p++; *p = 1; } //const char *const p 指针变量的值和它所指向的内存不能被修改。 void getMem3(const char *const p) { //p++; //*p = 1; } 多维数组date: 2018-09-04 16:57:20 void main() { int a[] = {1, 2}; int b[100] = {1, 3}; int c[200] = {0}; //编译的是 就已经确定 所有的值 为零 memset(c, 0, sizeof(c)); //显示的 重置内存块 //对一维数组 C规定： //c是数组首元素的地址 c+1 步长 4个字节 //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4 printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } //怎么样表达int a[10]这种数据类型那？int[] //类型本质：固定大小内存块的别名 //定义数组类型 void main() { typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; for (i=0; i&lt;5; i++) { myArray[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, myArray[i]); } printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1); printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法1 void main() { char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组 //数组指针 用一个指针 来指向一个数组 typedef int (MyArrayType)[5]; //定义了一个数据类型 数组数据类型 int i = 0; MyArrayType myArray; //int myArray[5]; //用类型定义变量 MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组 { int myArray2[5]; //相当于一级指针 pArray = &amp;myArray2; //相当于2级指针 for (i=0; i&lt;5; i++) { (*pArray)[i] = i+1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法2 void main() { //定义声明一个数组指针类型 typedef int (*PArrayType)[5]; PArrayType pArray; //告诉编译器 给我分配一个指针变量 int c[5]; int i = 0; pArray = &amp;c; for (i=0; i&lt;5; i++) { (*pArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 定义数组指针变量的方法3 void main() { //int [][5] int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量 int c[5]; int i = 0; pMyArray = &amp;c; for (i=0; i&lt;5; i++) { (*pMyArray)[i] = i + 1; } for (i=0; i&lt;5; i++) { printf(&quot;%d &quot;, (*pMyArray)[i]); } printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return ; } 多维数组名的本质是数组指针 多维数组作参数退化问问题 //多维数组作参数的退化问题 void getArray1(int buff[3][5])//buff退化为数组指针 { int num = 0; int i, j; int temp = 0; num = sizeof(buff); printf(&quot;num:%d\n&quot;, num); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++; } } } void getArray2(int buff[][5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { buff[i][j] = temp++; } } } void getArray3(int (*buff)[5]) { int i, j; int temp = 0; for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { *(*(buff+i)+j) = temp++;; } } } /* 多维数组名的本质 数组指针 ，步长 一维的长度 (a+i) 代表是整个第i行的地址 二级指针 *(a+i) 代表 1级指针 第i行首元素的地址 *(a+i) + j ===&gt; &amp; a[i][j] *( *(a+i) + j) ===&gt;a[i][j]元素的值 */ void main() { int a[3][5]; int i, j; int temp = 0; getArray3(a); for(i=0; i&lt;3; i++) { for(j=0; j&lt;5; j++) { printf(&quot;%d &quot;, a[i][j]); } } printf(&quot;hello.\n&quot;); system(&quot;pause&quot;); return; } /* 等价关系 | 数组参数 | 等效数组参数 | ------ | ------ | | 一维数组 char a[30] | 一级指针 char *a | 指针数组 char *a[30] | 二级指针char **a | 二维数组 char a[5][30] | 数组指针变量char (*a)[30] */ 二级指针的三种内存模型date: 2018-09-04 11:28:19 void main() { int num = 3; int i, j; char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;}; char **buff = (char**)malloc(sizeof(char*)*4); for(i=0; i&lt;num; i++) { buff[i] = (char*)malloc(sizeof(char)*10); sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1); } for(i=0;i&lt;num; i++) { printf(&quot;%s\n&quot;, buff[i]); } system(&quot;pause&quot;); } 字符串常用操作date: 2018-09-03 15:02:59 字符串COPY函数优化过程 /* buf[3] 和 *(p+3) 1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯 2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。 3.p普通指针 和 数组第一个元素地址的区别 */ void str_copy(char *from, char *to) //表明主调函数分配内存，供被调函数内部使用 { for( ; *from != &#39;\0&#39;; from++, to++) { *to = *from; } *to = &#39;\0&#39;; } void str_copy1(char *from, char *to) { while( (*to = *from) != &#39;\0&#39;) { to++; from++; } } void str_copy2(char *from, char *to) { while((*to++ = *from++) != &#39;\0&#39;) //等效与*to = *from; to++; from++; { ; } } //建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来 void str_copy_good(char *from, char *to) { char *tempfrom = from; char *tempto = to; if( tempfrom ==NULL || tempto == NULL) { return; } while((*tempto++ = *tempfrom++) != &#39;\0&#39;); printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。 } 正确示范 void main() { char *p = &quot;abcd&quot;; char buff[123]; //分配内存 str_copy2(p, buff); printf(&quot;buff:%s\n&quot;,buff); system(&quot;pause&quot;); } 错误示范 void main() { char *p = &quot;abcd&quot;; char *to = NULL;//没有分配内存 str_copy2(p, to);//直接在0X0地址写值，程序运行中断。 printf(&quot;buff:%s\n&quot;,to); system(&quot;pause&quot;); } 项目开发中字符串模型 /* (*count)++和 *count++的区别：*count++ 等效于 *(count++) 1. 输入特性 in：主函数分配内存，供被调函数使用。 2. 输出特性out：被调函数分配内存，供主调函数。 */ int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/) { char * p = mystr; char * count = ncount; int ret; if( mystr == NULL || sub == NULL || ncount == NULL) { ret = -1; printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;); } do { p = strstr(p, sub); if(p != NULL) { (*count)++; //(*count)++和 *count++的区别：*count++ 等效于 *(count++) p = p + strlen(sub); } }while(*p != &#39;\0&#39;); ret = 0; return ret; } void main() { char *p = &quot;123123adcd123123abcd123&quot;; char *substr = &quot;123&quot;; char count = 0; int ret; ret = getCount(p, substr, &amp;count); if (ret != 0) { printf(&quot;getCount() error;&quot;); return; } printf(&quot;count :%d\n&quot;, count); system(&quot;pause&quot;); } 字符串反转 ​ ​ int reverse(char *str) { int length; char *temp = str; char *p1; char *p2; char c; if(temp == NULL) { return -1; printf(&quot;str = NULL.&quot;); } length = strlen(temp); p1 = temp; p2 = temp + length -1; while(p1 &lt; p2) { c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } return 0; } void main() { char buff[] = &quot;123123abcd123123abcd123&quot;; //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值 char *substr = &quot;abcd&quot;; char count = 0; int ret; printf(&quot;buff[]: %s\n&quot;, buff); ret = reverse(buff); if(ret != 0) { printf(&quot;reverse() error.&quot;); return; } printf(&quot;buff = %s\n&quot;, buff); system(&quot;pause&quot;); } ​ 通过递归方式和局部变量的方式实现的逆序打印字符串。 void inverse(char *p, char *mybuf) { if( p == NULL) { return ; printf(&quot; p = NULL.&quot;); } if(*p == &#39;\0&#39;) { return; } inverse(p+1, mybuf); strncat(mybuf, p, 1); // } void main() { char buf[] = &quot;abcdfg&quot;; char mybuf[100]={0}; inverse(buf,mybuf); printf(&quot;%s\n&quot;, mybuf); system(&quot;pause&quot;); } ​ 二级指针的间接赋值date: 2018-09-02 19:07:59 void getMem(int **p) //通过二级指针形参， 指向主函数的一级指针 { *p = (int*)malloc(100); } void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值 { p = (int*)malloc(sizeof(char)*100); } void main(void) { int **p2 = NULL; int *p1 = NULL; p2 = &amp;p1; getMem(p2); printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值 getMem2(p1); //无修改p1的值 printf(&quot;int *p: %d\n&quot;, p1); system(&quot;pause&quot;); return ; } //结果显示： //int *p :7746448 //int *p: 7746448 //请按任意键继续. . . 间接赋值的应用 void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/) { char *temp1 = NULL; char *temp2 = NULL; temp1 = (char *)malloc(100); strcpy(temp1, &quot;12312312&quot;); *len1 = strlen(temp1); *p1 = temp1; temp2 = (char *)malloc(200); strcpy(temp2, &quot;asdfasdfasdf&quot;); *len2 = strlen(temp2); *p2 = temp1; } void main(void) { char *p1 = NULL; char *p2 = NULL; int len1, len2; getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量 printf(&quot;p1 = %s\n&quot;, p1); printf(&quot;len1 = %d\n&quot;, len1); printf(&quot;p2 = %s\n&quot;, p2); printf(&quot;len2 = %d\n&quot;, len2); system(&quot;pause&quot;); } 指针作函数参数, 具有输入输出特性 输入特性 in：主函数分配内存，供被调函数使用。 输出特性out：被调函数分配内存，供主调函数。 指针也是一种数据类型date: 2018-09-02 10:07:52 指针是一种数据类型，是指它指向的内存空间的数据类型 含义1：指针步长（p++），根据所致内存空间的数据类型来确定 p++=(unsigned char )p + sizeof(a); 结论：指针的步长，根据所指内存空间类型来定 void main() { int b[40]; printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1); system(&quot;pause&quot;); return; } 结果显示: b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048 //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。 //&amp;b 表明 整个数组的首地址。 //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。 //&amp;b 加数组中第一个数的大小得到的地址。 堆栈区和函数调用分析date: 2018-09-02 08:57:39 栈的生长方向 函数调用分析 //栈的开口向上向下,,测试 release和dubug; //一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的.. void main(void) { int a; int b; char buf[99]; //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了.... printf(&quot;&amp;a:%d\r\n&quot;, &amp;a); printf(&quot;&amp;b:%d\r\n&quot;, &amp;b); printf(&quot;buf:%d\r\n&quot;, buf); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } 堆栈区的理解date: 2018-09-01 20:40:25 //堆区 char *getMem(int num) { char *p; p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存 if(p == NULL) { return; } return p; } //栈区 char * getMem2() { char *p = NULL; char a[40]; //局部变量，临时变量 p = a; return p; } void main(void) { char *p1 = NULL; char *p2 = NULL; p1 = getMem(10); if(p1 == NULL) { return; } p2 = getMem2(); if(p2 == NULL) { return; } strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中 strcpy(p2, &quot;123123&quot;); //打印p1 p2 所指向内存空间的数据 printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2); //打印p1 p2 的值 printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2); printf(&quot;hello\n&quot;); system(&quot;pause&quot;); return ; } //结果显示： //p1:123123 p2:乱码 //p1:2896568 , p2:1572272 //hello... //请按任意键继续. . . mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 数据类型的大小, 内存四区的划分date: 2018-09-01 15:57:49 函数参数退化问题, 退回一个指针date: 2018-09-01 12:01:59 结论： 把数组的内存首地址和数组的有效长度传给被调用函数 实参的 a 的 形参的 a的数据类型不一样 形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。 形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。 void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。 { int i = 0, j = 0; int temp = 0; int num1 = 0; num1 = sizeof(a) / sizeof(a[0]); printf(&quot;num1: %d\r\n&quot;, num1); // num1 = 1, 结果表明形参中的a[]是指针类型。 for(i=0; i&lt;num; i++) { for(j=0; j&lt;i+1; j++) { if(a[i] &lt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } } void printfArray(int a[], int num) { int i = 0; for(i=0; i&lt;6; i++) { printf(&quot;%d &quot;, a[i]); } printf(&quot;\n&quot;); } //排序 void main(void) { int a[] = {123,321,231,332,221,1}; int i, j, temp; int num = 0; num = sizeof(a) / sizeof(a[0]); printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。 SortArray(a, num); printfArray(a, num); printf(&quot;\n&quot;); printf(&quot;hello...\n&quot;); system(&quot;pause&quot;); return; } `]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软考]]></title>
    <url>%2F2018%2F10%2F03%2F%E8%BD%AF%E8%80%83%2F</url>
    <content type="text"><![CDATA[第 1 章 计算机系统基础知识基本的计算机硬件系统由运算器, 控制器, 存储器, 输入设备和输出设备组成. 运算器和控制器以及其相关部件已被集成到一起, 统称为中央处理单元(CPU) 移码表示法: 是在数X上增加一个偏移量来定义的, 常用与表示浮点数中的阶码. 移码:不管正负数, 只要将其补码的符号位取反即可. 例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101 十进制数与字符的编码表示: 数值, 文字, 英文字母都被认为是字符, 任何字符进入计算机时, 都必须转换成二进制表示形式, 成为字符编码. 用4位二进制代码表示以为十进制数, 称为二-十进制编码, 简称BCD编码. 直接存储器存取(Direct Memory Access, DMA) 方式的基本思想是通过硬件控制实现主存与I/O设备之间的直接数据传送. 数据的传送过程由 DMA 控制器( DMAC ) 进行控制, 不需要 CPU 的干预. CPU 所能完成的操作是由其执行的指令决定的, 这些指令成为机器指令. CPU 能执行的所有机器指令的集合称为该 CPU 的指令系统. 指令系统是计算机硬件与软件之间的接口. 指令是指挥计算机完成各种操作的基本命令. 一般来说, 一条指令包括两个基本组成部分: 操作码和地址码. 操作码说明指令的功能机操作性质. 地址码用来指出指令的操作对象, 它指出操作数或操作数的地址及指令结果的地址. 操作码用二进制编码来表示, 该字段越长, 所能表示的指令就越多. 寻址方式: 就是如何对指令中的地址字段进行解释, 以获得操作数的方法或获得程序转移地址的方法, 操作数的位置可能在指令中, 寄存器中, 存储中或 I/O 端口. 常用的寻址方式有立即寻址, 直接寻址, 寄存器寻址, 寄存器间接寻址等. 磁盘存储器的主要技术指标： 道密度：沿盘面半径方向单位长度内磁盘的数目， 单位是道/毫米 位密度：磁道圆周上单位长度存储的二进制位的个数，单位是位/毫米 存储容量：总的盘面数 x 每面的磁道数 x 每道扇区数 x 每个扇区存储的字节数。 平均访问时间： 平均寻道（址）时间 +平均等待时间 数据传输率： 单位时间内写入或读出的字节数。 数据传输率 = 每道扇区数 x 每个扇区包括的字节数 x 磁盘的转数 第 2 章 操作系统基础知识操作系统是计算机系统中必不可少的核心系统软件, 其他软件的(编辑程序, 汇编乘车, 编译程序, 数据库管理程序等系统软件, 以及大量的应用的软件)是建立在操作系统的基础上的. 操作系统的作用是通过资源管理提高计算机系统的效率. 操作系统的 4 个特征是并发性, 共享性, 虚拟性和不确定性. 从资源管理的观点来看, 操作系统的功能可分为5大部分: 处理机管理, 文件管理, 存储管理, 设备管理和作业管理. 处理机管理, 实质上是对处理机的执行时间进行管理, 采用多道程序等技术将CPU 的时间合理地分配给每个任务. 主要包括进程控制, 进程同步, 进程通信和进程调度. 处理机管理也称为进程管理, 其核心是如何合理地分配处理机的时间, 提高系统的效率. 在计算机系统中有多个并发执行的程序, 采用 程序 这个静态概念已经不能描述程序执行时的动态变化过程, 所以引入了 进程 . 基本概念程序执行时的特征.进程 (Process) 是程序的一次执行. 进程通常有程序, 数据和进程控制模块 (Process Control Block, PCB ) 组成. 进程控制模块是进程存在的唯一标志. 进程的状态及其状态键的转换 三态模型, 在多道程序系统中, 进程的运行是走走停停的, 在处理器上交替运行, 状态也不断地发生变化, 因此一般有三种基本状态: 运行, 就绪和阻塞, 也成为三态模型. 运行: 当一个进程在处理机上运行时，称为进程处理运行状态．显然，对于单处理机系统，处理运行状态的进程只有一个． 就绪：一个进程获得了除处理机外的一切说需要的资源，一旦得到处理机即可运行，则称为进程处于就绪状态． 阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生而暂时停止运行， 这时及时把处理机分配给进程，这时及时把处理机分配给该进程，他也无法运行，故称为该进程处于堵塞状态． 进程控制 进程控制是对系统中所有进程从创建到消亡的全过程实施有效的控制．在操作系统中通过设置一套控制机构堆进程实施控制，其主要功能包括创建一个新进程，撤销一个已经运行完的进程，改变进程的状态，实现进程间的通信．进程控制是由操作系统内核中的原语实现的． 原语是指由若干条机器指令组成，用于完成特定功能的程序段， 进程通信 在多道程序环境的系统中，存在多个可并发执行的进程，因此进程间必然存在资源共享和相互合作的问题．进程通信是指各个进程交换信息的过程． 进程间的同步:是指进程间完成一项任务时直接发生相互作用的关系. 进程间的互斥: 在多道程序系统中, 各进程可以共享各类资源, 但有些资源一次只能供一个进程使用, 称为临界资源. 如打印机. 进程间的互斥是指系统中各进程互斥使用临界资源. 临界区是进程中对临界资源实施操作的那段程序. 有空即进. 无空则等 有限等待 让权等待 信号量机制: 是一种有效的进程同步与互斥工具. 整形信号量与 PV 操作 信号量是一个整形变量, 根据控制对象的不同被赋予不同的值. 公用信号量. 实现进程间的互斥, 初值为 1 或资源的数目 私用信号量. 实现进程间的同步, 初值为 0 或某个正整数. 信号量 S 的物理意义: 若 S &gt;= 0, 表示某资源的可用数; 若 S &lt;０，则其绝对值表示阻塞队列中等待该资源的进程数． 对系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互斥有关． PV 操作是实现进程同步与互斥的常用方法. P 操作和 V操作是低级通信原语, 在执行期间不可分割. 其中, P 操作表示申请一个资源, V 操作表示释放一个资源. 高级通信: 为了提高通信效率, 能传递大量数据, 减轻程序的复杂度, 系统引入了高级通信方式. 高级通信方式主要分为 共享存储模式, 相互通信的进程共享某些数据结构 ( 或存储区), 实现进程之间的通信. 消息传递模式, 进程间的数据交换以消息为单位, 程序员直接利用系统提高的一组通信命令 (原语) 来实现通信. 如Send(A), Receive(A) 管道通信: 管道是用于连接一个读进程和一个写进程, 以实现它们之家你通信的共享文件 (pipe文件)，向管道提供输入的发送数据（即写进程), 以字符流的形式将大量的数据送入管道; 而接受进程可从管道接受大量的数据. 直接和间接通信 直接通信是将消息直接发送给制定进程. 间接通信是以信箱为媒体来是实现通信的, 接受信件的进程只需设疑一个信箱, 若干个进程都可以向同一个进程发送信件. 进程调度​ 进程调度方式是指当有更高优先级的进程到来时, 如何分配 CPU. 调度方式分为可剥夺和不可剥夺两种. 三级调度 调度算法: 常用的进程调度算法有先来先服务， 时间片轮转， 优先级调度和多级反馈调度算法． 死锁 在计算机系统中有各种互斥资源(如磁带机, 打印机和绘图仪) 和 软件资源(如进程表, 临界区等), 若两个进程互相要求对方已占用的资源. 所谓死锁, 是指两个以上的进程互相要求使用对方已经占有的资源而导致无法继续运行的现象. 进程推进顺序不当, 同类资源分配不当, PV 操作使用不当等情况都可能造成死锁. 线程 传统的进程有两个基本属性: 可拥有资源的独立单位, 可独立调度和分配的基本单位. 由于在进程的创建, 撤销和切换中, 系统必须为之付出较大的时空开销, 因此在系统中的设置的进程数目不宜过多, 进程切换不宜太高, 这就是限制了并发程度的提高. 引入了线程后, 将传统进程的两个基本属性分开, 线程作为调度和分配的基本单位, 进程作为独立分配资源的单位. 用户可以通过创建线程来完成任务, 以减少程序并发执行时付出的时空开销. 进程: 资源分配的最小单位 线程: 程序执行的最小单位. 线程是进程中的一个实体, 是被系统独立分配和调度的基本的单位. 线程基本上不拥有资源, 只拥有一点运行中必不可少的资源. 它可与同属一个进程的其他线程共享进程所拥有的全部资源. 存储管理 存储器管理的对象是(主存, 内存). 存储管理的主要功能包括分配和回收住存空间, 提高主存的利用率, 扩充主存, 对主存信息实现有效保护. 文件管理 文件是就有符号名的, 在逻辑上具有完整意义的一组相关信息项的集合. 第 3 章 数据库基础知识 文件系统是操作系统中的一个子系统, 它按一定的规则将数据组织成为一个文件, 应用程序通过文件系统堆文件的数据进行存取和加工. 文件系统对数据管理的, 实际上是通过应用程序和数据之间的一种接口实现. 文件系统的最大特点是解决了应用程序和数据之间的一个公共接口问题, 使得应用程序采用统一的存取方法来操作数据. 数据库系统是由计算机软件, 硬件资源组成的系统, 它实现了大量关联数据有组织地, 动态第存储, 方便用户访问. 它与文件系统的重要区别是数据的充分共享, 交叉访问, 与应用程序高度独立. 数据模型 模型是对现实世界特征的模拟和抽象, 数据模型是对现实世界数据特征的抽象. 第 4 章 多媒体基础知识色调:指颜色的类别， 如红色，绿色和蓝色等不同颜色． 第 5 章 网络基础知识 数据在网络中是以”包”的形式传递, 但不同网络的”包”的格式不同. 因此, 在不同的网络间传送数据时, 就需要网络间的连接设备充当翻译工作. 中继器: 可以”延长”网络的距离, 在网路传输中其到放大的作用. 数据经过中继器, 不需要进行数据包的转换. 中继器连接的两个网络在逻辑上是同一个网络. 中继器工作物理层, 对高层协议完全透明. 集线器: 集线器是中继器的一种, 区别仅在于集线器能够提供更多的端口服务, 所有集线器又称多口中集器. 集线器主要用于优化网络布线结构, 简化网络管理. 集线器是对网络进行集中管理的最小单元, 只是分配带宽, 可以放大和中转信号. ​ 使用集线器的优点是:当网络系统中某条线路或某结点出现故障时， 不会影响网上其他结点的正常工作，因为它提高了多通道的通信，大大提高了网络通信速度． 网桥： 当一个单位有多个LAN, 或一个LAN由于通信距离受限无法覆盖所有结点而不得不使用多个局域网时, 举要将这些局域网互联起来, 以实现局域网之间的通信. ​ 使用网桥可扩展局域网的范围, 网桥的每个端口与一个网段(这里说所的网段就是普通局域网)相连. ​ 网段:一般指一个计算机网络使用同一物理层设备，能够直接通信那那一部分．例如，从192.168.0.1到192.168.255.255这之间就是一个网段。 交换机： ​ 交换机提高了另一种提高数据传输速率的方法． 第 7 章 软件工程基础知识 面向对象的基本概念 １.对象 ２.消息：对象之间进行通信的一种构造叫做信息。 当一个消息发送给某个对象时，包含要求接受对象去执行某些活动的信息。接受到信息的对象经过解释，然后给予响应。这种通信机制叫做消息传递。发送消息的对象不需要知道接受消息的对象如何响应应该请求。 ３.类：一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述了一组对象的共同行为和属性。把一组对象的共同特征加以抽象并存在一个类中，而是面向对象技术最重要的一点，是否建立了一个丰富的类库，是衡量一个面向对象程序设计语言成熟与否的重要标志。 ４.继承：是父类和子类之间共享数据和方法的机制。 ５.多态：对象收到消息时，要给予响应。不同的对象收到同一消息可以进行不同的响应，产生完全不同的结果，这种现象叫做多态。 ６.动态绑定：绑定是一个把过程调用和响应调用需要执行的代码加以结合过程。 软件测试的目的及原则 ​ 软件测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。 ​ 测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。 维护： 改正性维护是指诊断和改正在使用过程中发现的软件错误； 适应性维护是值修改软件以适应环境的变化 完善性维护是根据用户的要求改进或扩充软件是它更完善 预防性维护是指修改软件为将来的维护活动预先做准备。 常见的软件生存模型： 瀑布模型：一个待开发的系统需求是完整的、简明的、一致的 增量模型：假设将需求分段为一系列的增量产品。 演化模型：针对事先不能完整定义需求的软件开发，是在一个快速开发的基础上，根据用户在使用模型的过程中提出的意见和建议对原型进行改进。 螺旋模型：将瀑布模型和演化模型结合。 喷泉模型： 软件过程：生产一个最终满足需求并且达到工程目标的团建产品所需的步骤。过程是活动的集合，活动是任务的集合。 软件能力成熟度模型：CMM。 CMM将软件过程改进分为5个成熟度： 初始级，可重复级，已定义级，已管理级，优化级。 软件调试：试探发， 回溯法，对分查找法，归纳法，演绎法 第 8 章 数据结构与算法 ​ 数据结构是指数据元素的集合及元素间的相互关系的构造方法。 ​ 矩阵是很多科学与工程计算领域研究的数学对象。在数据结构中主要讨论如何在尽可能节省存储空间的情况下，使矩阵的各种运算能搞笑地运行。 第 12 章 Java 程序设计语言 /* 这里将main方法定义公共方法的目的是为了让Java解释器能够调用此方法 而定义为静态static，因为调用main方法的时候还不存在任何对象，main方法只能属于类，而不能和对象相关联。 */ public class Demo { public static void main(String[] args) { } } StringBuffer 字符串： 类StringBuffer的对象也表示字符串，与String不同的是， StringBuffer是线程安全的可变的字符序列， StringBuffer对象引用的字符串能够通过特定的方法调用被直接修改。 StringBuilder 字符串 ​ StringBuilder 是 Java1.5引入的一个可变的字符序列，提供了和 StringBuffer 相同的API， 但是不保证同步（非线程安全），在只有一个线程时替代 StringBuffer 使用。 StringBuilder 的大多数实现要比 StringBuffer快速， 推荐优先使用 StringBuilder 。 Java程序中不需要明确删除一个对象，因为Java有自动的垃圾回收机制。 当一个对象没有任何变量引用时， 该对象的生存期结束，其存储空间由系统自动回收。 包： ​ 定义包： package ​ 引入包： import来引入包 注解@override 表示子类 getValue() 是覆盖了父类的 getValue()， 如果程序员不小心拼写错误， 或者方法签名对不上被覆盖的方法， 编译器就会发生错误提示。 接口： 也是实现代码重用的一种方式， Java不支持多重继承， 接口是顺应多重继承的需要的而产生的， 以另一种方式实现多重继承，接口实际是一组抽象方法和常量的集合。 异常： ​ 异常分为两种： Error 和 Exception。 编程程序时应该考虑异常的产生和处理。 通常， 程序不需处理 Error 类型的异常， 但是应关注 Exception 类型的异常。 文件输入、输出和流 ​ 一个流是一个输入设备或输出设备的抽象表示， 一般分为字符流和字节流。 字节流：字节流处理单元为8位的字节，数据源中如何含有非字符数据的二进制的数据，如音频，图片，歌曲文件等， 就是字节流来处理输入/输出。 所有的字节流都是抽象基类 InputStream 或者 OutputStream 的子类， 这两个类是抽象的， 不能直接创建其对象来创建一个流， 而要通过他们的子类来创建一个流。 集合类：Java提供了容纳对象（或者对象的句柄）的多种形式，以设计好的类库形式提供了读数据进行有效管理的数据结构和算法， 如链表、二叉树、栈和散列表等。 Java集合框架分为集合和映射两组， 分别从两个基本接口继承而来： Collection 和 Map， 他们是相互独立的， 包含了常用的数据结构 考点第 1 章 CPU包括运算器，控制器，寄存器三大部分。 时钟周期是最基本，最小的时间单位。指令周期 &gt; 机器周期 &gt; 时钟周期 海明码是利用奇偶性来检错和纠错的校验方法。 在同一时间处理二进制数的位数称为字长。通常称处理字长为8位数据的CPU为8位CPU。 光盘格式中，不能多次擦除重写数据的是 CD-R 地址总线的宽度决定了CPU可以访问的物理地址空间，简单地说就说CPU到底能够使用多大容量的内存。 在微型计算中，通常用主频来描述CPU的运算速度；对计算机磁盘工作影响最小的因素是噪声。 CPU执行算术运算或者逻辑运算时，算术运算部件(ALU)将计算结果保存在累加器AC中。 PCI 是系统总线， USB 是串行总线， IEEE-1394也是高速串行接口标准， IEEE-488是并行外部总线。 若指令系统中设置了专用I/0操作指令，则I/0接口可以独立编址。 第 2 章 操作系统的定义 操作系统的作用 操作系统的特征：并发性，共享性，虚拟性和不确定性， 4个基本特征。虚拟性是操作系统的重要特征，所谓虚拟是把物理上的一台设备变成逻辑上的多台设备。 不确定性：通常一个程序的初始条件相同时，无论何时运行，结构都应该相同。但由于操作系统并发执行系统内的各种进程。 操作系统的功能： ​ 1.处理机管理负责解决如何把CPU时间合理地、动态地分配给程序运行的基本单位–进程，是处理机得到充分利用。 ​ 2.存储管理：存储器是运行程序或存放工作数据的部件，存储管理的工作的主要是对内存存储器进行分配，扩充和保护。 ​ 3.设备管理 ​ 4.文件管理 存储器的功能是保存数据 虚拟地址：数据的存放地址是友符号决定的， 故又称为符号名地址，或者成为名地址。 地址重定位：是指程序的逻辑地址转换成主存的物理地址的过程。在可执行文件装入时需要解决可执行文件中的地址和主存地址的对应关系。 存储管理：分区存储管理，分页存储管理，分段存储管理，段页式存储管理和虚拟存储管理、其中存储管理是把主存中的用户区划分成若干个区域，每个区域分配給一个用户作用使用，并限定他们只能在自己的区域运行。按划分的不同方式，可分为固定分区，可变分区和重定位分区。 分页式存储管理： ​ 分页管理：将一个进程的地址空间划分为若干个大小相等的区域，称为页。相应的，将内存空间划分成与页相同的大小的物理块，成为块或页框。 分段存储管理： ​ 作业的地址空间被划分成若干个段，每个段是一组完整的逻辑信息，如有主程序段，子程序段，数据段和堆栈段等，每个段都有自己的名字，都是从0开始编址的一段连续的地址空间，各段的长度是不等的。 虚拟存储器管理： ​ 存储管理策略的基础是局部原理——进程往往会不均匀地，高度局部化地访问主存。 ​ 虚拟存储器的定义：一个作业在运行之前，没必要全部装入内存中，而仅将当前要运行的那部分分页面或段先装入主存启动运行，其余部分暂时时留在磁盘上。 虚拟存储器具有请求调入功能和置换功能，仅能把作业的一部分装入内存便可运行作业的存储器系统，能从逻辑上对主存容量进行扩充。 设备管理： ​ DMA 技术：在外围设备和主存之间开辟直接的数据交换通路。在内存与输入/输出设备间传送一个数据块的过程中，不需要CPU的任何干涉，只需要CPU在过程中开始启动和过程结束时处理，实际操作由DMA硬件直接执行完成。 ​ 缓冲技术：硬件缓冲是利用专门的硬件寄存器作为缓冲区；软件缓冲是利用操作系统的管理，用主存中一个或多个区域作为缓冲区，进而可以形成缓冲池。 磁盘调度： 对磁盘的存储访问一般要有三部分时间。 首先要将磁头移动到相应的磁道或柱面上，这个时间叫做寻寻道时间。信息在磁盘和内存之间的实际传送时间叫做传送时间。磁盘调度的目的是平均寻道时间最少。 数据库概念模式：是数据库中全部数据的逻辑结构和特征的描述，由若干个概念记录类型组成。 外模型：是用户与数据库系统的接口 软件工程基础知识 风险分析：风险控制，风险预测，风险控制。风险回避，损失控制，风险转移和风险保留。 常见的生命周期模型： 软件生命周期六个阶段：问题的定义及规划，需求分析，软件设计，程序编码，软件测试，运行维护 软件工具：软件开发工具， 软件维护工具， 软件管理和软件支持工具。 UML图：统一建模语言是用来对软件密集系统进行可视化建模的一种语言。 UML图：用例图，静态图，行为图，状态图，交互图，实现图。 类之中的关系：UML中规定，类中共有4中基本关系：依赖， 关联，泛化，实现。 面向对象分析模型5个层次：主题层，对象类层，结构层， 属性层和服务层。 结构化设计方法：是一种面向数据流的方法 相对对象建模得到的模型包含对象的三个要素：静态结构，交互次序和数据交互。 面向对象设计原则：封装，信息隐蔽，高内聚，低耦合。 耦合关系 内容耦合：一组模块都访问同一个公共数据环境。 外部耦合：一组模块都访问同一个全局简单变量而不是同一全局数据结构。 控制耦合：一个模块把控制信息传递给另一个模块，对其功能进行控制。 标志耦合：一组模块通过参数传递记录信息，这组模块就是标记模块，注释：事实上模块共享了某一数据结构的子结构，而不是简单的变量。 数据耦合：一个模块访问另一个模块彼此之间通过数据参数来交换输入，输出信息。 非直接耦合：两个模块之间没有直接关系，它们间的联系完全通过主模块的控制和调用来实现的。 软件质量管理和质量保证 ​ 功能性、可靠性、易用性、效率、可维护性、可移植性。这六中质量特性都由质量特性（第一层6个），子特性（第二次21个）和度量 三个层次组成。 测试分类： ​ 黑盒测试：是一种功能测试，就是将被测试系统看成一个黑盒，单纯从外界取得输入后进行输出。 ​ 白盒测试：逻辑测试，也叫结构测试，它把程序看成白盒，即测试时了解被测对象的内部逻辑结构，并且以程序内部的设计结构及具体的代码实现为基础来设计测试用例。 软甲测试分四步： ​ 单元测试，集成测试，系统测试，确认测试。 软件工程是计算机软件的一个重要的分支和研究方向。 软件生存周期：可行性分析和项目开发计划，需求分析，软件设计，编码，测试和维护6个阶段。 软件开发项目管理是指在软件生存周期中软件管理者所今进行的一系列活动，是软件系统或软件产品按原定的计划和质量要求如期完成。 软件开发项目管理：进度管理，成本管理，质量管理，人员管理，资源管理，标准化管理。 成本估算，风险分析，进度管理，人员管理。 风向分析的主要活动有风险识别，风险估算，风险管理策略，风险解决和风险监督。 面向对象 = 对象 + 分类 + 继承 + 通过消息的通信 多态是指同一个操作作用于不同的对象可以有不同的解释，产生不同的执行结果。 与多态密切相关的一个概念是动态绑定，传统的程序设计语言，把过程调用与目标代码的连接放在程序运行前进行，而动态绑定则是把这种连接推辞到运行时才进行。 软件测试方法： 静态测试又称为代码审查。通过对程序静态结构的检查，找出编译时不能发现的错误。 动态测试： 白盒测试：完全了解程序的内部结构和处理过程，它，根据程序的内部逻辑来设计程序用例，检查程序的逻辑通路是否都按预订的要求正确地工作。 黑盒测试：完全不考虑程序的内部结构和处理过程，而只是测试软件的外部特性。 软件测试的主要过程： 单元测试，也称为模块测试，通常采用白盒测试 组装测试，也称为集成测试，它是由各模块组装而成的程序进行测试，主要检查模块间的接口和通信。通常采用黑盒测试。 确认测试，检查软件的功能，性能以及其他特征是否与用户的需求一致。通常采用黑盒测试 系统测试：和其他因素结合在一起，进行信息系统的各种组装测试的确认测试，主要目的是通过与系统的需求相比较，来发现所开发的系统与用户需求不符合和矛盾的地方。 软件调试： 试探法，回溯法，对分查找法，归纳法，演绎法。 软件测试的目的及原则，软件测试是发现软件中错误和缺陷的主要手段。]]></content>
      <categories>
        <category>程序语言</category>
      </categories>
      <tags>
        <tag>程序语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown]]></title>
    <url>%2F2018%2F08%2F28%2Fmarkdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[换行：1.方法1： 连续两个以上空格+回车。 首行缩进两个字符：（每个表示一个空格，连续使用两个即可） 1.&amp;ensp;半角的空格 ​ 2.&emsp;全角的空格 字体、字号、颜色 - &lt;font color=red&gt;red&lt;/font&gt; - &lt;font color=blue&gt;blue&lt;/font&gt; - &lt;font color=green&gt;green&lt;/font&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2018%2F08%2F28%2FGit%2F</url>
    <content type="text"><![CDATA[GitHub基本概念 Repository： 开源项目 Issue： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个Issue ，然后这些问题逐个去修复，即一个一个Close掉。 Star：关注 Fork：引用别人的开源项目 Pull Request：在Fork的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 review, 就接受你的Pull Request。 Watch： Watch了该项目，它的任何更新消息，会通知你。 Gist： 单纯分享代码段。 ssh协议ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。 将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。 Git 命令git push origin master : 把本地代码推到远程master分支。 git pull origin master : 远程master的最新代码拉下来。 git remote add origin git@github.com:daihuiyou/Material.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。 在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里 git config -global user.name &quot;stromzhang&quot; git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot; Pull requests： 我们每个人都可以一起参与开发，一起来完善，而这都通过Pull requestss来完成。 fork 他人项目 git clone （fork 来项目） 在本地，自己修改这个项目 git push 到自己远程仓库 Pull requests 到 他人项目上 他人 reviews 你在他项目修改什么， 并觉得合理， 就接受你的PR。 完成这个项目的贡献。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会提问]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE%2F</url>
    <content type="text"><![CDATA[日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。 但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。 读书摘抄价值观： 苏格拉底说过的话:”我唯一所知的就是我一无所知。” 找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。 关键问题：论题和结论。 没有把证据支撑的断言称为纯观点。 写作建议：在写作之前最好确定好论题，引导读者得出你的结论 如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。 一个论证的表面结构由理由和结论两部分组成。 我们把没有明说出来的想法成为假设。 先检查理由，然后检查结论，寻找价值观假设和描述性假设。 假设越可疑，推理和结论的相关程度也就越小。 用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。 单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。 价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。 价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。 谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。 过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。 以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。 循环论证谬误指在推理过程中已然假设自己的结论成立的论证。 人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建流程]]></title>
    <url>%2F2018%2F08%2F20%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录总体的搭建流程 搭建Node.js环境：命令行使用node -v查看版本。 安装Hexo博客框架：npm install hexo-cli -g 安装git, git同步在github上。 开启GitHub Pages服务： 注意要选择主题，才有效。 创建文件夹，存放博客文件： hexo init myHexoBlog hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动服务 hexo与github关联起来 绑定域名 更换主题 安装git, git同步在github上git config --global user.name &quot;你的GitHub用户名&quot; git config --global user.email &quot;你的GitHub注册邮箱&quot; 生成ssh密钥文件：ssh-keygen -t rsa -C “你的GitHub注册邮箱” 然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制 打开GitHub_Settings_keys 页面，新建new SSH Key 在Git Bash中检测GitHub公钥设置是否成功，输入 ssh git@github.com hexo与github关联起来：打开站点的配置文件_config.ymldeploy: type: git repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git branch: master 绑定域名ping www.daihuiyou.github.io #得到IP值 第一步：在阿里云解析服务： 填写 主机记录www对应 daihuiyou.github.io 主机记录@对应 www.daihuiyou.github.io 主机记录www对应 185.199.111.153 主机记录@对应 185.199.111.153 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top 更换主题待更新。]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My New Post]]></title>
    <url>%2F2018%2F08%2F19%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[Have a good day!Cease to struggle and you cease to live.]]></content>
      <categories>
        <category>开篇</category>
      </categories>
      <tags>
        <tag>the first post.</tag>
      </tags>
  </entry>
</search>
