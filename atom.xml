<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Will&#39;s notebook</title>
  
  <subtitle>Share My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.daihuiyou.top/"/>
  <updated>2019-05-21T11:37:26.039Z</updated>
  <id>https://www.daihuiyou.top/</id>
  
  <author>
    <name>Will</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程</title>
    <link href="https://www.daihuiyou.top/2019/05/20/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.daihuiyou.top/2019/05/20/网络编程/</id>
    <published>2019-05-20T04:36:46.000Z</published>
    <updated>2019-05-21T11:37:26.039Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://raw.githubusercontent.com/DaiHuiYou/Material/master/gif/socket.gif" alt=""></p><h3 id="1-TCP连接的粘包问题"><a href="#1-TCP连接的粘包问题" class="headerlink" title="1. TCP连接的粘包问题"></a>1. TCP连接的粘包问题</h3><p>由于TCP是面向连接，二进制流传输，由于 Send()是发送给操作系统的缓冲区，并不是立即发送给客户端，等缓冲区有一定大小，再一次性发送给客户端。</p><p>所以由于这样的机制，多次消息的发送，可能一次性消息的接受。导致粘包问题，即是多个消息粘在一起发送。</p><ul><li><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5></li></ul><p>发送一次消息，等待接受消息，即判断对方是否接受到消息，确定对方接受到了消息，再继续发送下一条消息。</p><h3 id="2-多媒体文件传输"><a href="#2-多媒体文件传输" class="headerlink" title="2. 多媒体文件传输"></a>2. 多媒体文件传输</h3><p>多媒体文件并不是文本文件，采取文本文件读取，对方接受到多媒体文件无法解码。所以文件读取的方式采取是二进制。</p><ul><li><h5 id="传输文件的方法"><a href="#传输文件的方法" class="headerlink" title="传输文件的方法"></a>传输文件的方法</h5></li></ul><p>服务端：读取文件，连续 send()，直到发送完成。等待客户端接受完成消息。</p><p>客户端：接受服务端的消息，以二进制的方式存储到文件中，接受完成后，发送服务端接受完成消息。</p><h3 id="3-阻塞和非阻塞"><a href="#3-阻塞和非阻塞" class="headerlink" title="3. 阻塞和非阻塞"></a>3. 阻塞和非阻塞</h3><p>阻塞即是有消息则接受消息，没有消息则一直等待，不去执行其他操作。</p><p>在 TCP中 recv() 是采用阻塞方式接受。</p><p>非阻塞即有消息接受消息，没有消息则执行其他操作。</p><h3 id="4-多线程实现多个客户端连接"><a href="#4-多线程实现多个客户端连接" class="headerlink" title="4. 多线程实现多个客户端连接"></a>4. 多线程实现多个客户端连接</h3><p>多线程实现多个客户端连接，线程的数量等于客户端的数量， 当客户端连接数量大到一定程序，服务端容易崩溃。</p><h3 id="5-Select模型实现多个客户端连接"><a href="#5-Select模型实现多个客户端连接" class="headerlink" title="5. Select模型实现多个客户端连接"></a>5. Select模型实现多个客户端连接</h3><p>select 模型时 Winsock 中最常见的 I/0 模型， 它的中心思想是利用 select 函数，实现多个套接字 I/0 的管理。 利用 select 函数，可以判断套接字上是否存在数据，或则能否向一个套接字写入数据。 只有在条件满足时，才对套接字进行输出操作。</p><p>异步 I/0 模型通过调用 WSAAsynocSelect 函数实现，利用这个模型，应用程序可在一个套接字上接受以 windows 消息为基础的网络事件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="SOCKET" scheme="https://www.daihuiyou.top/categories/SOCKET/"/>
    
    
      <category term="SOCKET" scheme="https://www.daihuiyou.top/tags/SOCKET/"/>
    
  </entry>
  
  <entry>
    <title>python</title>
    <link href="https://www.daihuiyou.top/2019/05/18/python/"/>
    <id>https://www.daihuiyou.top/2019/05/18/python/</id>
    <published>2019-05-18T14:53:48.000Z</published>
    <updated>2019-05-18T15:22:50.110Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>在 Python 中定义函数， 可以用<strong>必选参数，默认参数，可变参数，关键字参数和命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意， 参数的定义顺序必须是： 必选参数，默认参数，可变参数， 命名关键字参数， 关键字参数。</p><hr><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><p>在函数内部， 可以调用其他函数。 如果一个函数在内部调用自身本身，这个函数就是递归函数。</p><p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试<code>fact(1000)</code>：</p><p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p><p>在很多编程语言中， 针对字符串提供了很多各种截取函数（substring），其实目的就是对字符串切片， <strong>Python没有针对字符串的截取函数，字需要切片一个操作就可以完成了。</strong></p><hr><h5 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h5><p>如果给定一个 list 或 tuple， 我们可以通过 for 循环来遍历这个 list 或 tuple， 这种编译我们称为 迭代（iteration）</p><p>在Python中，迭代是通过<code>for ... in</code>来完成的，而很多语言比如C语言，迭代 list 是通过下标完成的，比如 Java代码：</p><pre><code class="c++">for (i=0; i&lt;list.length; i++) {    n = list[i];}</code></pre><p>可以看出，Python的<code>for</code>循环抽象程度要高于C的<code>for</code>循环，因为Python的<code>for</code>循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p><p><strong>list 这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如 dict 就可以迭代：</strong></p><p>判断是否可迭代对象， 方法通过 collections 模块的 Iterable 类型判断</p><p>列表生成式即 List Comprehensions，是 Python 内置的非常简单却强大的可以用来创建 list 的生成式。</p><hr><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的 LIst， 从而节省大量的空间。 在Python中，这种一边循环一边计算的机制，称为生成器。</p><p>要创建一个 generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator</p><p>要一个一个打印出来，可以通过<code>next()</code>函数获得generator的下一个返回值</p><p>我们创建了一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，</p><p>定义generator的另一种方法。如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator：</p><p>generator和函数的执行流程不一样。函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>generator 是非常强大的工具， 在 Python中，可以简单地把列表生成式改成 generator， 也可以通过函数实现复杂逻辑的 generator。</p><p>生成器： 一个列表生成式的<code>[]</code>改成<code>()</code>,  普通函数变为 generator 就是把 函数体中加入 yelid。</p><p>普通函数调用直接返回结构， generator 函数的调用实际是一个generator对象。</p><hr><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>我们已经知道，可以直接作用于<code>for</code>循环的数据类型有以下几种：</p><p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p><p>一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p><p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code></p><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p><p>凡是可作用于 for 循环的对象都是 Iterable 类型</p><p>凡是可作用于 next() 函数的对象都是 Iterator 类型</p><p>集合数据类型如 list， dict， str 是 Iterable， 但不是 Iterator， 不过可以通过 iter() 函数获得一个 Iterator 对象。</p><p>Python 的 for 循环的本质就是通过不断调用 next() 函数实现的。</p><h5 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h5><p>函数式 Python 内建支持的一种封装， 我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。 函数就是面向过程的程序设计的基本单元。</p><p>函数式编程时一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数只要有输入是确定的，输出就确定。</p><p><strong>函数式编程的一个特点就是， 允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</strong></p><p>高阶函数</p><p>函数本身也可以赋值给变量，即： 变量可以指向函数。</p><p>函数名就是指向函数的变量。</p><p>传入函数： 一个函数可以接受另一个函数作为参数，这种函数就称之为高阶函数。</p><p>在数学总他们叫算子（运算符）或泛函。微积分总的导数就是常见的例子，因为它映射一个函数到另一个函数。</p><p>map / reduce  </p><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><p>filter</p><p>Python内建的<code>filter()</code>函数用于过滤序列。</p><p>和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>返回函数</p><p>把函数作为结果值返回</p><p>内部函数可以引用外部函数的参数和局部变量。当外部函数返回内部函数， 相关参数和变量都保存在返回的函数中，这种称为”闭包”（Closure）</p><p>返回函数时不要引用任何循环变量， 或者或许会发生变化的变量。</p><p>匿名函数</p><p>在传入函数是，有些时候，不需要显示的定义函数， 直接传入匿名函数更方便。</p><p>关键字 lambda 表示匿名函数，冒号前面表示函数参数。 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，在利用变量来调用函数。</p><p>匿名函数可以作为函数返回值返回</p><p>装饰器</p><p>由于函数也是一个对象， 而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p><p>增强函数的功能，在代码运行期间动态增加功能的方式，称之为 “ 装饰器 ”</p><p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式， OOP的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外， 直接从语法层次支持 decorator。 Python 的 decorator 可以用函数实现， 也可以用类表现。</p><p>偏函数（Partial function)</p><p>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分函数，从而在调用时更简单。</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p> 为了编写可维护的代码， 把很多函数分组，分贝放到不同的文件里。 在 Python 中， 一个 .py 文件就称之为一个模块 (Module)</p><p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。但不要与内置函数函数名字冲突。</p><p>为了解决不同的人编写的模块名相同， Python 引入了按目录来组织模块的方法， 称为包（Package）。</p><p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。</p><p>任何模块代码的第一个字符串都被视为模块的文档注释；</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过<code>_</code>前缀来实现的。</p><p>正常的函数和变量名是公开的（public），可以被直接引用，比如：<code>abc</code>，<code>x123</code>，<code>PI</code>等；</p><p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，<code>hello</code>模块定义的文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名；</p><p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p><p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p><h5 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h5><p>OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数， 每个对象都可以接受其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p><p>给对象发送消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。 </p><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的</p><p>通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问.</p><p>在Python中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p><p>继承和多态</p><p>新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态： 调用方只管调用，不管细节。 调用方和定义方可以责任分清。当我们新增一个 子类时， 只要确保 run()方法编写正确，不用管原来的代码是如何调用的。 这就是著名的 ‘<strong>开闭原则</strong> ’</p><p><strong>对扩展开放</strong>： 允许新增 Animal 子类；</p><p><strong>对修改封闭</strong>： 不需要修改依赖 Animal 类型的 run_twice 等函数</p><p>静态语言 vs 动态语言</p><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了</p><p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p><p>Python的“file-like object“就是一种<strong>鸭子类型</strong>。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><p>获取对象信息</p><p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断</p><p> 总是优先使用 isinstance() 判断类型，可以将指定类型及其子类“一网打尽”。</p><p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数</p><p>类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法</p><p>通过内置的一系列的函数，我们可以任意一个 Python 进行剖析，拿到其内部的数据。 要注意的是，只有在不知道对象信息的时候，我们才会获取对象信息。</p><p>实例属性和类属性</p><p>由于 Python 的动态语言，根据类创建的实例可以任意绑定属性。</p><p>给实例绑定属性的方法是通过实例变量， 或则通过 self 变量。</p><p>直接在class中定义属性，这种属性是类属性</p><p>实例属性属于各个实例所有，互不干扰。</p><p>类属性属于类所有，所有实例共享一个属性</p><p>不要对实例属性和类属性使用相同的名字，否则产生难以发现的错误。</p><p>使用  slots </p><p>通常情况下，上面的<code>set_score</code>方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><p>限制实例的属性， 只允许对 Student 实例添加 name 和 age 属性。为了达到限制的目的， 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</p><p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p><p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code></p><p>使用@property</p><p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用</p><p><code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p><p><code>@property</code>广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</p><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为 MixIn。</p><p>MixIn 的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p><p>定制类</p><p><code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p><p><code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的</p><p>如果一个类想被用于<code>for ... in</code>循环，类似list或tuple那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。</p><p>要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法</p><p>任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用</p><p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p><p>怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象</p><p>通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p><p>使用枚举类</p><p>枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p><p><code>Enum</code>可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。</p><p>Python提供了<code>Enum</code>类来实现这个功能：</p><pre><code class="python">from enum import EnumMonth = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))</code></pre><h5 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h5><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p><p>当Python解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的class对象</p><p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是class <code>Hello</code></p><p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出<code>Hello</code>类，而无需通过<code>class Hello(object)...</code>的定义：</p><p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类</p><p>metaclass</p><p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用 metaclass。</p><p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p><p>但是如果我们想创建出类呢？那就必须根据 metaclass 创建出类，所以：先定义 metaclass，然后创建类。</p><p>连接起来就是：先定义 metaclass，就可以创建类，最后创建实例。</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5><p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p><p>捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。好比一个员工处理不了一个问题时，就把问题抛给他的老板，如果他的老板也处理不了，就一直往上抛，最终会抛给CEO去处理。</p><p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个Error，还可以把一种类型的错误转化成另一种类型</p><p>调用栈： 如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。</p><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><ol><li><p>第一种方法： 简单直接粗暴有效，就是用<code>print()</code>把可能有问题的变量打印出来看看。</p><p>用<code>print()</code>最大的坏处是将来还得删掉它，想想程序里到处都是<code>print()</code>，运行结果也会包含很多垃圾信息。</p></li><li><p>第二种方法： 断言， 凡是用<code>print()</code>来辅助查看的地方，都可以用断言（assert）来替代：</p><p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p></li><li><p>第三种方法： logging() 替换为 logging 是第 3 种方式 ， 和 assert 比， logging 不会抛出错误， 而且可以输出文件。</p><p><code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p><p><code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件</p></li><li><p>启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态. </p></li><li><p>pdb.set_trace() ,这个方法也是用 pdb，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点</p></li></ol><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><p>测试驱动开发”（TDD：Test-Driven Development）。</p><p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p><p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p><p>每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的</p><p>另一种重要的断言就是期待抛出指定类型的Error，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code></p><p>单元测试是用来对一个模块，一个函数或则一个类来进行正确性检验的测试工作。</p><p>单元测试通过后有什么意义呢？如果我们对<code>abs()</code>函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对<code>abs()</code>函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。</p><p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。</p><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p><p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p><p>文档测试</p><p>Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</p><p><strong>实现自动执行写在注释中的这些代码</strong></p><p>doctest 非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest 的注释提取出来。用户看文档的时候，同时也看到了doctest。</p><h5 id="IO-编程"><a href="#IO-编程" class="headerlink" title="IO 编程"></a>IO 编程</h5><p>IO 在计算机中指 Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要 IO接口。</p><p>同步IO 是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10秒 后写入磁盘，再接着往下执行。</p><p>异步IO 是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行。</p><p>同步和异步的区别就在于是否等待 IO 执行的结果。</p><h5 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h5><p>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p><p>Python引入了 <code>with</code> 语句来自动帮我们调用<code>close()</code>方法</p><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p><p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p><h5 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h5><p>很多时候，数据读写不一定是文件，可以在内存中读写。 </p><p>StringIO 顾名思义就是在内存中读写 str</p><p>StringIO 和 ByteIO 是在内存中中操作 str 和 bytes 的方法， 使得和读写文件具有一致的接口</p><p>操作文件和目录</p><p>操作系统提供的命令指示简单地调用了操作系统的提供的接口函数， Python 内置的 os 模块也可以直接调用操作系统提供的接口函数</p><p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符</p><p>要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p><p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便</p><p>Python的<code>os</code>模块封装了操作系统的目录和文件操作，要注意这些函数有的在<code>os</code>模块中，有的在<code>os.path</code>模块中</p><p>序列化</p><p>在程序运行过程中， 所有的变量都是在内存中，我们把变量从内存中变成可存储或传输的过程称之为序列化。 在 Python 中叫 picking， 在其他语言中也被称之为 serialization， marshalling， flattening 等等。</p><p>序列化之后， 就可以把序列化后的内容写入磁盘，或则通过网络传输到别的机器上。</p><p>反过来， 把变量内容从序列化的对象重新读到内存里称之为反序列化。 即 unpickling。 </p><p>Python提供了<code>pickle</code>模块来实现序列化</p><p>JSON</p><p>如果我们在不同的编程语言之间传递对象，就必须把对象序列化为标准格式， 比如 XML， 但更好的方法是序列化为 JSON， 因为 JSON 表示出来就是一个字符串，可以被所有语言读取， 也可以方便存储到磁盘或则通过网络传输。 JSON 不仅是标准格式， 并且比 XML 更快， 而且直接在 Web 页面读取。</p><p>JSON 表示的对象就是标准的 JavaScript 语言的对象</p><p>Python内置的<code>json</code>模块提供了非常完善的Python对象到 JSON 格式的转换</p><p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p><p>通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class</p><p>Python 语言特定的序列化模块是 pickle， 但如果把序列化搞得更通用， 更符合 Web 标准， 就可以使用 json 模块。 <code>json</code>模块的<code>dumps()</code>和<code>loads()</code>函数是定义得非常好的接口的典范</p><h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h5><p>多任务： 就是操作系统可以同时运行多个任务。 单核 CPU， 也可以执行多任务。 真正的并行执行多任务只能在多核 CPU 上实现， 但是， 由于任务数量远远多于 CPU 的核心数量， 所以，操作系统也会自动把任务轮流调度到每个核心上执行。</p><p>多个线程可以同时执行， 多线程的执行范式和多进程一样，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样， 当然，正确地同时执行多线程需要多核 CPU 才可能实现。 </p><p>我们要同时执行多个任务：第一种方法， 启动多个进程， 每个进程虽然只有一个线程， 但多个进程可以一块执行多个任务。  第二种方法，启动一个进程，在一个进程内启动多个线程，这样，多个线程可以一块执行多个任务。</p><p>多任务的实现 3 种方式：</p><ol><li>多进程模式：</li><li>多线程模式：</li><li>多进程 + 多线程模式</li></ol><p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调。</p><p>线程是最小的执行单元， 而进程有至少一个进程组成，如何调度进程和线程，完全有操作系统决定，程序自己不能决定什么时候执行， 执行多长时间。</p><h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p><p><strong>子进程永远返回<code>0</code>，而父进程返回子进程的ID</strong>。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p><p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程。</p><h5 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h5><p>Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块</p><p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象</p><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p><p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h5 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h5><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p><p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p><p>由于<code>Pool</code>的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p><h5 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h5><p>在Unix/Linux下，可以使用<code>fork()</code>调用实现多进程。</p><p>要实现跨平台的多进程，可以使用<code>multiprocessing</code>模块。</p><p>进程间通信是通过<code>Queue</code>、<code>Pipes</code>等实现的。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>多线程和多进程最大不同在于， 多进程中，同一个变量，各自有一份拷贝在每个进程中，互不影响，而多线程中，所有变量都有所有线程共享，所有，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时该一个变量， 把内容改乱。</p><p>高级语言的一条语句在 CPU 执行时是若干条语句</p><p>锁的好处是确保了某段关键代码只能由一个线程从头到尾地执行，坏处当然也很多，首先阻止了多线程的并发执行，不同的线程持有不同的锁，可能会造成死锁，导致多个线程全部挂起。</p><h5 id="多核-CPU"><a href="#多核-CPU" class="headerlink" title="多核 CPU"></a>多核 CPU</h5><p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p><p>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。</p><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="python" scheme="https://www.daihuiyou.top/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://www.daihuiyou.top/2019/01/04/%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.daihuiyou.top/2019/01/04/排序/</id>
    <published>2019-01-04T05:13:37.000Z</published>
    <updated>2019-03-04T14:38:40.889Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><h3 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1 . 选择排序"></a>1 . 选择排序</h3><pre><code class="c++">// 未优化template&lt;typename T&gt;void selectionSort1(T arr[], int n){    for (int i = 0; i &lt; n; i++) {        for (int j = i + 1; j &lt; n; j++) {            if (arr[j] &lt; arr[i])                swap(arr[j], arr[i]);        }    }    return;}// 优化template &lt;typename T&gt;void selectionSort2(T arr[], int n){    for (int i = 0; i &lt;= n - 1; i++){        int minIndex = i;        for (int j = i+1; j &lt;= n - 1; j++) {            if (arr[minIndex] &gt; arr[j])                minIndex = j;        }        swap(arr[minIndex], arr[i]);    }    return;}</code></pre><ul><li>测试</li></ul><p>从 1 万个 0~100 的随机数中，从小到大排序。</p><p>selectionSort1 :  <font color="red"> 2.208 s </font></p><p>selectionSort2  : <font color="red">0.108 s</font></p><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><pre><code class="c++">// 未优化template&lt;typename T&gt;void InsertionSort1(T arr[], int n){    for (int i = 1; i &lt; n; i++)    {        for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) {            swap(arr[j], arr[j - 1]);        }    }    }// 优化template&lt;typename T&gt;void InsertionSort2(T arr[], int n) {    for (int i = 1; i &lt; n; i++) {        T e = arr[i];        int j;        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--)            arr[j] = arr[j - 1];        arr[j] = e;    }    return;}</code></pre><ul><li>测试</li></ul><p>从1万个 0~100 的随机数中，从小到大排序。</p><p>InsertionSort1 : <font color="red">2.653 s </font></p><p>InsertionSort2 : <font color="red">0.064 s</font></p><h3 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3. 希尔排序"></a>3. 希尔排序</h3><pre><code class="c++">// 希尔排序template&lt;typename T&gt;// n 表示数组 capacityvoid shellSort(T arr[], int n){    int cnt = n - 1;  // 数组元素个数    int tmp = 0;       // 临时变量    // d：distance，     for (int d = n/2; d&gt;=1; d=d/2) {        // 遍历        for (int i = d; i &lt;=cnt; i++) {            // 插入排序            tmp = arr[i];            for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) {                arr[j + d] = arr[j];                arr[j] = tmp;            }        }    }}</code></pre><ul><li><p>测试</p><p>从 1 万个 0~100 的随机数中，从小到大排序。</p><p>Insertion Sort  :  <font color="red">6.332 s </font></p><p>Shell Sort       : <font color="red">0.029 s</font></p></li></ul><h2 id="O-nlogN"><a href="#O-nlogN" class="headerlink" title="O(nlogN)"></a>O(nlogN)</h2><h3 id="1-归并排序"><a href="#1-归并排序" class="headerlink" title="1. 归并排序"></a>1. 归并排序</h3><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. 快速排序</h3><pre><code class="c++">int __partition(int arr[], int l, int r){    int v = arr[l];    int j = l;    for (int i = l + 1; i &lt;= r; i++) {        if (arr[i] &lt; v) {            j++;            swap(arr[i], arr[j]);        }    }    swap(arr[j], arr[l]);    return j;}void __quickSort(int arr[], int l, int r){    if (l &gt;= r)        return;    int p = __partition(arr, l, r);    __quickSort(arr, l, p - 1);    __quickSort(arr, p + 1, r);}// 快速排序void quickSort(int arr[], int n){    __quickSort(arr, 0, n - 1);}</code></pre><h3 id="3-堆排序"><a href="#3-堆排序" class="headerlink" title="3. 堆排序"></a>3. 堆排序</h3><pre><code class="c++">void shiftDown(int arr[], int n, int k){    while (2 * k + 1 &lt; n) {        int j = 2 * k + 1;        if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) {            j++;        }        if (arr[k] &lt; arr[j]) {            swap(arr[k], arr[j]);            k = j;        }        else            break;    }}void heapSort1(int arr[], int n){    // heapify    for (int i = (n - 1) / 2; i &gt;= 0; i--) {        shiftDown(arr, n, i);    }    for (int i = n - 1; i &gt; 0; i--) {        swap(arr[0], arr[i]);        shiftDown(arr, i, 0);    }}// n 为数组元素个数// k 当前要筛选的索引// arr[0] 为临时存储变量void shift(int arr[], int n, int k) {    while (2 * k &lt; n) {        int j = 2 * k;        if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1])            j++;        if (arr[k] &lt; arr[j]) {            // arr[j] 与 arr[k] 交换            arr[0] = arr[j];            arr[j] = arr[k];            arr[k] = arr[0];            k = j;        }        else             break;    }}// n 为数组元素个数// arr[0] 为临时存储变量void heapSort2(int arr[], int n){    for (int i = (n - 1) / 2; i &gt;= 1; i--) {        shift(arr, n, i);    }    for (int i = n - 1; i &gt;=2; i--) {        // arr[i] 与 arr[1] 交换        arr[0] = arr[i];        arr[i] = arr[1];        arr[1] = arr[0];        shift(arr, i, 1);    }}</code></pre><ul><li><p>测试</p><p>从100 万个 0~100 的随机数中，从小到大排序。</p><p>Heap Sort 1 : <font color="red">2.228 s </font></p><p>Heap Sort 2 : <font color="red">0.248 s</font></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="c++" scheme="https://www.daihuiyou.top/categories/c/"/>
    
    
      <category term="算法与数据结构" scheme="https://www.daihuiyou.top/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++Primer</title>
    <link href="https://www.daihuiyou.top/2018/12/02/C++Primer/"/>
    <id>https://www.daihuiyou.top/2018/12/02/C++Primer/</id>
    <published>2018-12-02T14:04:10.000Z</published>
    <updated>2018-12-13T12:49:32.970Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Variables-and-Basic-Types"><a href="#Variables-and-Basic-Types" class="headerlink" title="Variables and Basic Types"></a><strong>Variables and Basic Types</strong></h2><p>C++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably.</p><p>To support 「separate complication」, C++ distinguishes between declaration  and definition.</p><p>The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs.</p><h3 id="1-Main-Function-and-Library"><a href="#1-Main-Function-and-Library" class="headerlink" title="1. Main Function  and Library"></a><strong>1. Main Function  and Library</strong></h3><p>「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main.</p><p>Standard library collection of types and function that every C++ compiler must support.</p><p>They also tend to refer to particular  part of the library by referring to a  library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes.</p><p>By default, reading cin flushes cout,  cout is also flushed when the program end normally.</p><p>To handle input, we use an object of type istream named cin, This object is also referred to as the standard input.</p><p>In C++ an expression yields a result.</p><p>When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1.</p><p>The word 「nullptr」 is a pointer literal. </p><p>The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand.</p><p>To attain a declaration that is not also a definition, add the 「extern」 keyword.</p><p>An extern that has an initializer is a definition.</p><h3 id="2-Variables"><a href="#2-Variables" class="headerlink" title="2. Variables"></a><strong>2. Variables</strong></h3><ul><li>Initialization</li></ul><p>Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one.</p><p>Uninitialized objects of <em>built-in type</em> defined inside a function body have undefined value. Objects of <em>class type</em> that we do not explicitly initialize have a value that is defined by the class.</p><p>We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.</p><p>Separate compilation lets us split our programs into several files, each of which can be compiled independently.</p><ul><li>Declaration and Definition</li></ul><p>To support separate compilation, C++ distinguishes between declarations and definitions.</p><p>To obtain a <em>declaration</em> that is not also a definition, we add the <em>extern</em> keyword and may not provide an explicit initializer:</p><pre><code class="c++">extern int i;   // declares but does not define iint j;          // declares and defines j</code></pre><p>Variables must be defined exactly once but can be declared many times.</p><p>To use a variable in more than one file requires declarations that are separate from the variable’s definition.</p><p>To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files  that use that variable must declare—but not define—that variable.</p><ul><li>Reference</li></ul><p>A reference is not an object. Instead, a reference is just another name for an already existing object.</p><p>A reference must be initialized</p><p>A reference may be bound only to an object, not to a literal or to the result of a more general expression:</p><p>Unlike a reference, a pointer is an object in its own right.</p><p>Unlike a reference , a pointer need not be initialized at the time it is defined.</p><p>references are not objects, they don’t have addresses. Hence, we may not define a pointer  to a reference.</p><h3 id="3-Pointer"><a href="#3-Pointer" class="headerlink" title="3. Pointer"></a><strong>3. Pointer</strong></h3><ul><li>Pointer Value</li></ul><p>The types must match because <em>the type of the pointer</em> is used to infer the type of the object to which the pointer points.</p><p>It can be a  null pointer , indicating that it is not bound to any object.</p><ul><li>Using a Pointer to Access an object</li></ul><p>When a pointer points to an object, we can use the <em>dereference</em> operator (the * operator) to access that object:</p><p>We may dereference only a valid pointer that points to an object.</p><p>Dereferencing a pointer yields the object to which the pointer points.</p><ul><li>Null Pointers</li></ul><p>A null pointer does not point to any object.</p><p>Older programs sometimes use a preprocessor variable named <em>NULL</em>, which the cstdlib header defines as 0.</p><p><em>nullptr</em> is a literal that has a special type that can be converted  to any other pointer type.</p><p>Modern C++ programs generally should avoid using NULL and use nullptr instead.</p><ul><li>void* Pointers</li></ul><p>The type void* is a special pointer type that can hold the address of any object.</p><p>We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object.</p><ul><li>Understanding Compound Type Declarations</li></ul><p>A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types</p><ul><li>Reference to Pointers</li></ul><p>A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer.</p><pre><code class="c++">int i = 42;int *p;            // p is a pointer to intint *&amp;r = p;       // r is a reference to the pointer pr = &amp;i;         //  r refers to a pointer; assigning &amp;i to r makes p point to i*r = 0;     //  dereferencing r yields i, the object to which p points; changes i to//  the base type of the declaration says that r is a reference to a pointer to an int.</code></pre><p>It can be easier to understand complicated pointer or reference declarations if you read them from right to left.</p><h3 id="4-const-Qualifier"><a href="#4-const-Qualifier" class="headerlink" title="4. const Qualifier"></a><strong>4. const Qualifier</strong></h3><p>By Default, const Objects Are Local to a File</p><p>We want to define the const in one file, and declare it in the other files that use that object.</p><p>To share a const object among multiple files, you must define the variable as extern.</p><ul><li>References to const</li></ul><pre><code class="c++">const int ci = 1024;const int &amp;r1 = ci;   // ok: both reference and underlying object are constr1 = 42;              // error: r1 is a reference to constint &amp;r2 = ci;         // error: non const reference to a const object</code></pre><ul><li>Initialization and Reference to const</li></ul><p>In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression</p><p>A Reference to const May Refer to an Object That Is Not const</p><pre><code class="c++">int i = 42;int &amp;r1 = i;          // r1 bound to iconst int &amp;r2 = i;    // r2 also bound to i; but cannot be used to change ir1 = 0;               // r1 is not const; i is now 0r2 = 0;               // error: r2 is a reference to const</code></pre><ul><li>const Pointers  and Pointer to const</li></ul><p>Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const.</p><p>We use the term top-level const to indicate that the pointer itself is a const.</p><p>When a pointer can point to a const object, we refer to that const as a low-level const.</p><p>The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored</p><pre><code class="c++">int errNumb = 0;int *const curErr = &amp;errNumb;  // curErr will always point to errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; // pip is a const pointer to a const object</code></pre><p>On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects.</p><pre><code class="c++">int *p = p3; // error: p3 has a low-level const but p doesn&#39;tp2 = p3;     // ok: p2 has the same low-level const qualification as p3</code></pre><ul><li>constexpr and Constant Expressions</li></ul><p>A constant expression is an expression whose value cannot change and that can be evaluated at compile time.</p><p>Such functions must be simple enough that the compiler can evaluate them at compile time.</p><p>Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions.</p><ul><li>Pointers and constexpr</li></ul><pre><code class="c++">const int *p = nullptr;     // p is a pointer to a const intconstexpr int *q = nullptr; // q is a const pointer to int</code></pre><p>The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines.</p><pre><code class="c++">constexpr int *np = nullptr; // np is a constant pointer to int that is nullint j = 0;constexpr int i = 42;  // type of i is const int// i and j must be defined outside any functionconstexpr const int *p = &amp;i; // p is a constant pointer to the const int iconstexpr int *p1 = &amp;j;      // p1 is a constant pointer to the int j</code></pre><h3 id="5-Dealing-with-Types"><a href="#5-Dealing-with-Types" class="headerlink" title="5. Dealing with Types"></a><strong>5. Dealing with Types</strong></h3><ul><li>Type Aliases</li></ul><p>Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used.</p><p>We can define a type alias in one of two ways. Traditionally, we use a typedef</p><pre><code class="c++">typedef char *pstring;const pstring cstr = 0; // cstr is a constant pointer to charconst pstring *ps;      // ps is a pointer to a constant pointer to char</code></pre><p>When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char<em>, the base type is char and the </em> is part of the declarator.</p><ul><li>The auto Type Specifier</li></ul><p>Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer.</p><ul><li>The decltype Type Specifier</li></ul><p>Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable.</p><p>For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand.</p><p>The compiler analyzes the expression to determine its type but does not evaluate the expression:</p><pre><code class="c++">decltype(f()) sum = x; // sum has whatever type f returnsconst int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x has type const intdecltype(cj) y = x; // y has type const int&amp; and is bound to xdecltype(cj) z;     // error: z is a reference and must be initialized</code></pre><ul><li>decltype and References</li></ul><p>Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment</p><pre><code class="c++">// decltype of an expression can be a reference typeint i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;  // ok: addition yields an int; b is an (uninitialized) intdecltype(*p) c;     // error: c is int&amp; and must be initialized// decltype of a parenthesized variable is always a referencedecltype((i)) d;    // error: d is int&amp; and must be initializeddecltype(i) e;      // ok: e is an (uninitialized) int// The type is a reference to the type of the left-hand operand.int a = 3, b = 4;decltype(a) c = a;decltype(a = b) d = a; //  equal to :int &amp;d = a;</code></pre><p>Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression.</p><h3 id="6-Defining-Our-Own-Data-Structures"><a href="#6-Defining-Our-Own-Data-Structures" class="headerlink" title="6. Defining Our Own Data Structures"></a><strong>6. Defining Our Own Data Structures</strong></h3><p>In C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes.</p><ul><li>Defining the Sales_data Type</li></ul><pre><code class="c++">struct Sales_data {    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><p>The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body.</p><p>It is a common mistake among new programmers to forget the semicolon at the end of a class definition.</p><ul><li>Writing Our Own Header Files</li></ul><p>In order to ensure that the class definition is the same in each file, classes are usually defined in header files. </p><p>classes are stored in headers whose name derives from the name of the class.</p><p>Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations.</p><ul><li>A Brief Introduction to the Preprocessor</li></ul><p>The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs.</p><p>Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.</p><p>Preprocessor variables have one of two possible states: defined or not defined.</p><p>The #define directive takes a name and defines that name as a preprocessor variable.</p><p>#ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined.</p><p>If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.</p><p>Preprocessor variable names do not respect C++ scoping rules.</p><p>Preprocessor variables, including names of header guards, must be unique throughout the program.</p><h3 id="7-Defined-Terms"><a href="#7-Defined-Terms" class="headerlink" title="7. Defined Terms"></a><strong>7. Defined Terms</strong></h3><p><strong>const reference</strong> Colloquial synonym for reference to const.</p><p><strong>constant expression</strong> Expression that can be evaluated at compile time.</p><p><strong>declaration</strong> Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared.</p><p><strong>definition</strong> Allocates storage for a variable of a specified type and optionally initializes the variable.</p><p><strong>object</strong> A region of memory that has a type. A variable is an object that has a name.<br>outer scope Scope that encloses another scope.</p><p><strong>preprocessor variable</strong> Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled.</p><p><strong>reference</strong> An alias for another object.</p><p><strong>struct</strong> Keyword used to define a class.</p><p><strong>typedef Defines</strong> an alias for another type.</p><p><strong>void* Pointer</strong> type that can point to any nonconst type. Such pointers may not be dereferenced.</p><h2 id="Strings-Vectors-and-Arrays"><a href="#Strings-Vectors-and-Arrays" class="headerlink" title="Strings, Vectors, and Arrays"></a><strong>Strings, Vectors, and Arrays</strong></h2><p>C++ defines a rich library of abstract data types.</p><p>Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections.</p><p>Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector.</p><p>The built-in types represent facilities present in most computer hardware, such as numbers or characters.</p><p>The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly.</p><p>A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type.</p><h3 id="1-Namespace-using-Declaration"><a href="#1-Namespace-using-Declaration" class="headerlink" title="1. Namespace using Declaration"></a><strong>1. Namespace using Declaration</strong></h3><p>Headers Should Not Include using Declarations.</p><p>If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.</p><h3 id="2-Library-string-Type"><a href="#2-Library-string-Type" class="headerlink" title="2. Library string Type"></a><strong>2. Library string Type</strong></h3><p>A string is a variable-length sequence of characters. To use the string type, we must include the string header.</p><p>When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created.</p><p>Otherwise, when we omit the =, we use direct initialization.</p><pre><code class="c++">string s5 = &quot;hiya&quot;;  // copy initializationstring s6(&quot;hiya&quot;);   // direct initializationstring s7(10, &#39;c&#39;);  // direct initialization; s7 is cccccccccc</code></pre><p>The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered.</p><p>Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator.</p><ul><li>Adding Literals and strings</li></ul><p>When we mix strings and string or character literals, at least one operand to each + operator must be of string type</p><ul><li>Dealing with the Characters in a string</li></ul><p>In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. </p><p>The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c.</p><p>The c indicates that the header is part of the C library.</p><ul><li>Processing Every Character? Use Range-Based for</li></ul><p>If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」.</p><p>The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence.</p><p>On each iteration, the variable in declaration is initialized from the value of the next element in expression.</p><ul><li>Using a Range for to Change the Characters in a string</li></ul><p>If we want to change the value of the characters in a string, we must define the loop variable as a reference type.</p><pre><code class="c++">string s(&quot;Hello World!!!&quot;);// convert s to uppercasefor (auto &amp;c : s)   // for every char in s (note: c is a reference)    c = toupper(c); // c is a reference, so the assignment changes the char in scout &lt;&lt; s &lt;&lt; endl;</code></pre><ul><li>a subscript</li></ul><p>The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position.</p><p>Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1].</p><p>The value in the subscript is referred to as 「a subscript」 or 「an index」.</p><p>The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined.</p><h3 id="3-Library-vector-Type"><a href="#3-Library-vector-Type" class="headerlink" title="3. Library vector Type"></a><strong>3. Library vector Type</strong></h3><p>A vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. </p><p>A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」.  Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions.</p><p>The process that the compiler uses to create classes or functions from templates is called 「instantiation」.</p><pre><code class="c++">vector&lt;int&gt; ivec;             // ivec holds objects of type intvector&lt;Sales_item&gt; Sales_vec; // holds Sales_itemsvector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors</code></pre><p>「vector is a template, not a type.」 Types generated from vector must include the element type.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h2><p>Conventions for Variable Names：变量名称的约定</p><p>separate compilation：独立编译</p><p>tend to：倾向于</p><p>fits in：适合</p><p>so far：目前为止</p><p>the indicated value: 指定的值</p><p>yields a result : 产生一个结果</p><p>bound to (bind to) :绑定</p><p>plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析</p><p>evaluated : 求…值</p><p>do not respect C++ scoping rules: 不遵守作用域规则</p><p> be used to： 用于</p><table><thead><tr><th><em>associative:联合</em></th><th><em>container:容器，集装箱</em></th><th><em>derived-Class: 派生类/子类</em></th></tr></thead><tbody><tr><td><em>alias:别名</em></td><td><em>override: 重写</em></td><td><em>overloading: 重载</em></td></tr><tr><td><em>directive:指令</em></td><td><em>redirect: 重定向</em></td><td><em>indicator:指示</em></td></tr><tr><td><em>arguments: 实参</em></td><td><em>library facility:库功能 (工具库)</em></td><td><em>statements:语句</em></td></tr><tr><td><em>extensive: 大规模</em></td><td><em>mechanisms: 机制</em></td><td><em>string literal: 字符串字面量</em></td></tr><tr><td><em>semicolon: 分号</em></td><td><em>block: 代码块</em></td><td><em>iteration: 重复</em></td></tr><tr><td><em>comments: 注释</em></td><td><em>built-in type： 内置类型</em></td><td><em>backslash： 反斜杠</em></td></tr><tr><td><em>carriage return： 回车</em></td><td><em>Escape Sequences: 转义序列</em></td><td><em>initializer: 初始化</em></td></tr><tr><td><em>commas： 逗号</em></td><td><em>type specifier: 类型说明符</em></td><td><em>Identifiers: 标识符</em></td></tr><tr><td><em>inclusive：包括</em></td><td><em>Nested Scopes：嵌套范围</em></td><td><em>fetch: 获取</em></td></tr><tr><td><em>type modifiers: 类型修饰符</em></td><td><em>underlying: 底层</em></td><td><em>Qualifier: 限定符</em></td></tr><tr><td><em>plain: 原始,素</em></td><td><em>synonym: 同义词</em></td><td><em>groups: 分组</em></td></tr><tr><td><em>implement：实现</em></td><td>strategy：a plan of action 策略</td><td>contents:内容</td></tr><tr><td>cover: 介绍 / 覆盖</td><td>punctuation: 标点</td><td>capitalize: 大写字母</td></tr><tr><td>subscript：下标</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="原版书籍" scheme="https://www.daihuiyou.top/categories/%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="原版书籍" scheme="https://www.daihuiyou.top/tags/%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>硅谷来信</title>
    <link href="https://www.daihuiyou.top/2018/11/30/%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1/"/>
    <id>https://www.daihuiyou.top/2018/11/30/硅谷来信/</id>
    <published>2018-11-30T15:21:45.000Z</published>
    <updated>2019-01-06T14:38:49.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="收获比较大的方面："><a href="#收获比较大的方面：" class="headerlink" title="收获比较大的方面："></a>收获比较大的方面：</h3><ul><li>学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。</li><li>科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 </li><li>科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 </li><li>结论可以证实，但不可证伪。为什么呢？  就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？  总之， 因为未来的不确定，结论可以证实，不能证伪。</li><li>别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。</li></ul><h3 id="语录："><a href="#语录：" class="headerlink" title="语录："></a>语录：</h3><ul><li>对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="书籍" scheme="https://www.daihuiyou.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>算法精解</title>
    <link href="https://www.daihuiyou.top/2018/11/22/%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3/"/>
    <id>https://www.daihuiyou.top/2018/11/22/算法精解/</id>
    <published>2018-11-22T11:54:02.000Z</published>
    <updated>2018-11-30T15:17:10.088Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p><img src="https://i.imgur.com/SO1tRes.png" alt=""></p><pre><code class="c">#ifndef LIST_H#define LIST_H/*  funciton process result */typedef enum Result_{    FALSE = -1,    TRUE  = 0}Result;/* Define a structure for linked lists */typedef struct ListElmt_{    void                *data;    struct ListElmt_    *next;}ListElmt;/* Define a structure for linked lists */typedef struct List_{    int            size;    ListElmt    *head;    ListElmt    *tail;    int    (*match)(const void *key1, const void *key2);    void(*destroy)(void *data);}List;/* Public Interface */void list_init(List *list, void(*destroy)(void *data));void list_destory(List *list);int list_ins_next(List *list, ListElmt *element, const void *data);int list_rem_next(List *list, ListElmt *element, void **data);void list_destory(List *list);/* role : inline function*/#define list_size(list) ((list)-&gt;size)#define list_head(list) ((list)-&gt;head)#define list_tail(list) ((list)-&gt;tail)#define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0)#define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0)#define list_data(list) ((list)-&gt;data)#define list_next(list) ((list)-&gt;next)#endif</code></pre><pre><code class="c++">/* list.c */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;list.h&quot;/* list_init */void list_init(List * list, void(*destroy)(void *data)){    /* Initialize the list. */    list-&gt;size = 0;    list-&gt;destroy =     destroy;    list-&gt;head = NULL;    list-&gt;tail = NULL;    return;}/* list_destory */void list_destory(List *list){    void        *data;    /* Remove each element */    while (list_size(list) &gt; 0) {        if (list_rem_next(list, NULL, (void**)&amp;data) == 0             &amp;&amp; list-&gt;destroy != NULL){            /* Call a user-defined function to free dynamically data */            list-&gt;destroy(data);         }    }    /* No operations are allowed now, but clear the structure as a precautions */    memset(list, 0, sizeof(List));     return;}</code></pre><pre><code class="c++">/* list_ins_next *//* The ListElmt *element has the next pointer information , the next pointer is not null */int list_ins_next(List * list, ListElmt * element, const void * data){    ListElmt        *new_element;    /* Allocate storage for the element */    if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) {        return -1;    }    /* Insert the element into the list */    new_element-&gt;data = (void *)data;    if (element == NULL) {        /* Handle insertion at the head of the list */        if (list_size(list) == 0)            list-&gt;tail = new_element;        new_element-&gt;next = list-&gt;head;        list-&gt;head = new_element;    }    else {        /* Handle insertion somewhere other than at the head */        if (element-&gt;next == NULL)            list-&gt;tail = new_element;        new_element-&gt;next = element-&gt;next;        element-&gt;next = new_element;    }    /* Adjust the size of the list to account for the inserted element */    list-&gt;size++;    return 0;}/* list_rem_next */int list_rem_next(List *list, ListElmt *element, void **data){    ListElmt        *old_element;    /* Do not allow removal an empty list */    if (list-&gt;head == NULL)        return -1;    /* Remove the element from the list */    if (element == NULL) {        /* Handle removal from the head of the list */        *data = list-&gt;head-&gt;data; //Generic pointer        old_element = list-&gt;head;        list-&gt;head = list-&gt;head-&gt;next;        if (list_size(list) == 1)            list-&gt;tail = NULL;    }    else {        /* Handle removal from somewhere other than the head */        if (element-&gt;next == NULL)            return -1;        *data = element-&gt;next-&gt;data;        old_element = element-&gt;next;        element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember.    }    /* Free the storage allocated by the abstract datatype */    free(old_element);    /* Adjust the sizeof the list to account for the removal element */    list-&gt;size--;    return 0;}</code></pre><h3 id="使用链表的例子：-页帧管理"><a href="#使用链表的例子：-页帧管理" class="headerlink" title="使用链表的例子： 页帧管理"></a>使用链表的例子： 页帧管理</h3><p>​    <img src="https://i.imgur.com/d1GUdHJ.png" alt=""></p><h3 id="泛型指针"><a href="#泛型指针" class="headerlink" title="泛型指针"></a>泛型指针</h3><ul><li>很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型</li></ul><h3 id="泛型指针和句柄的差别"><a href="#泛型指针和句柄的差别" class="headerlink" title="泛型指针和句柄的差别"></a>泛型指针和句柄的差别</h3><h5 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h5><ul><li>设计者： 设计函数的人</li><li><p>调用者： 调用函数的人</p></li><li><p>void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。</p></li><li>句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="书籍" scheme="https://www.daihuiyou.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>暗时间</title>
    <link href="https://www.daihuiyou.top/2018/11/16/%E6%9A%97%E6%97%B6%E9%97%B4/"/>
    <id>https://www.daihuiyou.top/2018/11/16/暗时间/</id>
    <published>2018-11-16T04:36:46.000Z</published>
    <updated>2019-01-06T14:40:19.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="暗时间"><a href="#暗时间" class="headerlink" title="暗时间"></a>暗时间</h3><ol><li>善于利用<strong>思维时间</strong>的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。</li><li>如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“<strong>暗时间</strong>”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。</li><li>能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在《How We Decide》上看到斯坦福的一个牛人，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越？<font color="red">（思维方式）</font></li><li><strong>能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。</strong></li><li>因此这里就涉及到最后一个高效的习惯：<strong>抗干扰</strong>。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。</li></ol><h3 id="设计你自己的进度条"><a href="#设计你自己的进度条" class="headerlink" title="设计你自己的进度条"></a>设计你自己的进度条</h3><ol><li><p>进度条的设计是一个很多人都知道的故事：同样的耗时，如果不给任何进度提示，只是在完成之后才弹出一个完成消息，中间没有任何动态变化，那么整个过程就会让人等得非常焦急，导致一些人干脆把程序关了了事。如果有进度不断更新，那么对整个过程耗时的心理感受就会远低于实际值，用户也不会郁闷到把程序关了。</p></li><li><p>善于规划的人，会将目标分割成一个个的里程碑，再将里程碑分割成 TODO 列表。前阵子流行的 GTD 方法学，核心的理念就在于，如果你把任务分割了，你就有了进度条，你就知道，事情在不断的进展，你总会完成任务或到达你的目标，你会有一个时间估计。反之如果没有这个分割，整个的任务或目标对你来说就只有两种状态——“完成”和“未完成”，如果不幸是一个比较漫长的目标，那么你会发现你的进度条总是“未完成”，一次又一次的等待未果会耗尽你的耐心，让你下意识的产生“这事什么时候才能完呢？”的疑惑，没有分而治之，你就不知道未来还需要付出多少努力才能达到目的，这就会让你心生怯意，不敢进一步投入时间，免得血本无归。在这样的心理下，不少人就会选择保守策略——退出，以免到头来花了时间还一事无成。</p></li><li><p>其实人天生就对新事物怀有好奇心，难以找出谁没有对任何事物或领域产生过兴趣，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难，第一道坎的时候，他们就熄灭了，然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定的燃烧很多年。区别他们的并不是兴趣的有无，而是他们的性格里面有没有维持兴趣的火种一直燃烧下去的燃料。</p></li><li><p><strong>饿死在干草堆之间的驴子</strong><font color="red">（选择问题）</font></p><p>面前有两条路，到底选哪一条？“转行还是不转行？”“学C++还是学Java。？“做管理还是做程序员？”有些问题其实不是问题：比如“学C++还是学Java。”答案是都学而且还不仅学两个。有些问题不是一个泛泛的答案能够适合的，比如转行还是不转行，需要考虑很多自身因素。</p><p>但更重要的是，有人会因为无法作出决定就推迟决定，然而实际上推迟决定是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。</p><p>所以，不管有多纠结，也不要从纠结中逃离，试图推延决定，既然终究是个痛苦的决定，就痛一回，好好思考和调查之后作出一个决定并坚持下去，只要不是太不靠谱的行业（相信也没谁会在纠结了之后却选了一个不靠谱的行业的），经过你的积累总会成为高手。</p></li></ol><h3 id="如何有效地记忆与学习"><a href="#如何有效地记忆与学习" class="headerlink" title="如何有效地记忆与学习"></a>如何有效地记忆与学习</h3><ol><li>你所拥有的知识并不取决于你记得多少，而在于它们能否在恰当的时候被回忆起来。</li><li>整理笔记：经常整理你的笔记——如果你没有做笔记，现在就开始——整理之前的笔记一来巩固已经淡化的记忆，二来给你重新审视知识的机会。我常常发现对知识的首次记忆往往是有偏颇的，或者只看到了一个方面，或者只关注了一个点，一段时间之后再回来看往往能够和这段时间以来的一些新思考和知识结合起来，得到更多的东西。留心一下你会发现记忆实际上是很脆弱的东西，而且我们对事物的首次理解几乎肯定是不深入的。</li><li>书写：将一段时间学习的知识按照一个主题系统地“串”起来大大地丰富了知识之间的关联，平添无数提取线索。</li></ol><h3 id="学习密度与专注力"><a href="#学习密度与专注力" class="headerlink" title="学习密度与专注力"></a>学习密度与专注力</h3><ol><li>其实，在大学期间，最不缺的就是业余时间，最缺的就是专注精神，非凡的注意力造就非凡的专家。而生活中太多的分散注意力的因素：游戏、篮球、选修课、女朋友… 要想集中注意力对一个单一的目标猛下功夫，其实还是相当有难度的。这个难度并非来自自制力，如果一个人要靠自制力去强迫自己不受干扰，那只能说还是寻常人(mediocre)。真正的效率源自于内心对一个东西强烈的热忱，也就是我们俗称的追求，这时候从表层意识到深层意识都关注在这件事情上面，脑细胞高度活跃，才能创造最大的效率。</li><li>专注力为什么会对学习效率造成这么大的影响。这来源于两个方面，一是专注于一件事情能让表层意识全功率运作，这个是显式的效率。第二点，也是更重要的，它还能够使你的潜意识进入一种专注于这件事情的状态。如果表层意识和潜意识都能专注同一件事情，也就是俗称的完全投入，这个时候的效率就能double。此外这种专注成了一种习惯之后，就容易在很短时间之内把自己的潜意识带入到一种关注的“惯性”中，于是即便表层意识的注意力已经移开了，然而潜意识仍在继续关注原来的问题。比如你可能有这样的经历，学习一首歌曲，一开始的时候并没有完全学会，然后你就去忙别的事情了，一个星期之后想起这首歌曲，居然发现原来难学会的几个地方突然会哼了；或者思考一个问题，一开始的时候总有一个地方没有思考出来，然后你就先放着了，几天之后回想这个问题，突然发现一切都清晰了。这就是潜意识的效率，它能在你不知不觉中把时间利用起来。</li><li>一个习惯于专注事情的人不管做什么事情都容易并迅速进入一种专注的状态。既然是一种习惯，就能够培养，金出武雄在《像外行一样思考，像专家一样实践——科研成功之道》里面提到“思维体力”的概念，所谓思维体力就是能够持续集中注意力的时间，注意力造就非凡专家，天才来源于长期的专注的训练。培养你的思维体力，是成为非凡专家的一个必要条件。除了培养专注的习惯之外，还可以通过另一个充分条件来实现专注力，即做自己喜欢做的事。我们从小对自己喜欢做的事情都是极其专注的，当然，即使长大了之后，仍然还是某种程度上保留了这种专注的能力，只不过因为种种外界因素，长久专注的能力反而削弱了，要考虑房子，要考虑业绩，要考虑小孩，要考虑医疗保险…这些让人焦虑的事情会积压在潜意识当中，总是在影响你专注做事，削弱你人生的效率。</li></ol><h3 id="一直以来伴随我的一些学习习惯"><a href="#一直以来伴随我的一些学习习惯" class="headerlink" title="一直以来伴随我的一些学习习惯"></a>一直以来伴随我的一些学习习惯</h3><h4 id="学习与思考"><a href="#学习与思考" class="headerlink" title="学习与思考"></a>学习与思考</h4><ol><li>Google &amp; Wiki（遇到问题做的第一件事情，也是学习某个东西做功课（homework）最先用到的东西。</li><li>做读书笔记。一是将自己阅读的时候的思考（包括闪念）总结下来，二是将书中的好例子摘抄下来。（这个习惯是一年前才养成的，发现受益极大。）有了 google note，笔记可以加上tag，非常便于回顾，加深理解。我觉得，人与人学习的差距不在资质上，而在花在思考的时间和思考的深度上（后两者常常也是相关的）。</li><li>提到思考，我有一个小习惯。利用走路和吃饭的时候思考，还有睡觉前必然要弄一个问题放在脑子里面，在思考中迷糊入睡。发现这样一来往往在不知不觉中多出来大量的思考时间。</li><li>将思考成为习惯还有一个很大的好处——避免焦虑。</li><li>重要的事情营造比较大的时间块来完成。比如一本好书，或者一个重要的知识点，最好不要切得太琐碎了看，否则看了后面忘了前面。不利于知识的组织&amp;联系。</li><li>多看心理学与思维的书，因为它们是跨学科的。知识分两种，一是我们通常所谓的知识，即领域知识。二是关于我们的大脑吸收知识的机制的知识，后者不妨称为元知识。虽说这也是领域知识，但跟其它的领域知识不同的是，它指导着我们学习其它所有的领域知识。</li><li>学习一项知识，必须问自己三个重要问题：1. 它的本质是什么。2. 它的第一原则是什么。3. 它的知识结构是怎样的。</li><li><strong>获得的多少并不取决于读了多少，而取决于思考了多少、多深。</strong></li><li>善于利用小块时间，也就是《奇特的一生》中所说的“时间下脚料”，如何利用前面有几个方法。同时，也善于创造整块时间（如通过要事优先）。</li></ol><h4 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h4><ol><li>学习和思考的过程中常问自己的几个问题： 你的问题到底是什么？. OK，到现在为止，我到底有了什么收获呢？时常反省和注意自己的思维过程。养成反驳自己的想法的习惯。</li><li>重视知识的本质：对于程序员来说这一点尤其重要，程序员行业的知识芜杂海量，而且总是在增长变化。很多人感叹跟不上新技术。应对这个问题的办法只能是：抓住不变量。大量的新技术其实只是一层皮，背后的支撑技术其实都是十来年不变的东西。底层知识永远都不过时。算法数据结构永远都不过时。基本的程序设计理论永远都不过时。良好的编码习惯永远都不过时。分析问题和解决问题的能力永远都不过时。强大的学习能力和旺盛的求知欲永远都不过时。你大脑的思维方式永远都不过时。</li><li>重视积累的强大力量，万事提前准备：计划订长一点，自然就可以多获得准备的时间。设想你若干年后会在做什么事情，需要哪些技能，现在就开始准备。一个5年计划便可以让你获得从现在开始的5年准备时间。5年中每天腾出半个到一个小时专心于某一件事情，认准一个方向，每次走一点，其实不要说5年，两年就会发现会起到宏大的效应。</li><li>抬起头来：人的思维是非常容易只见树木不见森林的（否则这个成语从哪来的呢？）。时不时抬起头来审视一下自己正在做的事情，问一问它（对现在或未来）有什么价值，是不是你真正希望做的。你学到的东西到底是什么？它们重要吗？你需要在这个时候学习这些吗？（见第2条）。你的时间就是你的资源，你投入这些资源来掌握知识，所以到底用来掌握哪些知识是一个很重要的问题。仅仅遵循兴趣是不够的，人会对很多次要的东西产生兴趣，并一头钻进去浪费好多时间。所以判断一个东西值不值得学习是很重要的。<font color="red">（兴趣偏差）</font></li><li>有时间吗？总结总结最近得到的新知识吧。一般来说，我在一段时间内学习的一些东西总是会在这段时间内一直在脑子里打转，一有时间空隙（譬如走路，吃饭）它们就会自己蹦出来，促使我去进一步思考和总结。永远不要认为对一个知识的把握足够深刻，“理解”的感觉很多时候只是假象。学会反问自己对知识到底把握了多少，是很有价值的。</li><li>有时间吗？看本书吧。（传统的）阅读和思考永远优于所谓的在互联网上汲取新知识，后者往往浅表、不系统、乃至根本没价值。</li><li>制定简要的阅读计划：选出最近认为对你最有价值的书，先总览一下，决定阅读的顺序（哪些章节可以优先阅读）。然后每天看一点。并利用走路、吃饭、乘车或其他不适合带着书和笔的时间来总结看过的内容，建立知识结构，抽取知识本质，与以往的大脑中的知识建立联系。</li></ol><h4 id="阅读方法"><a href="#阅读方法" class="headerlink" title="阅读方法"></a>阅读方法</h4><ol><li>趁着对一件事情有热情的时候，一股脑儿把万事开头那个最难的阶段熬过去。万事开头难，因为从不了解到了解基本的一些事实，是一个新知识暴涨的阶段，这个时候的困难是最大的。有人熬不过去，觉得困难太大就放弃了。</li><li>根据主题来查阅资料，而不是根据资料来查阅主题。以前读书的时候是一本一本的读，眼里看到的是一本一本的书，现在则是一章、甚至一节一节的读，眼中看到的不是一本一本的书，而是一堆一堆的章节，一个一个的知识主题，按照主题来阅读，你会发现读的时候不再是老老实实地一本书看完看另一本，而是非常频繁地从一本书跳到另一本书，从一处资料跳到另一处资料，从而来获得多个不同的人对同一个主题是如何讲解的。</li><li>学习一个东西之前，首先在大脑中积累充分的“疑惑感”。即弄清面临的问题到底是什么，在浏览方法本身之前，最好先使劲问问自己能想到什么方法。一个公认的事实是，你对问题的疑惑越大，在之前做的自己的思考越多，当看到解答之后印象就越深刻。记得大学里面的课本总是瀑布式地把整个知识结构一览无余地放在面前，读的过程倒是挺爽，连连点头，读完了很快又忘掉了，为什么？因为没有带着疑问去学习。</li><li>有选择地阅读。很多人觉得我读书速度很快，其实我只是有选择地阅读。这里的选择体现在两个地方，一是选择一本书中感兴趣的章节优先阅读。二是对一本书中技术性较弱或信息密度较低的部分快速地略读。一般来说，除了技术性非常强的书之外，大多数书的信息密度很低，有很多废话。一般来说在阅读的时候应该这样来切分内容：1. 问题是什么？2. 方案是什么？3. 例子是什么？如果是需要解释一个现象的（譬如《黑天鹅》），那么1. 现象是什么？2. 解释是什么？3. 支撑这个解释的理由是什么？4. 例子是什么？一般来说，这一二三四用不了多少字就可以写完了（如果假设只举一到两个精到的例子的话），这样的无废话著作的典型是《合作的进化》；那为什么有些书，明明核心观点就那点东西（顶多加上几个精要的例子罢了）却写得长得要命呢？因为人的思维都有一个“联想”的特点，写着写着就容易旁逸斜出，而且作者自己也往往觉得引申出去挺牛逼，有时候很多与主题无关的废话就掺和进来了；那么，阅读的时候就应该有选择性地滤掉这些不相干的废话；此外还有一种可能性就是大量冗余的例子。一般来说组织得比较好的书会有详细且一目了然的目录和索引，根据目录首先就可以滤掉一部分（比如某个子章节的内容你以前是看过的），然后有时候作者还会举很多冗余的例子，如果你已经觉得印象够深刻了这些例子完全可以不看（一些书就非常厚道地对每个观点只辅以一两个最最经典的例子，譬如《与众不同的心理学——如何正视心理学》，这样的书我最是喜欢）。<font color="red">（有选择阅读）</font></li></ol><h4 id="知识结构"><a href="#知识结构" class="headerlink" title="知识结构"></a>知识结构</h4><ol><li>抓住不变量： 把知识分为essential的和non-essential的。对于前者采取提前深入掌握牢靠的办法，对于后者采取待用到的时刻RTM (Read the manual)方法（用本）。</li></ol><h3 id="思维改变生活"><a href="#思维改变生活" class="headerlink" title="思维改变生活"></a>思维改变生活</h3><ol><li>如何区分essential和non-essential的知识想必绝大多数时候大家心里都有数，我举几个例子：对程序员来说，硬件体系结构是essential的，操作系统的一些重要的实现机制是essential的，主流编程范式（OO、FP）是为了满足什么需求出现的（出现是为了解决什么问题），是怎么解决的，自身又引入了哪些新的问题，从而适用哪些场景）。这些我认为都是essential的。我想补充一点的是，并不是说硬件体系结构就要了解到逻辑门、晶体管层面才行（其实要了解到这个层面代价也很小，一两本好书就行了），也并不是说就要通读《Computer Architecture: Quantitative Approach》才行。而是关键要了解那些重要的思想（很长时间不变的东西），而不是很细的技术细节（易变的东西）。《Computer Systems: A Programmer’s Perspective》就是为此目的，针对程序员的需求总结出那些essential knowledge的好书。<font color="red">（写下来，理性分析）</font></li><li>我们对于事物的思考深度常常是不够的，在浅层次的思考了之后，如果我们的情绪系统或者直觉已经给出了倾向，那么很少有人会继续深入地思考，而开始转向着手行动。这种匆忙的态度往往是失败的起源，在碰壁了之后，我们被动地“让事实告诉了我们”某方案是行不通的，让事实替代我们进行了思考和推理，我们从失败当中获得了信息，知道了为什么之前的方法是不恰当的，这就是一些时候我们认为要亲身经历才能明白的原因。然而，这并不意味着任何时候我们都只能“做了之后才发现…”，人类最强大的能力就是社会学习—— <strong>普通人从自己的错误中学习，聪明人从别人的错误中学习。</strong></li><li>人类最强大的另一个能力则是归纳和推理—— A few lines of reasoning can change the way we see the world. (via) <strong>我们可以仔细地，理性地思考、权衡各个选择的利弊，而不仅仅满足于情绪上的判断。</strong> 假设我们面临两个选择，A和B，我们可以结合别人的经历，利用自己的推理能力，去分别推断A或B选项带来的各种各样可能的利弊，对于其中不确定的因素我们或者可以进一步从别人那里收集更多的信息来使得判断更靠谱，或者可以对风险的上下界进行一些估计，总之，<strong>我们尽量去让我们大脑中假想的角色去经历失败——我们通过推理发现某条路行不通，就避免了现实中去碰一鼻子灰</strong>。</li></ol><h3 id="书写是为了更好地思考"><a href="#书写是为了更好地思考" class="headerlink" title="书写是为了更好地思考"></a>书写是为了更好地思考</h3><ol><li>我经常在走路和睡前总结所学过的内容，思考遗留的问题，一段时间的阅读和思考之后，一个总体的知识框架就会逐渐浮现在脑海中。然后我会将它书写下来，然而，我往往非常惊讶地发现，当我书写的时候，新的内容仍然源源不断的冒出来，就像我的键盘自己也会思考一样。<font color="red">（总写学过的知识）</font></li></ol><h3 id="遇到问题为什么应该自己动手"><a href="#遇到问题为什么应该自己动手" class="headerlink" title="遇到问题为什么应该自己动手"></a>遇到问题为什么应该自己动手</h3><ol><li>有一个很不错的概念叫做“<strong>Unknown Unknown</strong>”，<strong>大意是如果你不知道一个东西的话，你也不会知道你自己不知道它。</strong>很多时候新知识就有这个特性——掌握了之后觉得很明白，掌握之前却觉得“不可能啊”、“这简直没有解嘛”。在这样的认知之下，你自然会高估前方的困难、风险和不确定性，因为你不知道什么样的知识才能解决你的困惑。然而事实上呢？只要智商没有根本的差别，别人的大脑能够掌握的知识，你的大脑也能掌握，你所感觉到的巨大困难只不过是因为Unknown Unknown，你所需要的只是耐心地踏遍这块知识版图，当你掌握了那些你该掌握的知识之后自然会柳暗花明。<font color="red">（不知道自己不知道的）</font></li><li>用最小的代价解决手头的问题”——这里的问题在于，难道我们计算收益的时候仅仅考虑是否解决了手头的问题吗？如果解决的过程中得到了其他的收益呢？为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。<font color="red">（额外的收益）</font></li></ol><h3 id="什么才是你的不可替代性-amp-核心竞争力"><a href="#什么才是你的不可替代性-amp-核心竞争力" class="headerlink" title="什么才是你的不可替代性&amp;核心竞争力"></a>什么才是你的不可替代性&amp;核心竞争力</h3><h4 id="知识技能组合是具有相当程度的不可替代性的："><a href="#知识技能组合是具有相当程度的不可替代性的：" class="headerlink" title="知识技能组合是具有相当程度的不可替代性的："></a>知识技能组合是具有相当程度的不可替代性的：</h4><ol><li><strong>专业领域技能</strong>：成为一个专业领域的专家，你的专业技能越强，在这个领域的不可替代性就越高。这个自是不用多说的。</li><li><strong>跨领域的技能</strong>：解决问题的能力，创新思维，判断与决策能力，Critical-Thinking，表达沟通能力，Open Mind 等等</li><li><strong>学习能力</strong>：严格来说学习能力也属于跨领域的技能，但由于实在太重要，并且跨任何领域，所以独立出来。如何培养学习能力，到目前为止我所知道的最有效的办法就是持续学习和思考新知识。</li><li><strong>性格要素</strong>：严格来说这也属于跨领域技能，理由同上。一些我相信很重要的性格要素包括：专注、持之以恒、自省（意识到自己的问题所在的能力，这是改进自身的大前提）、好奇心、自信、谦卑（自信和谦卑是不悖的，前者是相信别人能够做到的自己也能够做到，后者是不要总认为自己确信正确的就一定是正确的，Keep an open mind）等等。</li></ol><h3 id="鱼是最后一个看到水的"><a href="#鱼是最后一个看到水的" class="headerlink" title="鱼是最后一个看到水的"></a>鱼是最后一个看到水的</h3><ol><li>《设计模式》被许多初学者奉为圭臬，认为那些看上去精巧的东西才是真正牛13的，值得学习的。而且，更聪明一点的人甚至会唯恐学的东西还不够复杂，因为越是复杂的东西搞出来越是有成就感。然而事实是，把简单的事情搞复杂的人比比皆是，把复杂的事情搞简单的人凤毛麟角。<font color="red">（不要把简单事情搞复杂）</font></li><li><strong>避免思维被一门语言束缚的最好办法就是“学习其它语言”。</strong></li></ol><h3 id="知其所以然"><a href="#知其所以然" class="headerlink" title="知其所以然"></a>知其所以然</h3><ol><li>包含了多得多的知识：记一个算法，就只有一个算法。一个萝卜一个坑。<strong>就好比背99乘法表只能解决乘法问题一样。而记背后的思想，却有助于解决一类问题。</strong>思想所处的抽象层面往往比到处都是实现细节的算法本身要低，越是低的抽象层次，越是本质，涵盖范围越是广泛。数学的发展本身就体现了这个过程，抽象代数就是非常好的例子。算法诞生过程中的思路往往包含了比实际算法更本质得多的知识，实际算法乃至算法的某个特定语言的实现包含了太多表面的不相干知识，它们会阻碍对本质的理解。<font color="red">（分析推理）</font></li><li><strong>重在分析推理，而不是联想</strong>：学了一大通算法和数据结构之后的一个副作用就是，看到一个问题之后，脑袋里立即不管三七二十一冒出一堆可能相干的数据结构和算法来。联想是强大的思维捷径，在任何时候都会抢占大脑的工作记忆，由不得你控制——比如我问你“如何寻找区间的最大值”，首先进入你的意识的肯定就是学过的那个算法，甚至算法的实现细节都一一跳了出来，也许最先跳出来的还是算法实现中某个最容易弄错的边界细节，或是某个比较tricky的实现技巧！然而这些其实根本不反映一个算法的本质，结果想来想去总是停留在问题的表层。而另一方面，重在思维的传授则可以让人养成从问题本质入手，逐步分析推理的习惯，而不是直接生搬硬套。当然，完全不可否认，联想本身也是极其重要的思维方法，甚至可以说是人类思维最重要的特征。很多时候我们并不知道问题的本质是什么，就需要靠联想、类比来领路探索。只不过，养成优先从问题的本质入手进行考察的好习惯绝对是有更大的好处的。</li></ol><h4 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h4><ol><li>也许，对付我们强大的习惯的最佳办法是将自己认为正确的（不管是自己经过困难或失败而领悟的，还是看到书上或听到别人说的）写下来，并常常拿出来翻看。事实上，我的经验是，在写下来的时候我们的大脑会进入到理性分析模块，进一步检验和推理那些道理，我们越是对一个道理审视的详细、深入、全面，大脑中留下的印象深刻，从记忆加工的角度来说，这叫深度加工，带来的结果就是该记忆与更多的提取线索相关联，于是便能够在更多的场景下被唤起（而不是被以往的习惯直接覆盖）</li></ol><h3 id="note"><a href="#note" class="headerlink" title="note:"></a>note:</h3><ol><li>俗语有谋事在人，成事在天的说法。其实这话说的是，我们的努力是为了增大结果发生的几率，而不是为了那个确定的结果。不要奢望你努力了就绝对会成功，你不会。更不要以这个理由来作为不去努力的原因，因为不去努力，那就永远不会成功。</li><li>生活中一抓一大把。俗语云“公说公有理，婆说婆有理。”你敢于表达自己的观点，他说你喜欢炫耀。你韬光养晦呢，他又说你夹着尾巴做人；你为自己的成就骄傲一下，他说你得意忘形。你低调做人呢，他又说你怎么这么没种；你说彪悍的人生不需要解释，他说你自大狂。你说做人贵有自知之明呢，他又说你丫做人怎恁费劲捏？…</li></ol><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="书籍" scheme="https://www.daihuiyou.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://www.daihuiyou.top/2018/10/11/C++/"/>
    <id>https://www.daihuiyou.top/2018/10/11/C++/</id>
    <published>2018-10-11T00:17:58.000Z</published>
    <updated>2019-05-20T04:32:09.458Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><hr><p>匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。</p><pre><code class="c++">class AA{public:    AA()    {        cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl;    }    ~AA()    {        cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl;    }};void main(){    //AA a = AA();  //产生一个匿名对象， 有一个变量去接，不会调用析构函数。    AA b;   //调用拷贝构造函数。    b = AA();   //匿名对象， 会调用拷贝构造函数和析构函数。    system(&quot;pause&quot;);}</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><hr><p>抛出异常是跨函数的。</p><p>c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，<br>这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。</p><p>栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。</p><p>异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr><p>引用分为普通引用和常引用</p><pre><code class="c++">//常引用 //常引用当函数参数 ,可以传字面量或者实参void func1(const int&amp; num){    cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl;}//普通引用当函数参数， 传实参void func2(int &amp;num){    cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl;}void main(){    int a = 10;    int c = a;  //引用当右值， 把变量的值赋值给变量    int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。    cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl;    cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl;    cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl;    cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl;    //字面量常引用    const int&amp; tmp = 123; //分配内存    cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl;    cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl;    //普通引用    //int&amp; var = 123;        //不自动分配内存， 编译错误    int var = 123;    func1(123);        //可以传进字面量    func1(var);    //可以传进变量    func2(var); //只能传进变量.    cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl;    system(&quot;pause&quot;);}</code></pre><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><hr><p>重写与重载：</p><ul><li>方法的重写Overriding和重载Overloading是多态性的不同表现。</li><li>重写Overriding是父类与子类之间多态性的一种表现，</li><li>重载Overloading是一个类中多态性的一种表现。</li><li>如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。</li><li>子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；</li><li>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。<br>Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同</li></ul><p>定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。</p><h3 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h3><hr><ul><li>左值和右值</li><li>左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；</li><li>右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。<br>-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。</li></ul><p>对象的初始化， 和赋值不一样 </p><pre><code class="c++">A a = b;     //    调用a的拷贝构造函数A a;a = b;  //调用操作符重载=函数, </code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><hr><h5 id="带指针的类和不带指针的类"><a href="#带指针的类和不带指针的类" class="headerlink" title="带指针的类和不带指针的类"></a>带指针的类和不带指针的类</h5><ul><li><em>class with pointer member</em> 必须有 拷贝构造 和拷贝赋值 </li><li><strong>&amp; 有不同意义， 取地址和声明参数引用。</strong></li></ul><h5 id="对象类型："><a href="#对象类型：" class="headerlink" title="对象类型："></a>对象类型：</h5><ul><li><em>local objects （auto object）： Complex c2();</em></li><li><em>static objects</em>：其生命在作用域结束后仍然存在，知道整个程序结束。</li><li><em>global objects</em></li><li><em>heap objects</em></li></ul><h5 id="using-编译指令："><a href="#using-编译指令：" class="headerlink" title="using 编译指令："></a>using 编译指令：</h5><ul><li>在多函数程序中使用using编译指令，这是因为函数都使用了 <em>cout</em>， 因此需要能够访问位于命名空间std的 <em>cout</em> 定义 。</li><li><em>using namespace std</em>； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素</li><li><em>namespace</em> 和  <em>Java</em> 的 包类似</li></ul><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><ul><li>函数原型作为黑盒的函数</li><li>函数原型 prototype</li></ul><h5 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h5><ul><li>成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。</li></ul><h5 id="static"><a href="#static" class="headerlink" title="static :"></a><em>static :</em></h5><ul><li><em>static data</em> 要 <em>static</em> 函数处理</li><li><em>static</em> 成员函数 和 成员函数区别：没有 <em>this pointer</em></li><li><em>static</em> 函数调用方式： <em>object</em> 调用 和 <em>class name</em> 调用</li></ul><h5 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a><em>Inheritance</em></h5><ul><li>继承成员变量</li><li>继承成员函数的调用权</li></ul><h5 id="vitual"><a href="#vitual" class="headerlink" title="vitual"></a><em>vitual</em></h5><ul><li><em>pure vitual</em></li><li><em>impure virtual</em></li><li><em>non-virtual</em></li></ul><h5 id="为什么需要原型"><a href="#为什么需要原型" class="headerlink" title="为什么需要原型"></a>为什么需要原型</h5><ul><li><h5 id="原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。-如-double-volume-cube（side）；"><a href="#原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。-如-double-volume-cube（side）；" class="headerlink" title="原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。    如 double volume  = cube（side）；"></a>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。    如 double volume  = cube（side）；</h5></li></ul><h5 id="原型的功能"><a href="#原型的功能" class="headerlink" title="原型的功能"></a>原型的功能</h5><ul><li>原型可以帮组编译器完成许多工作。</li><li>编译器正确处理函数返回值</li><li>编译器检查使用的参数数目是否正确</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。</li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><hr><p>多态即多种形态，多态的实现即3步骤：有继承，虚函数重写，父类指针指向子类对象。</p><p>那么类中函数的重载（overloading），也是多态，同一函数名的多种状态。</p><ul><li><strong>多态实现的原理</strong>：</li></ul><p>在类的成员方法有virtual关键字，那么在创建类对象时，编译器会把对象添加一个虚函数指针,来指向虚函数表。</p><p>虚函数表的作用来存放类中成员方法的虚函数地址。在程序运行时，根据虚函数表才能确定对应执行的操作（动态绑定）</p><ul><li><h5 id="为什么类中的析构函数通常都要添加-virtual-关键字？"><a href="#为什么类中的析构函数通常都要添加-virtual-关键字？" class="headerlink" title="为什么类中的析构函数通常都要添加 virtual 关键字？"></a>为什么类中的析构函数通常都要添加 virtual 关键字？</h5></li></ul><p>是为了正确调用子类的析构函数，不引发子类对象析构时的错误。</p><p>在父类中没有添加virtual的析构函数时，父类指针指向子类对象并析构子类对象时，只调用父类的虚构函数，导致错误的析构。</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Base{public:    Base() {}; //Base的构造函数    ~Base()   //Base的析构函数    {        cout &lt;&lt; &quot;Output from the destructor of class Base!&quot; &lt;&lt; endl;    };    virtual void DoSomething()    {        cout &lt;&lt; &quot;Do something in class Base!&quot; &lt;&lt; endl;    };};class Derived : public Base{public:    Derived() {}; //Derived的构造函数    ~Derived() //Derived的析构函数    {        cout &lt;&lt; &quot;Output from the destructor of class Derived!&quot; &lt;&lt; endl;    };    void DoSomething()    {        cout &lt;&lt; &quot;Do something in class Derived!&quot; &lt;&lt; endl;    };};int main(){    Derived *pTest1 = new Derived(); //Derived类的指针    pTest1-&gt;DoSomething();    delete pTest1;    cout &lt;&lt; endl;    Base *pTest2 = new Derived(); //Base类的指针    pTest2-&gt;DoSomething();    delete pTest2;    return 0;}// 输出结果1 Do something in class Derived!2 Output from the destructor of class Derived!3 Output from the destructor of class Base!4 5 Do something in class Derived!6 Output from the destructor of class Base!</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><hr><p>运算符重载的左侧的操作数是调用的对象。</p><p>所以对于成员方法的运算符重载，那么左侧的操作数是 this，并不是第一个参数。</p><ul><li><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5></li></ul><p>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型</p><p>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。</p><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><hr><p>动态绑定就是程序在执行时才确定具体的操作，我认为动态绑定是动态存储区(heap)申请内存；静态绑定（即在编译时刻已经确定程序的大小）是在静态存储区存放大小。</p><p>在 C 中 malloc 实现动态存储区的申请。</p><p>在 C++ 中 new 实现动态存储区的申请。</p><p>静态绑定的执行效率优于动态绑定的执行效率。</p><ul><li><h5 id="虚函数表的存储空间在哪呢？"><a href="#虚函数表的存储空间在哪呢？" class="headerlink" title="虚函数表的存储空间在哪呢？"></a>虚函数表的存储空间在哪呢？</h5></li></ul><p>我觉得是动态存储区，因为只有实例化对象时，虚函数表才能生成，并不是编译时刻就确定好。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><hr><p>智能指针在结束对象的生存期，智能释放指针指向的存储空间，不会产生内存泄露问题。相对于普通指针，更加安全。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="https://www.daihuiyou.top/2018/10/10/C/"/>
    <id>https://www.daihuiyou.top/2018/10/10/C/</id>
    <published>2018-10-10T13:58:34.000Z</published>
    <updated>2018-12-02T13:41:49.056Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>date: 2018-09-10 13:57:09</p><p>链表是一种结构体， 包括数据域和指针域。</p><p>链表是一种物理存储单元上非连续的线性存储结构。</p><p>链表遍历</p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>date: 2018-09-06 17:20:42</p><ul><li>h头文件是编译时必须的，</li><li>lib库是链接时需要的，</li><li>dll动态链接库是运行时需要的。</li></ul><p><strong>.h .lib .dll三者的关系是：</strong></p><ul><li>h文件作用是：声明函数接口</li><li>lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址</li><li>dll文件作用是：函数可执行文件</li></ul><p>动态库是底层函数的调用入口。<br>动态库与测试框架相结合。</p><p><strong>void SockInit(void *handle)：</strong></p><ul><li>handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数；</li><li>被调函数将传进来的参数handle 强制转换相应的数据类型。</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>date: 2018-09-06 11:44:51</p><p><strong>文件句柄</strong>： 就是内存块的首地址或者资源首地址。</p><p><strong>测试框架 和  分层模块的区别</strong></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>date: 2018-09-05 13:53:11</p><pre><code class="c">//结构体定义typedef struct Teacher{    char name[30];    int age;}Teacher;Teacher *SortTeacher(int num) //堆区分配内存{    Teacher *pArray = NULL;    pArray = (Teacher *) malloc(sizeof(Teacher) *num);    if(pArray == NULL)    {        printf(&quot;pArray = NULL.&quot;);    }    return pArray.} //返回值//优化int CreateTeahcer_good( Teacher **pArray, int num)    //    用二级指针修改一级指针的值{    Teacher * temp;    temp = (Teacher *)malloc(sizeof(Teacher)*num);    if(temp == NULL)    {        return -1;        printf(&quot;堆区分配失败.&quot;);    }    *pArray = temp;    return 0;}</code></pre><p><strong>用结构体套一级指针</strong></p><pre><code class="c">//结构体定义typedef struct Teacher{    char name[30];    int age;    char *id;  //需要分配内存空间才有效。}Teacher;int CreateTeahcer_good( Teacher **pArray, int num)    //    用二级指针修改一级指针的值{    Teacher * temp;    int i = 0;    temp = (Teacher *)malloc(sizeof(Teacher)*num);    if(temp == NULL)    {        return -1;        printf(&quot;堆区分配失败.&quot;);    }    for(i=0; i&lt;num; i++)    {        temp[i].id = (char *)malloc(sizeof(char)*120);    }    *pArray = temp;    return 0;}//需要两次释放堆内存  void freeMem(Teacher *pArray){    if(pArray == NULL)    {        printf(&quot;error.&quot;);    }    if(pArray-&gt;id != NULL)    {        free(pArray-&gt;id);        pArray-&gt;id = NULL;    }    free(pArray);    pArray = NULL;}/* 结构体嵌套二级指针C语言的高效（数组作函数的参数的退化现象）指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。什么时候用一级指针，什么时候用二级指针。  被调用函数分配内存，供主调函数使用，二级指针。  主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件：- 2个变量（通常一个实参，一个形参）- 建立关系，实参取地址赋给形参- *p形参区间接修改形参的值不断修改指针变量的值越界场景：char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39;总结:     函数调用时，用n级指针（形参）改变n-1级指针（实参）的值/*</code></pre><h3 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h3><p>date: 2018-09-04 09:17:33</p><pre><code class="c">//const char *p 指针所指向的内存不能被修改void getMem(const char *p){    p++;    //*p = 1;}//char *const p 指针变量的值的不能被修改。void getMem2(char *const p){    //p++;    *p = 1;}//const char *const p 指针变量的值和它所指向的内存不能被修改。void getMem3(const char *const p){    //p++;    //*p = 1;}</code></pre><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>date: 2018-09-04 16:57:20</p><pre><code class="c">void main(){    int a[] = {1, 2};    int b[100] = {1, 3};    int c[200] = {0}; //编译的是 就已经确定 所有的值 为零    memset(c, 0, sizeof(c)); //显示的 重置内存块    //对一维数组  C规定：    //c是数组首元素的地址 c+1 步长 4个字节    //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4     printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}//怎么样表达int a[10]这种数据类型那？int[]    //类型本质：固定大小内存块的别名  //定义数组类型   </code></pre><pre><code class="c">void main(){    typedef int (MyArrayType)[5]; //定义了一个数据类型  数组数据类型    int i = 0;    MyArrayType  myArray;  //int myArray[5];    for (i=0; i&lt;5; i++)    {        myArray[i] = i+1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, myArray[i]);    }printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1);printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1);    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>定义数组指针变量的方法1</strong></p><pre><code class="c">void main(){    char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组    //数组指针  用一个指针 来指向一个数组    typedef int (MyArrayType)[5]; //定义了一个数据类型  数组数据类型    int i = 0;    MyArrayType  myArray;  //int myArray[5]; //用类型定义变量     MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组    {        int myArray2[5]; //相当于一级指针        pArray = &amp;myArray2; //相当于2级指针        for (i=0; i&lt;5; i++)        {            (*pArray)[i] = i+1;        }        for (i=0; i&lt;5; i++)        {            printf(&quot;%d &quot;, (*pArray)[i]);        }    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>定义数组指针变量的方法2</strong></p><pre><code class="c">void main(){    //定义声明一个数组指针类型    typedef int (*PArrayType)[5];    PArrayType pArray;  //告诉编译器 给我分配一个指针变量    int c[5];    int i  = 0;    pArray = &amp;c;    for (i=0; i&lt;5; i++)    {        (*pArray)[i] = i + 1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, (*pArray)[i]);    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p>定义数组指针变量的方法3</p><pre><code class="c">void main(){    //int [][5]    int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量    int c[5];    int i  = 0;    pMyArray = &amp;c;    for (i=0; i&lt;5; i++)    {        (*pMyArray)[i] = i + 1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, (*pMyArray)[i]);    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>多维数组名的本质是数组指针</strong></p><p><strong>多维数组作参数退化问问题</strong></p><pre><code class="c">//多维数组作参数的退化问题void getArray1(int buff[3][5])//buff退化为数组指针{    int num = 0;    int i, j;    int temp = 0;    num = sizeof(buff);    printf(&quot;num:%d\n&quot;, num);    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            *(*(buff+i)+j) = temp++;        }    }}void getArray2(int buff[][5]){    int i, j;    int temp = 0;    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            buff[i][j] = temp++;        }    }}void getArray3(int (*buff)[5]){    int i, j;    int temp = 0;    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            *(*(buff+i)+j) = temp++;;        }    }}/*    多维数组名的本质  数组指针 ，步长 一维的长度    (a+i) 代表是整个第i行的地址  二级指针    *(a+i) 代表 1级指针  第i行首元素的地址    *(a+i) + j  ===&gt; &amp;  a[i][j]    *( *(a+i) + j) ===&gt;a[i][j]元素的值*/void main(){        int a[3][5];    int i, j;    int temp = 0;    getArray3(a);    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            printf(&quot;%d &quot;, a[i][j]);        }    }        printf(&quot;hello.\n&quot;);    system(&quot;pause&quot;);    return;}/*    等价关系    | 数组参数 | 等效数组参数     | ------ | ------ |    | 一维数组 char a[30] | 一级指针 char *a     | 指针数组 char *a[30] | 二级指针char **a     | 二维数组 char a[5][30] | 数组指针变量char (*a)[30]*/</code></pre><h3 id="二级指针的三种内存模型"><a href="#二级指针的三种内存模型" class="headerlink" title="二级指针的三种内存模型"></a>二级指针的三种内存模型</h3><p>date: 2018-09-04 11:28:19</p><pre><code class="c">void main(){    int num = 3;    int i, j;    char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;};     char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;};    char **buff = (char**)malloc(sizeof(char*)*4);    for(i=0; i&lt;num; i++)    {        buff[i] = (char*)malloc(sizeof(char)*10);        sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1);    }    for(i=0;i&lt;num; i++)    {        printf(&quot;%s\n&quot;, buff[i]);    }    system(&quot;pause&quot;);}</code></pre><p><img src="https://i.imgur.com/7xWidmb.png" alt=""></p><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><p>date: 2018-09-03 15:02:59</p><p><strong>字符串COPY函数优化过程</strong></p><pre><code class="c">/*buf[3] 和 *(p+3)   1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯   2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。   3.p普通指针 和 数组第一个元素地址的区别*/void str_copy(char *from, char *to)  //表明主调函数分配内存，供被调函数内部使用{    for( ; *from != &#39;\0&#39;; from++, to++)    {        *to = *from;    }    *to = &#39;\0&#39;;}void str_copy1(char *from, char *to){    while( (*to = *from) != &#39;\0&#39;)    {        to++;        from++;    }}void str_copy2(char *from, char *to){    while((*to++ = *from++) != &#39;\0&#39;)  //等效与*to = *from; to++; from++;    {        ;    }}//建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来void str_copy_good(char *from, char *to){    char *tempfrom = from;    char *tempto = to;    if( tempfrom ==NULL || tempto == NULL)    {        return;    }    while((*tempto++ = *tempfrom++) != &#39;\0&#39;);    printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。}</code></pre><p><strong>正确示范</strong></p><pre><code class="c">void main(){    char *p = &quot;abcd&quot;;     char buff[123]; //分配内存    str_copy2(p, buff);    printf(&quot;buff:%s\n&quot;,buff);    system(&quot;pause&quot;);}</code></pre><p><strong>错误示范</strong> </p><pre><code class="c">void main(){    char *p = &quot;abcd&quot;;     char *to = NULL;//没有分配内存    str_copy2(p, to);//直接在0X0地址写值，程序运行中断。    printf(&quot;buff:%s\n&quot;,to);    system(&quot;pause&quot;);}</code></pre><p><strong>项目开发中字符串模型</strong></p><pre><code class="c">/* (*count)++和 *count++的区别：*count++ 等效于 *(count++)1. 输入特性 in：主函数分配内存，供被调函数使用。2. 输出特性out：被调函数分配内存，供主调函数。*/int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/){    char * p = mystr;    char * count = ncount;    int ret;    if( mystr == NULL || sub == NULL || ncount == NULL)    {        ret = -1;        printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;);    }    do    {        p = strstr(p, sub);        if(p != NULL)        {            (*count)++;  //(*count)++和 *count++的区别：*count++ 等效于 *(count++)            p = p + strlen(sub);        }    }while(*p != &#39;\0&#39;);    ret = 0;    return ret;}void main(){    char *p = &quot;123123adcd123123abcd123&quot;;    char *substr = &quot;123&quot;;     char count = 0;    int  ret;    ret = getCount(p, substr, &amp;count);    if (ret != 0)    {        printf(&quot;getCount() error;&quot;);        return;    }    printf(&quot;count :%d\n&quot;, count);    system(&quot;pause&quot;);}</code></pre><p><strong>字符串反转</strong></p><p>​    </p><p>​    </p><pre><code class="c">int reverse(char *str){    int length;    char *temp = str;    char *p1;    char *p2;    char c;    if(temp == NULL)    {        return -1;        printf(&quot;str = NULL.&quot;);    }    length = strlen(temp);    p1 = temp;    p2 = temp + length -1;    while(p1 &lt; p2)    {        c = *p1;        *p1 = *p2;        *p2 = c;        ++p1;        --p2;    }    return 0;}void main(){    char buff[] = &quot;123123abcd123123abcd123&quot;;    //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值    char *substr = &quot;abcd&quot;;     char count = 0;    int  ret;    printf(&quot;buff[]: %s\n&quot;, buff);    ret = reverse(buff);    if(ret != 0)    {        printf(&quot;reverse() error.&quot;);        return;    }    printf(&quot;buff = %s\n&quot;, buff);    system(&quot;pause&quot;);}</code></pre><p>​    </p><p><strong>通过递归方式和局部变量的方式实现的逆序打印字符串。</strong></p><pre><code class="c">void  inverse(char *p, char *mybuf){    if( p == NULL)    {        return ;        printf(&quot; p = NULL.&quot;);    }    if(*p == &#39;\0&#39;)    {        return;    }    inverse(p+1, mybuf);    strncat(mybuf, p, 1); //}void main(){    char buf[] = &quot;abcdfg&quot;;    char mybuf[100]={0};    inverse(buf,mybuf);    printf(&quot;%s\n&quot;, mybuf);    system(&quot;pause&quot;);    }</code></pre><p>​    </p><h3 id="二级指针的间接赋值"><a href="#二级指针的间接赋值" class="headerlink" title="二级指针的间接赋值"></a>二级指针的间接赋值</h3><p>date: 2018-09-02 19:07:59</p><pre><code class="c">void getMem(int **p)  //通过二级指针形参， 指向主函数的一级指针{    *p = (int*)malloc(100);}void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值{    p = (int*)malloc(sizeof(char)*100);}void main(void){    int **p2 = NULL;    int *p1 = NULL;    p2 = &amp;p1;    getMem(p2);    printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值    getMem2(p1); //无修改p1的值    printf(&quot;int *p: %d\n&quot;, p1);    system(&quot;pause&quot;);    return ;}//结果显示：//int *p :7746448//int *p: 7746448//请按任意键继续. . .</code></pre><p><strong>间接赋值的应用</strong></p><pre><code class="c">    void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/)    {        char *temp1 = NULL;        char *temp2 = NULL;        temp1 = (char *)malloc(100);        strcpy(temp1, &quot;12312312&quot;);        *len1 = strlen(temp1);        *p1 = temp1;        temp2 = (char *)malloc(200);        strcpy(temp2, &quot;asdfasdfasdf&quot;);        *len2 = strlen(temp2);        *p2 = temp1;    }    void main(void)    {        char *p1 = NULL;        char *p2 = NULL;        int  len1, len2;        getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量        printf(&quot;p1 = %s\n&quot;, p1);        printf(&quot;len1 = %d\n&quot;, len1);        printf(&quot;p2 = %s\n&quot;, p2);        printf(&quot;len2 = %d\n&quot;, len2);        system(&quot;pause&quot;);        }</code></pre><p><strong>指针作函数参数, 具有输入输出特性</strong></p><ul><li>输入特性 in：主函数分配内存，供被调函数使用。</li><li>输出特性out：被调函数分配内存，供主调函数。</li></ul><h3 id="指针也是一种数据类型"><a href="#指针也是一种数据类型" class="headerlink" title="指针也是一种数据类型"></a>指针也是一种数据类型</h3><p>date: 2018-09-02 10:07:52</p><ul><li>指针是一种数据类型，是指它指向的内存空间的数据类型  </li><li>含义1：指针步长（p++），根据所致内存空间的数据类型来确定  </li><li>p++=(unsigned char )p + sizeof(a);  </li><li>结论：指针的步长，根据所指内存空间类型来定</li></ul><pre><code class="c">void main(){    int b[40];    printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1);    system(&quot;pause&quot;);     return;} 结果显示:    b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048  //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。  //&amp;b 表明 整个数组的首地址。  //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。  //&amp;b 加数组中第一个数的大小得到的地址。</code></pre><h3 id="堆栈区和函数调用分析"><a href="#堆栈区和函数调用分析" class="headerlink" title="堆栈区和函数调用分析"></a>堆栈区和函数调用分析</h3><p>date: 2018-09-02 08:57:39</p><p><strong>栈的生长方向</strong><br><img src="https://i.imgur.com/HEIBUoh.png" alt=""></p><p><strong>函数调用分析</strong><br><img src="https://i.imgur.com/qPse2Og.png" alt=""></p><pre><code class="c">//栈的开口向上向下,,测试 release和dubug;//一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的..void main(void){    int a;     int b;    char buf[99];  //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了....    printf(&quot;&amp;a:%d\r\n&quot;, &amp;a);    printf(&quot;&amp;b:%d\r\n&quot;, &amp;b);    printf(&quot;buf:%d\r\n&quot;, buf);    printf(&quot;hello\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><h3 id="堆栈区的理解"><a href="#堆栈区的理解" class="headerlink" title="堆栈区的理解"></a>堆栈区的理解</h3><p>date: 2018-09-01 20:40:25    </p><pre><code class="c">//堆区char *getMem(int num){    char *p;    p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存    if(p == NULL)    {        return;    }    return p;}//栈区char * getMem2(){    char *p = NULL;    char a[40]; //局部变量，临时变量    p = a;    return p;}void main(void){    char *p1 = NULL;    char *p2 = NULL;    p1 = getMem(10);    if(p1 == NULL)    {        return;    }    p2 = getMem2();    if(p2 == NULL)    {        return;    }    strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中    strcpy(p2, &quot;123123&quot;);    //打印p1 p2 所指向内存空间的数据    printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2);    //打印p1 p2 的值    printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2);     printf(&quot;hello\n&quot;);    system(&quot;pause&quot;);    return ;}//结果显示：//p1:123123 p2:乱码//p1:2896568 , p2:1572272//hello...//请按任意键继续. . .mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 </code></pre><h3 id="数据类型的大小-内存四区的划分"><a href="#数据类型的大小-内存四区的划分" class="headerlink" title="数据类型的大小, 内存四区的划分"></a>数据类型的大小, 内存四区的划分</h3><p>date: 2018-09-01 15:57:49</p><h3 id="函数参数退化问题-退回一个指针"><a href="#函数参数退化问题-退回一个指针" class="headerlink" title="函数参数退化问题, 退回一个指针"></a>函数参数退化问题, 退回一个指针</h3><p>date: 2018-09-01 12:01:59</p><ul><li><p>结论： 把数组的内存首地址和数组的有效长度传给被调用函数  </p></li><li><p>实参的 a 的 形参的 a的数据类型不一样  </p></li><li><p>形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。   </p></li><li><p>形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。  </p><pre><code class="c">void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。{    int i = 0, j = 0;    int temp = 0;    int num1 = 0;    num1 = sizeof(a) / sizeof(a[0]);    printf(&quot;num1: %d\r\n&quot;, num1); // num1  = 1, 结果表明形参中的a[]是指针类型。    for(i=0; i&lt;num; i++)    {        for(j=0; j&lt;i+1; j++)        {            if(a[i] &lt; a[j])            {                temp = a[i];                a[i] = a[j];                a[j] = temp;            }        }    }}void printfArray(int a[], int num){    int i = 0;    for(i=0; i&lt;6; i++)    {        printf(&quot;%d &quot;, a[i]);    }    printf(&quot;\n&quot;);}//排序void main(void){int a[] = {123,321,231,332,221,1};int    i, j, temp;int num = 0;num = sizeof(a) / sizeof(a[0]);printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。SortArray(a, num);printfArray(a, num);printf(&quot;\n&quot;);printf(&quot;hello...\n&quot;);system(&quot;pause&quot;);return;}</code></pre><p><code>`</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="https://www.daihuiyou.top/2018/08/28/markdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://www.daihuiyou.top/2018/08/28/markdown使用总结/</id>
    <published>2018-08-28T08:09:25.000Z</published>
    <updated>2018-11-09T06:13:21.596Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><p>换行：<br>1.方法1： 连续两个以上空格+回车。  </p></li><li><p>首行缩进两个字符：（每个表示一个空格，连续使用两个即可）</p><pre><code>  1.&amp;ensp;半角的空格  </code></pre><p>  ​    2.&emsp;全角的空格</p></li><li><p>字体、字号、颜色</p><pre><code>  - &lt;font color=red&gt;red&lt;/font&gt;  - &lt;font color=blue&gt;blue&lt;/font&gt;  - &lt;font color=green&gt;green&lt;/font&gt;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.daihuiyou.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>clovers</title>
    <link href="https://www.daihuiyou.top/2018/08/28/clover/"/>
    <id>https://www.daihuiyou.top/2018/08/28/clover/</id>
    <published>2018-08-28T07:38:38.000Z</published>
    <updated>2018-11-09T06:12:27.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://i.imgur.com/DQ79vXy.png" alt=""></p><p><strong>快捷键技巧：</strong></p><font color="red"><br>Ctrl+W关闭页面<br><br>Ctrl+Tab切换页面<br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="clovers" scheme="https://www.daihuiyou.top/tags/clovers/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://www.daihuiyou.top/2018/08/28/Git/"/>
    <id>https://www.daihuiyou.top/2018/08/28/Git/</id>
    <published>2018-08-28T07:35:41.000Z</published>
    <updated>2018-11-09T06:13:12.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="GitHub基本概念"><a href="#GitHub基本概念" class="headerlink" title="GitHub基本概念"></a>GitHub基本概念</h3><ul><li><strong><em>Repository</em></strong>： 开源项目</li><li><strong><em>Issue</em></strong>： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个<strong><em>Issue</em></strong> ，然后这些问题逐个去修复，即一个一个<strong><em>Close</em></strong>掉。</li><li><strong><em>Star</em></strong>：关注</li><li><strong><em>Fork</em></strong>：引用别人的开源项目</li><li><strong><em>Pull Request</em></strong>：在<strong><em>Fork</em></strong>的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 <strong><em>review</em></strong>, 就接受你的<strong><em>Pull Request</em></strong>。</li><li><strong><em>Watch</em></strong>： <strong><em>Watch</em></strong>了该项目，它的任何更新消息，会通知你。</li><li><strong><em>Gist</em></strong>： 单纯分享代码段。</li></ul><h3 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h3><p>ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。  </p><p>将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。</p><h3 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h3><p>git push origin master : 把本地代码推到远程master分支。  </p><p>git pull origin master : 远程master的最新代码拉下来。</p><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。  </p><p>在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里  </p><pre><code>git config -global user.name &quot;stromzhang&quot;  git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot;</code></pre><p> <strong><em>Pull requests</em></strong>： 我们每个人都可以一起参与开发，一起来完善，而这都通过<strong><em>Pull requestss</em></strong>来完成。  </p><ul><li><strong><em>fork</em></strong> 他人项目</li><li><strong><em>git clone</em></strong> （fork 来项目）</li><li>在本地，自己修改这个项目</li><li><strong><em>git push</em></strong> 到自己远程仓库</li><li><strong><em>Pull requests</em></strong> 到 他人项目上</li><li>他人 <strong><em>reviews</em></strong> 你在他项目修改什么， 并觉得合理， 就接受你的PR。</li><li>完成这个项目的贡献。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.daihuiyou.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>学会提问</title>
    <link href="https://www.daihuiyou.top/2018/08/21/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE/"/>
    <id>https://www.daihuiyou.top/2018/08/21/学会提问/</id>
    <published>2018-08-21T04:19:37.000Z</published>
    <updated>2018-11-09T06:07:44.765Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。</p><p>但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 </p><p>看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。</p><h3 id="读书摘抄"><a href="#读书摘抄" class="headerlink" title="读书摘抄"></a>读书摘抄</h3><p><strong>价值观</strong>：  </p><ol><li>苏格拉底说过的话:”我唯一所知的就是我一无所知。”  </li><li>找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。</li></ol><p>关键问题：论题和结论。</p><p>没有把证据支撑的断言称为纯观点。</p><p>写作建议：在写作之前最好确定好论题，引导读者得出你的结论</p><p>如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。  </p><p>一个论证的表面结构由理由和结论两部分组成。</p><p>我们把没有明说出来的想法成为假设。</p><p>先检查理由，然后检查结论，寻找价值观假设和描述性假设。  </p><p>假设越可疑，推理和结论的相关程度也就越小。</p><p>用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。</p><p>单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。</p><ul><li>价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。  </li><li>价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。</li><li>谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。</li><li>过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。  </li><li>以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。</li><li>循环论证谬误指在推理过程中已然假设自己的结论成立的论证。</li><li>人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="摘抄" scheme="https://www.daihuiyou.top/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建流程</title>
    <link href="https://www.daihuiyou.top/2018/08/20/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.daihuiyou.top/2018/08/20/hexo博客搭建流程/</id>
    <published>2018-08-20T06:03:47.000Z</published>
    <updated>2018-11-09T06:12:02.410Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记录总体的搭建流程"><a href="#记录总体的搭建流程" class="headerlink" title="记录总体的搭建流程"></a>记录总体的搭建流程</h2><ol><li>搭建Node.js环境：命令行使用<strong>node -v</strong>查看版本。</li><li>安装Hexo博客框架：<strong>npm install hexo-cli -g</strong></li><li><strong>安装git, git同步在github上</strong>。</li><li>开启GitHub Pages服务： <strong>注意要选择主题，才有效。</strong></li><li>创建文件夹，存放博客文件： hexo init  myHexoBlog   </li><li>hexo g  //g是generetor的缩写，生成博客</li><li>hexo s  //s是server的缩写，启动服务</li><li><strong>hexo与github关联起来</strong></li><li>绑定域名</li><li>更换主题</li></ol><hr><h2 id="安装git-git同步在github上"><a href="#安装git-git同步在github上" class="headerlink" title="安装git, git同步在github上"></a>安装git, git同步在github上</h2><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><ol><li><strong>生成ssh密钥文件：</strong>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</li><li>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</li><li>打开GitHub_Settings_keys 页面，新建new SSH Key</li><li>在Git Bash中检测GitHub公钥设置是否成功，输入 <strong>ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> </strong></li></ol><hr><h2 id="hexo与github关联起来：打开站点的配置文件-config-yml"><a href="#hexo与github关联起来：打开站点的配置文件-config-yml" class="headerlink" title="hexo与github关联起来：打开站点的配置文件_config.yml"></a>hexo与github关联起来：打开站点的配置文件_config.yml</h2><pre><code>deploy:      type: git      repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git      branch: master</code></pre><hr><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><pre><code>ping www.daihuiyou.github.io #得到IP值</code></pre><p> 第一步：在阿里云解析服务： 填写</p><pre><code>主机记录www对应 daihuiyou.github.io主机记录@对应 www.daihuiyou.github.io主机记录www对应 185.199.111.153主机记录@对应 185.199.111.153</code></pre><p> 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top</p><p> 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top</p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>待更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="博客" scheme="https://www.daihuiyou.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://www.daihuiyou.top/2018/08/19/My-New-Post/"/>
    <id>https://www.daihuiyou.top/2018/08/19/My-New-Post/</id>
    <published>2018-08-18T16:06:36.000Z</published>
    <updated>2018-11-09T06:11:44.537Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Have-a-good-day"><a href="#Have-a-good-day" class="headerlink" title="Have a good day!"></a>Have a good day!</h4><h4 id="Cease-to-struggle-and-you-cease-to-live"><a href="#Cease-to-struggle-and-you-cease-to-live" class="headerlink" title="Cease to struggle and you cease to live."></a>Cease to struggle and you cease to live.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="the first post." scheme="https://www.daihuiyou.top/tags/the-first-post/"/>
    
  </entry>
  
</feed>
