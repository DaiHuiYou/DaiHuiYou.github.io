<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Will&#39;s notebook</title>
  
  <subtitle>Share My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.daihuiyou.top/"/>
  <updated>2018-11-11T05:07:37.883Z</updated>
  <id>https://www.daihuiyou.top/</id>
  
  <author>
    <name>Will</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高质量C/C++编程指南</title>
    <link href="https://www.daihuiyou.top/2018/11/10/%E9%AB%98%E8%B4%A8%E9%87%8FC-C-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <id>https://www.daihuiyou.top/2018/11/10/高质量C-C-编程指南/</id>
    <published>2018-11-10T14:35:20.000Z</published>
    <updated>2018-11-11T05:07:37.883Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/DmB8JRq.png" alt=""></p><p><img src="https://i.imgur.com/oFJG3d5.png" alt=""></p><p><img src="https://i.imgur.com/opZoFYf.png" alt=""></p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="https://i.imgur.com/Yg9biEW.png" alt=""></p><h3 id="程序的版式"><a href="#程序的版式" class="headerlink" title="程序的版式"></a>程序的版式</h3><p><img src="https://i.imgur.com/54ejPJG.png" alt=""></p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><img src="https://i.imgur.com/xttjlnC.png" alt=""></p><h3 id="表达式和基本语句"><a href="#表达式和基本语句" class="headerlink" title="表达式和基本语句"></a>表达式和基本语句</h3><p><img src="https://i.imgur.com/ej4dwX5.png" alt=""></p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><img src="https://i.imgur.com/egopXNd.png" alt=""></p><h3 id="函数设计"><a href="#函数设计" class="headerlink" title="函数设计"></a>函数设计</h3><p><img src="https://i.imgur.com/6PveAhv.png" alt=""></p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p><img src="https://i.imgur.com/auXwoF0.png" alt=""></p><h3 id="c-函数的高级特性"><a href="#c-函数的高级特性" class="headerlink" title="c++函数的高级特性"></a>c++函数的高级特性</h3><p><img src="https://i.imgur.com/txOQAkG.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DmB8JRq.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/oFJG3d5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.i
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程规范" scheme="https://www.daihuiyou.top/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://www.daihuiyou.top/2018/11/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.daihuiyou.top/2018/11/08/设计模式/</id>
    <published>2018-11-08T10:56:26.000Z</published>
    <updated>2018-11-09T08:03:47.247Z</updated>
    
    <content type="html"><![CDATA[<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p><img src="https://i.imgur.com/RfWAInW.png" alt=""></p><pre><code class="c++">//抽象工厂模式， 生产一组产品class Fruit{public:    virtual void SayName() = 0;};class AbstractFactory{public:    virtual Fruit *CreateBanana() = 0;    virtual Fruit *CreateApple() = 0;};class NorthBanana : public Fruit{public:    virtual void SayName() {        cout &lt;&lt; &quot;It&#39;s north banana&quot; &lt;&lt; endl;    }};class NorthApple : public Fruit{public:    virtual void SayName() {        cout &lt;&lt; &quot;It&#39;s north apple&quot; &lt;&lt; endl;    }};class SouthBanana : public Fruit{public:    virtual void SayName() {        cout &lt;&lt; &quot;It&#39;s south Banana&quot; &lt;&lt; endl;    }};class SouthApple : public Fruit{public:    virtual void SayName() {        cout &lt;&lt; &quot;It&#39;s south apple&quot; &lt;&lt; endl;    }};class NorthFactory : public AbstractFactory{public:    virtual Fruit *CreateBanana() {        return new NorthBanana();    }    virtual Fruit *CreateApple() {        return new NorthApple();    }};class SouthFactory : public AbstractFactory{public:    virtual Fruit  *CreateBanana() {        return new SouthBanana();    }    virtual Fruit *CreateApple() {        return new SouthApple();    }};void main(){    AbstractFactory *af = NULL;    Fruit    *fruit = NULL;    af = new NorthFactory();    fruit = af-&gt;CreateApple();    fruit-&gt;SayName();    delete fruit;    fruit = af-&gt;CreateBanana();    fruit-&gt;SayName();    af = new SouthFactory();    fruit = af-&gt;CreateApple();    fruit-&gt;SayName();    delete fruit;    fruit = af-&gt;CreateBanana();    fruit-&gt;SayName();    system(&quot;pause&quot;);}</code></pre><h5 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h5><pre><code class="c++">class House{public:    void setDoor(string door) {        this-&gt;m_door = door;    }    void setWall(string wall) {        this-&gt;m_wall = wall;    }    void setWindow(string window) {        this-&gt;m_window = window;    }    string getDoor() {        cout &lt;&lt; m_door &lt;&lt; endl;        return m_door;    }    string getWall() {        cout &lt;&lt; m_wall &lt;&lt; endl;        return m_wall;    }    string getWindow() {        cout &lt;&lt; m_window &lt;&lt; endl;        return m_window;    }private:    string m_door;    string m_wall;    string m_window;};class Builder{public:    virtual void buildWall()     = 0;    virtual void buildDoor()     = 0;    virtual void buildWindow()    = 0;    virtual House* getHouse()     = 0;};class FlatBuilder : public Builder{public:    FlatBuilder() {        m_house = new House;    }    virtual void buildDoor() {        m_house-&gt;setDoor(&quot;Flat door&quot;);    }    virtual void buildWall() {        m_house-&gt;setWall(&quot;Flat wall&quot;);    }    virtual void buildWindow() {        m_house-&gt;setWindow(&quot;Flat window&quot;);    }    virtual House *getHouse() {        return m_house;    }private:    House *m_house;};class VillaBuilder : public Builder{public:    VillaBuilder() {        m_house = new House;    }    virtual void buildDoor() {        m_house-&gt;setDoor(&quot;Villa door&quot;);    }    virtual void buildWall() {        m_house-&gt;setWall(&quot;Villa wall&quot;);    }    virtual void buildWindow() {        m_house-&gt;setWindow(&quot;Villa window&quot;);    }    virtual House *getHouse() {        return m_house;    }private:    House *m_house;};class Director{public:    Director(Builder *build) {        m_build = build;    }    void Construct() {        m_build-&gt;buildWall();        m_build-&gt;buildWindow();        m_build-&gt;buildDoor();    }private:    Builder *m_build;};void main(){    House        *house = NULL;    Builder        *builder = NULL;    Director    *director = NULL;    builder = new VillaBuilder();    //设计师 指挥 工程队 干活    director = new Director(builder);    director-&gt;Construct();    house = builder-&gt;getHouse(); //返回房子    house-&gt;getWindow();    house-&gt;getDoor();    delete house;    delete builder;    //请 FlatBuilder 公寓    builder = new FlatBuilder;    director = new Director(builder);    director-&gt;Construct();    house = builder-&gt;getHouse();    house-&gt;getWindow();    house-&gt;getDoor();    delete house;    delete builder;    delete director;    system(&quot;pause&quot;);    return;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;抽象工厂模式&quot;&gt;&lt;a href=&quot;#抽象工厂模式&quot; class=&quot;headerlink&quot; title=&quot;抽象工厂模式&quot;&gt;&lt;/a&gt;抽象工厂模式&lt;/h5&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RfWAInW.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="理论" scheme="https://www.daihuiyou.top/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>歌曲改变人生</title>
    <link href="https://www.daihuiyou.top/2018/11/07/%E6%AD%8C%E6%9B%B2%E6%94%B9%E5%8F%98%E4%BA%BA%E7%94%9F/"/>
    <id>https://www.daihuiyou.top/2018/11/07/歌曲改变人生/</id>
    <published>2018-11-07T15:36:27.000Z</published>
    <updated>2018-11-09T06:08:43.170Z</updated>
    
    <content type="html"><![CDATA[<p>因为一首歌， 才去看一部电影， 大概只有这部了。</p><p>当看到男主生活地越来越好，如电影所说，歌曲真的可以改变人生。女主，除了她美妙的声音，还留下印象是穿搭风格，想起来那时2013年所拍摄的，因为时间落差感，现在看起来这样的穿搭，更nice。</p><p>电影中的一群热爱音乐的人，他们因为歌曲而聚在一起，因创作歌曲的过程而彼此成为朋友。我觉的生活，就该如此，找到共同兴趣的人，愉快的玩耍，真好。</p><p><img src="https://i.imgur.com/VWQ8EWP.png" alt=""></p><p><img src="https://i.imgur.com/WN8fOXb.png" alt=""></p><p>看完小感触，自己的兴趣是什么呢， 首先兴趣肯定是使一个人有学习的愉悦感，然后持续地练习，并得到自己和他人的赞赏，才叫做兴趣，至少我认为是这样。</p><p>想一想，或者唱歌，虽然我五音不全， 再或者英语，口语很差。现在我回答不了，我希望以后能够找到，并能回答。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为一首歌， 才去看一部电影， 大概只有这部了。&lt;/p&gt;
&lt;p&gt;当看到男主生活地越来越好，如电影所说，歌曲真的可以改变人生。女主，除了她美妙的声音，还留下印象是穿搭风格，想起来那时2013年所拍摄的，因为时间落差感，现在看起来这样的穿搭，更nice。&lt;/p&gt;
&lt;p&gt;电影中的
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="电影" scheme="https://www.daihuiyou.top/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>知识星球</title>
    <link href="https://www.daihuiyou.top/2018/11/04/%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/"/>
    <id>https://www.daihuiyou.top/2018/11/04/知识星球/</id>
    <published>2018-11-04T11:37:44.000Z</published>
    <updated>2018-11-09T06:13:35.555Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电动汽车可能会是未来的一场革命"><a href="#电动汽车可能会是未来的一场革命" class="headerlink" title="电动汽车可能会是未来的一场革命"></a>电动汽车可能会是未来的一场革命</h3><p>球友们都知道，我相对比较关注趋势，因为如果看清了趋势，其实就能比别人更容易把握更多的机会。之前我在星球里简单的说了下，我说我看好电动汽车未来的发展，今天就给大家简单的说下一些逻辑以及有哪些机会。</p><ol><li><p>电动汽车用电，传统汽车用油，所以第一个理由大家自然就想到了，电是可再生资源，石油是不可再生资源，哪怕储备还很丰富，但是总有一天是贫乏的时候，从现在油价频涨，相信大家都能感受到，而电费比油价便宜的多，从这点来说，电动汽车本身就有绝对优势。</p></li><li><p>传统汽车其实最核心的就是在于发动机、变速箱以及一系列复杂的构造，很多跑车家族研究了几十年、上百年才取得一些技术上的优势，然而电动汽车几乎颠覆了传统车企，不管是构造上还是技术上，完全不一样，可以算上是弯道超车了。</p></li></ol><p>举个例子，多少跑车家族在百米加速上，吭哧吭哧研究了多少年，才能取得一些进步，然而特斯拉这才出来多少年，在百米加速上几乎秒杀各种豪华跑车，听起来都觉得疯狂。</p><p>电动车在构造上也相当简单，而且不需要传统车企每年对发动机的维护保养，动力引擎就是很简单的电机，从技术、技术构造上，电动汽车绝对是弯道超车，秒杀级的。</p><ol start="3"><li>你们知道么，现在几乎所有巨头，都在涉足电动汽车领域，不仅传统车企，像宝马、奔驰、保时捷等在研发电动车，就连很多科技巨头，Google、Apple 也在或者打算做电动车，知道原因么？</li></ol><p>原因就在于，现在都看清楚了，汽车就是未来一个完整的操作系统，以后的车完全会像现在的手机这样智能，远程操纵、娱乐、无人驾驶等等，这些都是汽车未来的方向，而如果动力只能靠油来提供，毫无疑问，代价太大，如果汽车本身就是电动汽车，本身的动力就来自于电，就像我们的手机和电脑，电力足够，那未来的汽车，就是现在的智能手机，想象空间巨大。以后的汽车系统，会不会像现在的手机系统，诞生出苹果和安卓系统，那商业价值巨大，各大巨头都在瞄准这块。</p><p>所以，电动汽车是未来的发展方向，而且全球整个市场巨大，商业价值也极大。</p><ol start="4"><li>在特斯拉没做出成绩以前，没有人看好，没人在意，因为觉得电动车续航是问题，而且早电动车成本很高，赚不了钱。确实，电动汽车之所以成本很高，主要是这是一个新兴市场，科技溢价很高，而且在续航方面需要大力投入，基础设施不够完善，不够成熟，这块成本超高。</li></ol><p>但是随着科技的发展，锂电池领域的持续突破，基础设施的逐步完善，所有问题都会败给时间，而且一旦形成规模效应，成本就是极大降低，特斯拉在上个季度破天荒的盈利了，我想，这都得益于规模效应，而且你得相信，未来锂电池的一定会有更大的突破，这是历史发展的规律，续航在未来，不会有问题，以后续航会更持久，充电会更简单方便。</p><ol start="5"><li><p>环境问题是全球的问题，电动汽车比燃油车有天然的环保优势，多个国家都在大力提倡电动车。</p></li><li><p>特斯拉从以前的不被看好，到上个季度的盈利，再到现在各大企业巨头纷纷加入电动汽车大军，这是好事，有竞争，才会促进技术更快的进步，相信，电动车的技术突破，再未来应该比以前发展的要快的多。</p></li></ol><p>仔细想一下，功能机到智能机的过度是不是也类似，智能机一样开始不被重视，很多手机厂商一样一开始就在亏损，基站、网络的基础设施一样在后续逐渐的丰富，历史总是惊人的相似。</p><p>所以，综上，我认为，电动汽车在未来可能会是一场革命，可能会影响着很多地方，不管是对人们生活的影响，还是对商业价值的取缔，都是巨大的。</p><p>那么对我们普通人有什么样的机会呢？</p><p>当下国内电动车的现状是，很多企业冲着国家的补助，各种骗补贴，技术其实很垃圾，尤其很多国企为主，真正做事的很少，但是因为这是未来的方向，只要这个行业有真正做实事的，比如特斯拉和一些新加入的巨头，总会反向激励更多的企业会重视，会足够的创新，所以，当下国内电动车市场很乱不是问题，随着时代的发展，一些骗取补贴的企业终将淘汰。</p><p>对我们普通人来说，一是，如果你是汽车行业，不妨加入一些电动汽车行业的车企，也许你就踩到了节奏，因为这在未来很可能是一个飞速发展的行业。国内我觉得相对还可以的电动车企有蔚来、车和家、比亚迪、上汽荣威等。</p><p>二是其实最近不是跟大家普及一些投资理财知识么，其实投资，如果结合趋势也是一个不错的选择，如果你在定投基金，不妨考虑定投相关的基金，哪怕你要定投股票，也可以适当考虑下，比如国内上市公司电动汽车龙头比亚迪，虽然我很不喜欢比亚迪，但是在国内比亚迪相对来说算做的还可以的了，锂电池龙头宁德时代，国外电动汽车龙头就不说了，特斯拉。</p><p>三是，如果智能汽车后续全面普及，那么智能汽车上面相关应用的开发没准也会是一个新的需求呢，但因为开车场景的限制，不可能像玩手机这么随意，所以这类开发应用应该没那么广泛，除非，无人驾驶的全面普及。</p><p>不过以上不作为投资建议，请自行参考，而且电动汽车真正会在什么时候爆发，是 3 年后还是 5 年后，这个谁也说不准，只能说之后我会持续关注这个行业的发展，后续看是否有持续更多的机会。</p><p>以上仅是我的个人看法，跟大家分享下。</p><h3 id="人人都要懂点投资理财-01"><a href="#人人都要懂点投资理财-01" class="headerlink" title="人人都要懂点投资理财 01"></a>人人都要懂点投资理财 01</h3><p>从今天开始，给大家普及一系列的投资理财知识，我把这个系列叫做「人人都要懂点投资理财」，很俗，但是标题我觉得没那么重要，主要在于内容。在普及之前我还特意在星球做了调查，大概了解下球友们的投资理财经验，我发现其实大部分人都是很初级的，很大一部分人甚至从没接触过，基本上跟我预期一致，所以会从 0 开始普及，如果部分有基础的球友，希望有点耐心，哪怕有些东西是你已经知道的，但是当是复习了，或者看下是否有跟你以往理解的不一致的，后面肯定有你不知道，或者不具备的一些知识。</p><p>可能有人会说，市面上的投资理财课程与书籍很多，想要学的干脆自己去学好了。这么说吧，市面上的课程与书籍太啰嗦了，而且喜欢堆一些高大上的概念，我看过的投资理财书很多，这点我很有说服力，我觉得太不友好了，另外，我自己虽然算不上什么专家，但是我在投资理财方面的知识以及实践不少，接触的资源也远比大家多，应该比 99% 比例的球友懂得多些，所以，这个系列我希望试图用我总结的最精炼的语言，让大家都能够理解，并且以科普知识为主，不会推荐理财平台与股票，绝对不会有任何广告夹杂，就是单纯的把我积累的知识尽我所能的给大家普及，大家不用抱着看完可以一夜暴富的心态来学习。</p><p>至于这个系列有多少篇，实话说，我也不知道，直到我认为把一些重要的东西给大家普及完，让大家理解完为止。</p><p>好，下面进入正题。</p><p>我想在这个系列文章之前，大家肯定有诸多疑问，而且你们的疑问我基本都很了解，今天，这篇文章，先给大家解答几点疑问。</p><ol><li>我为什么要学投资理财呢？</li></ol><p>相信这个问题是大家第一关心的，让我做某件事，你得先说服我为什么要做这件事。以前我说过，选择职业尽量选择积累性很强的职业，随着时间的推移，这个技能越来越厉害，那这个职业就很值得去选择。毫无疑问，投资理财，这个技能积累性就很强，最重要的是，这个职业适用于任何人、任何行业，因为投资理财的本质，是用钱来帮你赚钱，我以前也说过，这是最高级别的赚钱方式，除非你不想赚钱，否则每个想赚钱的人，都该重视投资理财。</p><p>你有没有发现一个现象，越是有钱人，越是懂得投资理财，投资理财方式多种多样，有人买基金，有人买股票，更有钱的人直接当股东，自己持有股票，这些都有投资理财的方式而已，反而越是普通老百姓越没有这方面的意识。有人说了，人家懂得投资理财是因为人家有钱啊，我没钱，我理个毛财啊，所以，第二个问题就来了。</p><ol start="2"><li>我现在没钱，要学习投资理财么？</li></ol><p>多少钱是有钱，多少钱是没钱呢？这个概念是相对的，很多人总有个误区，认为人家存款 200w，投资理财赚个 10% 可以赚 20w，这是一大笔钱啊。我只有 2w 存款，我赚 10% 不过才 2000 块而已，跟人家 20w 的利润比不了。</p><p>这就是个误区，理财从来是追求的收益比，你只有 2w 的时候，突然多出来 2000 块，绝对是一笔不小的收入，你存款 2w 想着可以跟别人一样赚 20w，那简直是做梦。但是在资产越少的人，学习投资理财越有优势。</p><p>因为投资理财是有风险的，你的本金小，相应的风险就小，因为你的能力也在积累，你的财富也在越来越多，现在承受的风险随着你各方面的积累，其实是很低的。相反，如果你工作十年，积累了 200w 存款，这时候才想着去学习投资理财，那风险是极大的，你自身进步空间也在降低，相对下来，风险就极高了。</p><p>所以，投资理财越早越好，在本金最小的时候，也是风险最小的时候，利用风险最少的时机去学习一门技能，这是最划算不过的，而且你得相信，未来，你是越来越有钱的。</p><ol start="3"><li>除了学习一门技能，还能给我带来什么？</li></ol><p>有人说了，我学习投资理财，能让我发财么？说实话，我是见过靠着投资理财发财的，而且一开始的本金很少，但是这部分人极少，如果你认为你就是这种人，那目的就错了，我以前就说过，哪怕最后结果你是，但是也千万不要认为自己是那个天选之人。又有人说了，投资理财不能让我发财，那我还学有个啥大用。</p><p>这里有个小段子，如果你问你 80 岁的老太太，这辈子做过最后悔的事是什么？她可能会告诉你，她最后悔的事就是把钱存银行了。</p><p>虽然是个小段子，但是这是当下的现实，而大部分人的意识都是把钱存银行，但是你得知道，政府一直在印钱，通货一直在膨胀，看看十年前的 100 块，再看看十年后的 100 块，如果你把你的 100 块存银行存 10 年，那简直是最愚蠢的决定，那是老百姓最愿意干的事。所以，投资理财虽然不能让你发财，但是最起码的是，可以让你跑赢通货膨胀，让你的存款越来越值钱些。</p><p>而如果你胆子再大些，眼光再独到些，还买到了一些有成长性的公司的股票，那会让你的财富更快的增值，看看十年前的腾讯、苹果、Google 的股票，那么恭喜你，你的投资方式就让你享受到了巨大的回报。</p><p>再往大了说，十年前的国家与全球经济，跟现在的国家与全球经济比起来，那是巨大的进步，合理的投资理财，其实除了可以享受公司成长带来的回报之外，甚至可以享受国家的发展、全球经济发展带来的红利，这就在于你是否有独到的眼光与魄力了。</p><p>以上这些东西都是投资理财额外给你带来的回报，这跟你自身的成长带来的回报是不冲突的。</p><p>大部分人，总是愿意把宝压在自己身上，认为自己有能力，自己更牛逼，不愁赚不到钱，这是正确的，但是这跟其他事情是不冲突的，不妨稍微有点开放的思维，除了我自身成长之外，我稍微拿出点精力，押宝在别处，机会是不是也更大呢？投资理财就是值得你拿出点精力做押宝的事情，也许你自身发展很一般，但是你分享到了很多牛逼的公司发展带来的回报，甚至享受到了国家的发展带来的回报，别人的财富是线性增长，你的财富很可能是指数增长，这些可能是自己从未预料到的，这也是投资理财带来的魅力。</p><ol start="4"><li>投资不是有风险么？</li></ol><p>相信，大家都听过一句话，投资有风险，入市需谨慎。很多人一听有风险，就不愿意干了，但是我很早以前就在星球写过一篇文章，绝大部分人都缺乏一种特质，就是冒险精神，你可以去分析任何一位成功人士，是的，任何一位，无一不具备冒险精神，敢干，才有可能成功。这个世界是公平的，没有风险，只有回报的事，那根本轮不到你了，有风险不可怕，怕的是你看不到风险带来的机会，不过投资理财的方式有很多种，有风险很低，也有风险相对较高的，这取决于你的风格以及所能接受的风险程度了，这个讲到具体投资方式的时候会再单独说下风险控制。</p><p>总之，投资是有风险的，但是风险也意味着机会，很多时候，一件事情，正是因为有风险，才过滤掉了大部分人。</p><p>最后，想要学习投资理财，一定要先具备这个意识，基于以上分析，我才认为人人都该具备点投资理财，但是从实际情况来说，懂得投资理财的人在全中国范围内人比例很少，尤其懂得合理投资理财、具备一定专业知识的人更是少之又少，希望球友们都能有一种投资理财意识，接着，我希望后面给大家在投资理财之前，给大家普及一些专业的知识，而不至于像市面上绝大部分韭菜一样，冲着发财无脑进去的投机客，多少是一些帮助的。</p><p>PS：第一篇想给大家普及意识，后续会不定期持续更新该系列，觉得写的不错，记得点赞。</p><h3 id="人人都要懂点投资理财-02"><a href="#人人都要懂点投资理财-02" class="headerlink" title="人人都要懂点投资理财 02"></a>人人都要懂点投资理财 02</h3><p>上篇我们说到了投资理财的重要性，相信大家都已经具备了基本的投资理财观念，那么今天给大家说下投资理财的品种。</p><p>宽泛的投资理财品种非常多，比如你线下投资一家餐馆，比如买比特币，比如买房子、买商户屯着等等都属于投资理财，但是这类就不是大众能接受的投资理财方式了，今天，我只给大家普及一些常见的，适合大众的投资理财方式。</p><p>一般来说，投资理财的方式有银行理财产品、债券、基金、股票等几类，咱们一个个来说。</p><ol><li><p>银行理财产品<br> 其实你把钱存银行里，也是有利息的，但是利率极低，有些国家甚至都是负利率，中国倒没那么夸张，大概在一点几个点，几乎可以忽略，但是中国人传统的方式一直认为把钱放银行是最安全的，所以银行理财是很多人，包括很多底层老百姓最普遍、最信任的一种方式。这类收益一般铁定安全，除非银行倒闭，预期收益多在 4% - 5% 之间，不过一般对资金有要求，多是 5-10 万元人民币起投，不过现在门槛也降下来了，1w 好像就可以了，是一个保本的稳定收益理财渠道，不过缺点是必须有一定的时间限制，临时有事要用钱，没法提前兑付。</p></li><li><p>互联网理财产品<br> 近几年，理财种类很多，其实除了银行理财，互联网也出了一些理财产品，比如微信、支付宝、京东金融上都有一些，收益可能会比银行多一点，但是没有本质区别，就不多说了，不过，这种可能也就适合互联网从业人士，因为你分得清哪些是大平台，哪些是小平台，小老百姓肯定不适合。</p></li><li><p>互联网 P2P<br> 虽然现在 P2P 处于风口，但是不得不说，P2P 是金融领域的一个新的形式，而且收益很高，现在可能会比较低，但是刚出来的时候，一些年化收益甚至高达 15%、20%，当然，我说的是靠谱的平台，不靠谱的平台那更夸张。现在一般年化多在 8%-12% 左右，再高就要小心点了。就是 P2P 现在国家在大力整治，虽然有些平台比较靠谱，但是之前跑路的太多了，相信等整治完毕之后，我个人认为 P2P 是一种相对来说对普通人还不错的投资渠道，起码收益比银行理财产品高得多了，就是现在还处于一个行业整顿时期，不建议现在就投。</p></li><li><p>基金<br> 说到基金，其实就比较复杂了，简单来说，基金就是属于，如果你不懂如何投资理财，就把你的钱交给专业的基金经理人，他们帮你打理，然后收取管理费，帮你做收益，收益不是很稳定，毕竟是有基金经理打理的，盈亏自负你都得承担着。但是好处就是，大家一起凑钱，你 100，我 100，放一起钱就多了，所以起投限制很小，一般都是 100 块起投，但是现在也有不少基金起投不限制了。但是基金又有很多种，大概有以下常见的几种：</p></li></ol><ul><li><p>货币基金<br>货币基金其实这几年特别火，主要是被余额宝带火的，现在最有代表性的就是余额宝、微信理财通。货币基金简单来说就是，一些基金机构把你的钱投资在一些保本、稳定赚钱的地方去，所以基本上也是保本的，无风险的，优势是灵活性、流通性很好，可以随时随取，缺点是收益很低，不过余额宝刚出来的时候很不错，一度可以到 7% 收益，刚瞅了眼现在余额宝的七日年化收益，连 3% 都不到了，但是也比放银行存款强些，对于不少需要随时用钱的人来说，钱放着有点收益就算点呗。</p></li><li><p>债券型基金<br>债券啥意思呢？有点类似于欠条，就好比我找你借钱，给你写张欠条，写明欠你多少钱，利息多少，到期兑付。债券类似，只不过债券是一些机构、政府、企业甚至国家为了募集资金发行的。所以，债券型基金，主要是为了大家募资，投资债券方面，也是保本的，不会亏损，收益一般比货币基金要高些，只不过这个概念很多人不理解，所以大众投的少而已。</p></li><li><p>股票型基金<br>股票型基金就好理解了，很多人想把钱投资股市，但是自己又不懂股市，所以就把钱交给一些专业的股票投资经理，他们拿你们的钱去投资股市，所以更专业些，更保险些，但是这类基金跟前面的都不一样，前面的都是保本，这类基金投资股市，所以很有可能也会亏损的，亏损你也得自行承担，但一般相比你个人买股票来说，如果环境很差，你很可能亏损 50%，但是专业的股票基金经理，可能会懂得控制风险，可能只会亏 10%，行情好的时候，你个人买的股票可能跑不赢大盘，但是这类股票型基金，跑赢大盘相对很容易。</p></li></ul><p>这类基金是有风险的，适合可以承受本金有一定程度损失的人投资，但是风险也意味着有大回报，所以如果赚了，肯定收益也比以上的任何类型基金都要高，一般幅度在 -20%-20% 之间，所以很公平，想赚更多，意味着也必须承担更高的风险。</p><p>之前有球友问，为啥我买的基金一直在跌，那是因为你买的就是股票型基金，股市最近一直再跌，当然你的基金也在跌了。其实，在股市行情好的时候，如果你对股市一无所知，无脑买入股票型基金，其实是个不错的选择。</p><p>但是这类股票型基金又可以分类很多，比如什么沪深 300、中证 500、ETF、各种指数基金之类的，这个话题就比较大，后续单独开个帖子细说下。</p><ul><li>混合型基金<br>这类顾名思义，就是不是单一用途，根据不同的行情与策略，对资金分类做不同的投资。</li></ul><p>总之基金这块，其实如果想全部了解，其实挺多东西可以讲的，后续我单独说下基金这个，包括也说下一些策略</p><ol start="5"><li>股票<br> 这类就不多解释了，相信大家都懂，不过股票也分不同的市场，常见的就是 A 股（国内股市）、港股、美股，A 股因为是人民币股市，国内用户可以直接找个证券公司就可以开户投资了，港美股不行，需要到专门的券商开户，需要各种审核才能投资，因为这涉及到美元非法投资问题，所以审核比较严。相对来说，美股是比较成熟的，国内 A 股就很不成熟了，而且 A 股散户很多，亏的居多，也就被常说的韭菜，而且是政策市，很多行情，被国内政策左右，所以，我个人觉得想在 A 股赚钱很难，巴菲特一直提倡的价值投资，如果来到 A 股，估计会亏的不成样子，不过好处是，A 股也发展很多年了，也经历过各种各样的股灾，政策与制度也在不断完善，A 股上也还是有一些好的公司的，只是被炒作埋没了而已。</li></ol><p>股票这类投资就属于风险超高的了，每天的涨跌幅是 10%，可以看到一天的涨跌抵得上一般的投资理财一年的波动了，美股没有涨跌停限制，但因为美股相对比较成熟，所以，虽然没有限制，但是一般来说，也不会那么夸张，可以看到 Google、Apple 这类公司每天波动很小，也就一两个点左右，所以价值投资比较适合美股，一家好的公司，一年累积下来也有不少收益了。</p><p>投资股票适合很少的一部分人，因为他需要你有极高的风险意识，对市场有敬畏之心，有极高的策略与原则，不然，在股票市场会把人性的贪嗔痴无限放大，严重了说家破人亡完全不为过。</p><p>这类收益波动更大，年化 -100%-100% 都有可能，建议大家不要轻易进入股票市场，更不要轻易相信市面上的所谓各种股神，真正的股神都是闷声发大财的，谁一天到晚出来宣扬。</p><p>综上，保本型稳定赚钱的投资有银行理财、互联网理财、货币基金、债券型基金、P2P，但 P2P 要谨慎些，最大的风险是平台跑路，现阶段，如果不确定平台靠不靠谱，宁愿不投，。</p><p>需要承担一定风险的主要是股票型基金和混合型基金，但这类也可能获取相对还可以的回报。</p><p>更高的高风险高回报，那就是股票了，这类风险极高，可能的回报也意味着更高。</p><p>大家可以根据自己的性格选择适合自己的投资，但是一般来说，投资是需要有资产配置的，假设你都要去玩，我建议合理的资产配置是，40% 投资第一类绝对安全保本型的投资，如银行理财、货币基金，40% 投资有一定增长的投资，如互联网理财、靠谱的 P2P 平台，20% 投资有风险的股票型基金或者股票。</p><p>这是对于大部分普通人来说的，但是不同的人可以承担的风险是不一样的，比如有的人性格相对激进些，可以允许承担更高的风险，但同时向博取更高的收益，那就根据自行风格去调整，随着你的投资经验与投资水平的增长，还会进一步优化调整。但是我想强调的是，资产配置很重要，我以前一直说，鸡蛋不要放在一个篮子里，说的是对各种不同的投资方式，做各种不同的投资分配，这个观念一定要有，把钱全部买银行理财，和把钱全部买 P2P，和把钱全部 all in 股票市场是一样的蠢与贪，人生真的没有多少 all in 的机会，动不动要 all in 的人，那是赌博，不是投资。</p><p>最后，后面给大家普及更详细点的基金，以及基金定投的概念以及一些操作的策略，这篇大家先对比下自己，看下自己的可承担风险，以及资产配置大概是什么类型，做点消化。</p><h3 id="人人都要懂点投资理财-03"><a href="#人人都要懂点投资理财-03" class="headerlink" title="人人都要懂点投资理财 03"></a>人人都要懂点投资理财 03</h3><p>上一篇主要跟大家介绍了各种投资理财品种，今天主要跟大家介绍基金。</p><p>什么是基金呢？<br>简单来说，就是把那些不懂投资理财、同时又想追求财富增值的投资者的资金聚集起来，全部交给专业的基金经理们去打理，进而获取投资收益的一种方式。</p><p>可能有人会纳闷，那些基金经理们真那么牛逼？为啥不自己赚钱呢？还要帮别人赚钱？</p><p>一是基金经理们没那么多钱，他需要大量的资金去运营。二是他们也不是活雷锋，他们一般要收取一定的资金管理费，以及一部分利润，也就是说，不管赚钱还是亏钱，管理费他们都要收的，如果赚钱了，通常也会额外收取一部分利润，所以，他们也不会故意把你们的钱亏出去，毕竟他们帮你们赚的越多，他们本身也会赚的越多，而且还提升了名气，好处很大。</p><p>保本型的货币基金就不多说了，今天主要是说一些有风险的股票型基金与指数型基金，而且，严格来说，这两类现在基本是基金的最主要品种。</p><p>何为股票型基金呢？<br>简单来说就是把钱用来投资各种股票，最后达到获利的目的。有人说了？把钱交给基金经理，他们去买股票，那不如我自己去买股票了呢。这是个好问题，如果你是股票高手，没人会再去买股票基金的，所以，你看，市面上基本上买股票的人，基本都不玩基金。但是要知道，股票是风险更高的品种，而且需要你具备一定的专业知识，还需要你花很大精力去研究、去盯盘，对于大部分普通人，他是没这么专业，也没这么多时间精力去研究股票市场的，这种情况，投资股票型基金就很合适了。</p><p>啥是指数型基金呢？<br>其实，我一直觉得指数型基金也是属于股票型基金的一种，只不过指数型基金是投资各类指数的。啥是指数呢？股市的大盘指数你可能没怎么接触过，但是百度的搜索指数都知道啥意思吧？就是通过某种算法来反应出某个搜索关键字的热度。</p><p>大盘指数也是类似意思，拿美国纳斯达克来说，基本上全球顶尖的科技股都会在纳斯达克上市，整个纳斯达克有五六千只股票，每天这些股票涨涨跌跌参差不齐，所以把纳斯达克所有股票的走势按照某种算法，得出一个指数，这个指数反映了整体纳斯达克市场的趋势，这就是纳斯达克指数的用处。如果你看纳斯达克指数涨了，那基本上反应了整体股票市场走势向好，可以看到，美国纳斯达克指数一路走高，反映了这些年美国股市的牛市。</p><p>拿我 A 股举例，我们国家有两家证券交易所，分别是上海和深圳证券交易所，对应着上证指数和深证指数，分别反映了这两家交易所所有股票的走势，因为上海证券交易所最早，而且很多国企蓝筹股基本都上市上证，所以我们常说的大盘指数一般也就是指上证指数，但其实深证交易所分的比较细，分别有创业板、中小板，创业板言外之意针对中小公司和创业公司，因为以前国内上市条件比较苛刻，所以为了改革照顾一些中小创业公司，特意放宽条件，允许他们在这类板块上市。</p><p>所以，你看，指数型基金也多种多样，比如沪深 300，意味从上海、深圳俩交易所挑选了 300 个最有代表性、成长性很高的蓝筹股作为标的，来反应综合表现的指数，再比如中证 500，挑选了 500 只小市值股票来综合反应的。</p><p>总之，基金的种类太多，如果真要列出来，至少也有几千只，碰到不懂的你去搜下基本就知道这基金代表什么意思了。</p><p>我知道，很多人肯定会问？那我该买哪些呢？该怎么买呢？</p><p>这里先讲一个故事。腾讯有个老员工，每月收入除开销外全部买了公司股票，不管涨跌，坚持了七年，生活简朴，只有夏利一辆，目前资产过亿。中国石油也有个老员工，每月收入除开销外也全部买了公司股票，不管涨跌，坚持了六年，生活简朴，最终宝马也换成了自行车，目前负债累累。</p><p>所以你看，都是定投股票，但是选错了标的，结果大大不一样。</p><p>对于大部分普通人来说，在熊市坚持定投指数型基金是一个最容易赚钱的方法。</p><p>首先为啥是指数型基金，因为选择一个好的股票，有很大运气成分，但是如果你看好某一行业的未来，看好某一领域的发展，那定投相应的指数型基金一定没问题，巴菲特曾说过一句意味深长的话：买只指数基金，然后努力工作！</p><p>所以，很简单，如果你看好中国股市的未来发展，那就去定投大盘指数基金，如果你看好新能源、看好环保、看好国企等等，就可以买对应的指数型基金就好了。</p><p>至于这些指数型基金哪里买，支付宝、微信理财通、同花顺、东方财富这类股票交易软件也都可以买到。</p><p>这里顺便给大家简单说下定投，所谓定投，就是定期拿一笔钱投资，不管大盘涨跌，每月设置好买入的金额，然后正常工作就好了。至于定投多少，其实取决于你个人的风险承受能力和经济能力，对于新手、0 经验的，我建议每月拿工资的十分之一定投，这部分钱对你的生活不会有什么影响，当然了，我说的是对新手，如果你有一定经验，并且了解自己的风险承受能力，那自行根据自己风格去调整好了。</p><p>有人可能又问了，我没什么主见，没啥看好的领域，有没有那种傻瓜式操作的？别说还真有，现在市面上很多产品都是很自动化、人性化的了，比如以前我推荐过的「且慢」，他们自己有一套投资模型，结合技术手段，你跟着买就好了。再比如，支付宝上的基金模块，选择排行榜，过去 3 年内收益最高的基金，选择一个定投，微信上也有类似的，都是一种傻瓜式的无脑定投操作。</p><p>好处就是，拿一笔钱定期投资，然后该干嘛干嘛去，不会花费自己任何精力，忽略这笔钱就好了。</p><p>说到定投，我再补充一点，如果市场处于上涨趋势中，定投其实不如一次性买入收益高的，但是因为你不懂市场如何走，定投是一种无脑佛系操作，所以成本是越来越高的，最后的收益也就没那么多。如果是一种下跌趋势，定投其实理论上来说是越来越赚的，因为你的成本越来越低，但是最难的在于坚持，尤其中国熊市比较久，很长一段时间你的资金都是持续亏损，很多人难以承受，最后没能熬到牛市。最好的情况是，市场处于横盘的时候，定期定投，用时间来换空间，熬到牛市，绝对是一笔不少的收益，所以，很多人选择在牛市定投，其实是错误的，最好的定投是在熊市，只要你战胜恐惧，熬到牛市一定能赚钱。</p><p>当下，其实我觉得就是熊市，A 股已经处于下跌趋势中的底部，但要说是不是最底，这个没人预料，也别去预料，但只能说是一个总体风险没那么大的情况，定投最合适，只要你坚持定投，拿到牛市，收益绝对不小。很多，其实很早就开始定投的，这个时候建议不要放弃，不然太可惜了。我之所以在这个时候给大家普及投资理财知识，主要原因其实就是我认为现在总体风险不那么大，最多能有个 20% 的下跌空间了不起了，但是上面可以有 100% 甚至更大的机会，只要你能熬得住时间，只要你能战胜恐惧，只要你能坚定的执行策略。</p><p>接着，可能有人会问，那么定投啥时候开始止盈呢？</p><p>这其实取决于你自己。有的人以时间为限，比如选择一个标的，坚持定投 3 年，三年期结束再看，然后重新评估寻找新的标的。有的人以收益为限，比如有的人坚持定投，啥时候赚到 20% 的收益，啥时候收手。还有的人熊市定投，牛市止盈出来，那么如何判断牛市来了呢？这里交大家一个简单的技巧，当你的同学、同事在谈论股票，当你做地铁大家都在拿着手机看股市，甚至于打扫楼道的阿姨都在谈论股票的时候，就是时候止盈出来观望了。</p><p>以上，就是适合绝大部分人的一种策略，基金，也是大部分接触投资理财的一种方式，希望大家能够理解其本质，并且感兴趣的，用自己能承担的风险、制定合适的策略去执行，我希望在接下来的几年，大家都能赚钱，而只要坚定的执行策略、战胜恐惧，其实我觉的，赚钱挺容易的。</p><h3 id="考研建议"><a href="#考研建议" class="headerlink" title="考研建议"></a>考研建议</h3><p>有人问，现在经济不好，是不是去考个研，然后读研结束，再找工作行情是不是会好点呢？</p><p>相信会这么想的人很多，我也简单说下自己的看法吧。</p><p>这种决策就是典型的只重趋势，不重自我，考虑到趋势是对的，但是趋势有很多不确定性，比如这行情能持续多久没人知道，是一年还是五年呢？又比如，你怎么就知道自己找不到工作呢？</p><p>但是一些确定的，是在于自己身上，你可以选择让自己很努力，可以选择让自己持续学习，持续提升。把命运交给自己才是最重要的，做事情考虑趋势是对的，但是全部只考虑趋势，这就相当于不相信自己。</p><p>我这个人，一直认为命运是自己掌控的，这是我一直以来信奉的准则。</p><p>所以，我个人意见是，如果你想考研，而且本就打算去考了，也有很大把握去考，那就去考好了，如果你从没想过考研，对考研也很抵触，仅仅因为当下的行情想到了考研，这个我就不建议了，趋势差，只是对人才的要求更高了而已，并不是说不需要人才了，你为什么不能相信，靠着自己的努力，自己就是优秀的那批人呢？</p><p>总之一句话，考不考研还是按照你之前的规划以及之前我在星球说过的「先胜而后战」思维去决策，不必特别在意经济不好，但是焦虑感和压力是要有的，要让自己更努力，要想办法让自己成为优秀的那批人才。</p><h3 id="格局决定命运"><a href="#格局决定命运" class="headerlink" title="格局决定命运"></a>格局决定命运</h3><p>今天给大家讲几个我身边的人的故事，都是我这些年经历的真实的事。</p><p>第一个是我的父母，我的父母是农村人，没任何文化，他们那一代很穷苦，物质也匮乏，很多东西都是靠省吃俭用来养活我跟我弟弟，省吃俭用也一直是他们一辈子的宗旨，也是咱们中国提倡的美德。我来上海工作后的前几年，我几乎每年都换部手机，每次回家老爸老妈都教训我不要买些没用的，要攒钱为以后买房做准备，攒钱买房几乎是每次回家、每次打电话，都必须要说的一件事。一直到前两年，我有小孩了，把爸妈接来帮忙照顾，一开始的生活习惯完全没法相处，我家里很多台电脑、很多部手机，每周都要出去娱乐、下馆子，我爸妈超级不高兴，甚至对我媳妇也有意见，因为他们觉得我们在浪费钱，像我们这种啥时候才能买房。</p><p>直到有一次，我觉得再这样下去媳妇要崩溃了，然后很严肃的跟我爸妈沟通，钱是挣出来的，不是攒出来的，想要买房一定不是靠攒钱才能买得起的，上海的房价几百万，难道就靠每月多攒那几百块来买房么？省吃俭用在你们那个时代是非常宝贵的美德，但是时代不一样了，不能一味的为了省而省，该花的钱那是必须得花的。</p><p>虽然当时口头上老爸老妈觉得我说的有道理，但是心里一直还是没法接受，毕竟省吃俭用是他们骨子里的观念，没法改变，但是好在收敛些了。</p><p>这个应该不是个例，我相信每位父母差不多都如此，这就是格局不一样，我自认我格局比我爸妈要高的多，父母那个时代，钱真的就是省出来的，但是这个时代，钱是挣出来的，很庆幸我很早就有这个觉悟，后来的事你们知道了。</p><p>第二个件事，很多人都知道，我一直在强调投资的重要性，其实我投资方面的经验至少得有 3、4 年了吧，而且我在投资方面的总体确实赚到钱了，不仅以前，之后我相信我的投资技能，也会让我的财富增值的。但是你们知道我是怎么开始学习投资的么？是我认识一位朋友，当时我在业界算是有一点影响力了吧，他是做金融投资方面的，他最开始建议我学点投资理财，我当时还觉得我一程序员，又不是你金融领域的，让我学投资理财简直莫名其妙，我又没让你学编程，你干嘛让我学投资？而且我打心里确实觉得，我这种穷人要毛投资理财，投资理财不是有钱人才去做的么？所以我回复的理由是，我现在又没钱，不需要学。但是他当即给我说了一句话，改变了我的观念，他说：你以后会有钱的，而且一定是。</p><p>这句话让我很震惊，因为再次之前我从未想过我以后会有钱，我一直想着先让自己和家里人吃好喝好就不错了，他这句话警醒我了，我的格局实在太小了，我的眼里只盯着眼下的那点事，做好当下的事是没错，但是眼里只有当下的事，那就有问题了，这个朋友的这句话，对我之后有很大影响。</p><p>后来我影响力越来越大，中间有过各种事情，有人要高薪聘请我去给他们的技术公号写文章，还有人要收购我的公众号，有平台请我去录制课程的，还有培训机构去请我当老师的，给开的薪资其实在现在的我来看没啥吸引力，但在当时来看，非常有诱惑。但是后面我格局提升了，全都拒绝了，我不是想赚一时的快钱，我是把它当做事业来看的，以上的种种诱惑如果我当时格局不够，很可能都不会有现在的我，我很感激我这个朋友，这个朋友一直到现在都时长在联系，他的格局我自认比我要大的多，我受到他的影响非常大。</p><p>格局是什么？</p><p>之前有很多球友问过一堆类似的问题，其实只要你格局够大，一些问题直接就有了答案。</p><p>买啥电脑好？直接在你能接受的情况下买最好的，因为电脑是你吃饭的家伙，你吃饭的家伙如果都能凑合，我不认为你的工作能做的多出色。</p><p>因为种种原因欠了几万块，或者被骗了几万块，就要死要活的。你这一辈子就只值那几万块么？几万块在你当下觉得是一笔巨款了，但是在未来的你手上，只不过是九牛一毛而已。</p><p>现在北京、上海房价这么高？以后不可能买得起，所以我就回老家工作算了。当你这么想的时候，那么你永远不会有大的成就，因为你格局摆在这。</p><p>其实仇富心理，本质上也就是格局的问题，格局小的人，看到别人用一些高档用品，就觉得是在炫耀，其实那不过是他们的正常生活而已，而到了格局小的人眼里，就变成了炫耀。就好比我上次买房在公号发了篇文章，评论区有人说，不就买个房么？有啥好炫耀的？在格局小的人眼里，你做什么都会成为炫耀的。</p><p>我这些年，其实积累了不少人脉，有些人脉的积累，我想了下都归功于格局。</p><p>有很多人知道，我以前出车祸撞了一辆一百多万的奔驰 S 级，只不过你们不知道的是，这位车主车成了我的人脉，这位车主 5、6 十岁了，当时出车祸，他全责，但是在整个的处理过程中，我没人任何过分要求，都是规规矩矩在处理，整个沟通的过程中，也并没有因为是他的责任，我就很不客气。后来这车主见我很年轻，为人处世还不错，就加微信偶尔聊聊，后来才知道，这车主是一家公司的老总，只不过现在退休了，他经常看我朋友圈，也觉得我蛮有才华的，上次还邀请我去他的苏州豪宅喝茶，这个缘分我觉得非常不可思议。</p><p>今天上午说到 Fenng 的事，大家也都知道了，我被 Fenng 拉黑过，但是我并没有因此对他一生黑，因为我知道这么个道理，被比自己厉害的人怼，不是啥坏事，虽然那会我不认可 Fenng，但是我内心承认，Fenng 比我厉害的多，如果不敢于承认这个，是不会有之后的自己反思以及提升的，经过这么多年来的认知提升，才意识到以前的自己有多傻逼，后来为了跟 Fenng 认识，我在他公号连续打赏了多少次大额赞赏，终于有机会承认当年的错误，并且跟 Fenng 成为了朋友。</p><p>现在的我，也在不断提升自己的格局，因为我一直在认识新的比我厉害的朋友，每次跟他们的沟通交流中，我都会从他们身上学到一些东西，我发现凡是厉害的人，他们的格局都很大，从不会在意一时的得失，我一直相信一点，比你厉害的人，他们说的、做的虽然不一定都对，但是格局一定不会错。</p><p>当你做事的时候，不妨想想自己的格局，很多时候，格局决定命运。</p><h3 id="趋势的力量"><a href="#趋势的力量" class="headerlink" title="趋势的力量"></a>趋势的力量</h3><p>最近，很多球友的问题中，有不少人都说表示工作 6、7 年了才发现危机意识很严重，不知道具体如何走，还有不少在职业选择上很困惑的，还有不少高考、考研不知道怎么选专业的等等等，其实商业上有一条非常重要的原则很多人都不知道，那就是「顺势而为」，今天就跟大家好好谈谈趋势的力量。</p><p>很多人都知道我的经历，都知道我非常努力，非常拼命，但是我以前就说过，努力很重要，但是选择远大于努力。</p><p>要说努力的话，这世界上我想没人比农民更努力，我父母就是农民，我深知道他们的辛苦，风吹日晒，全年无休，那种毅力与吃苦能力我是自愧不如，但是到头来呢？一年下来根本挣不了俩钱，而且不止我父母，绝大部分农民是最贫穷的。</p><p>说到 IT 领域，固然我是很努力，但是我相信，各大城市，无数努力的小青年到处都是，如果努力一定可以成功，那就不会有那么多落寞的身影，绝大部分人输在了选择上。</p><p>很多人都知道，我一开始自学编程的时候，选择了移动开发，因为那时候的我受人点拨，意识到移动互联网是未来的趋势，自然移动开发以后就是香饽饽，虽然我是非科班，0 基础，但是我借助于趋势的力量，抹平了这个差距，所以，后面只自学了很短的时间，就很快找到了工作，并且之后凭着不懈的努力，混的风生水起。</p><p>在大家都开始写博客的时候，微信公众号来了，虽然我在整个微信生态不算早的，但是在技术圈我绝对属于第一批写微信公众号的人，当所有人在 csdn 写博客的时候，我开始在 GitHub Pages 写博客，所有人都开始搭建自己的博客时，我毫无以为追随微信公众号的趋势，之后凭借一路下来的兢兢业业，持续不断的输出，才有后来的积累。</p><p>知识星球大家都知道，现在我的星球在整个领域影响力都非常大，然而我又是把握住了知识付费的趋势。16 年底我就看到了知识付费的趋势，所以果断自己尝试，在 17 年知识付费元年到来的时候，更毫不犹豫的上车了，我清楚的记得，那会一堆人都忙着录制课程、写书，当然也有一大堆这样的人找我的，都被我拒绝了，我全新投入在了知识星球，大力拥抱知识付费。</p><p>所以，你回顾一整个过程，你就会发现，每一步我都能做的如此成功，是因为看到了趋势后，敢于全身心的去拥抱趋势，只不过我持续不断的努力，大部分人就认为我是单纯靠努力而取得的成就而已，其实在我自己看来，所有的努力都是建立在趋势的基础上，方向对了，你做事其实会越来越轻松，否则，你很努力，很累，但是并没有什么成功。</p><p>雷军说，站在风口，猪都能飞。本质上这个风口就是指趋势，而顺势而为，是商业上最重要的一条法则。</p><p>商业上有很多案例，都说明了趋势的重要性。</p><p>智能手机时代的到来，诺基亚不以为意，死守功能机，这么一个巨头在趋势面前，一样不堪一击。移动支付的到来，银联的业务不知道受到多少冲击。很多时候，打败你的可能不是你的竞争对手，而是趋势，比如手机的普及，手游的火爆，对多少网吧造成了冲击。</p><p>说到网吧，有一个真实的案例，是网鱼网咖的老板跟我老板亲口讲述的。网鱼网咖大家都知道，就是一家相对高端点的网吧，这两年业务惨淡，因为被王者荣耀冲击太狠，以前都去网吧玩游戏，但是现在都用手机玩了。业务下降严重，不能坐以待毙啊，所以内部开会想着解决方案，有各种策略就提出来，什么降价啊，会员力度更强啊之类的，但是最后他们定了一条，手游是趋势，他们不能逆势而为，所以开辟了手游专区，就是用手机玩游戏的专区，虽然大部分人都有手机，但是大部分去网吧玩游戏是追求的一个氛围与环境，所以他们判断，与其被冲击，不如就顺势而为。所以现在你们去网鱼网咖，应该都可以看到手游专区，手游专区开辟之后，业绩大增，这真是一个趋势最现实的案例。</p><p>现在几乎每个公司，每位管理者都异常的关注趋势，商业上是，但其实在人生的选择上，趋势同样具备很大的指导作用。</p><p>你现在如果 0 基础学编程，还学习什么 C++、php，既然本来你就有很大劣势了，为什么不放手一搏，选择最新趋势的？如小程序开发、如 Python。马上都要人工智能时代了，你现在报考专业还选择翻译，那未来只会后悔。</p><p>选择有多重要，只有过来人才会清楚。</p><p>我一直给大家说，要活在当下，面对未来。很多人不以为意，尤其是在当下优势越大的人，越容易对趋势不以为意，我也一再告诉大家，要有开放的心态，不管你现在的领域多么成功，优势多大，一定要眼界开阔，多关注当下的趋势变化，但是如果你只守着自己的一点土地，很可能不会败给别人，而败给趋势。</p><p>有人问，如何判断趋势呢？</p><p>趋势这玩意不是百分百确定的，如果可以有一种方法论，可以百分百确定趋势，那这世界上全都是成功的企业，以及成功的个人了。但是总有一些方法可以帮助你判断，很多球友都知道，我对信息很敏感，而对信息很敏感的目的就在于帮助自己判断趋势，我还有一种能力，就是感知细微变化的能力，我善于观察，一旦有什么变化，我都会思考，这种变化可能会带来哪些连锁反应，我敢于预判，虽然，有些时候不一定正确，但是长此以往，在看待问题的方式以及趋势判断上，准确度会更高。</p><p>最后，我个人还有一个方法，也介绍给大家，当你在某一领域内有很大竞争力的时候，在趋势来临之前，可以保守点去跟进趋势。但是当你在某一领域毫无优势而言，甚至 0 积累的时候，在趋势来临的时候，这种情况下，为什么不大胆的去下注趋势呢？</p><p>比如你要转行，你现在在行业内工作也没多久，也没多少积累，这个时候判断一个新的方向有前途，要转行的话那就完全可以下重注，反正在这个行业你也没啥优势。但是如果你已经在这个行业工作了好多年了，有一定的积累了，这个时候转行可以不用那么极端，业余时间先学着，等觉得学的可以，时机成熟的情况下再转行不迟。我做事情一直秉承着这个原则。</p><p>顺势而为，现在是商业上最最重要的一条原则，也告诫每一个人，不能只顾埋头眼下的工作，千万不要忽略趋势的力量。</p><h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p> 提问: 张哥，一直看到你在星球里推荐python，但是python入门很容易，尤其是对于学过java的人来说，也就是说技术壁垒并不高，而且目前学的人还多。</p><p>另外如果单单是后端开发的话大厂用python的并不多，只会python而能进入大厂的机会并不如java多。那么python对于不搞人工智能方向的程序员来说竞争力在哪里？求张哥解惑。</p><p>你搞错了一个因果关系，能进大厂的人，绝不是因为学了 Java 就进了大厂，那是因为自身实力问题，你让这样的人学 Python 一样可以进大厂。</p><p>所以，编程语言只是一门工具，它不代表你的能力，只代表你选择的方向，而方向的选择没有绝对的对和错，我之所以推荐大家现在学 Python，因为 Python 的应用很广，未来人工智能时代也是很有建树的，意味着如果你是 0 基础，选择 Python，未来比 Java 选择面要光，但不代表你选择了 Python 就一定比选择了 Java 的人更牛逼，牛不牛逼，取决于你个人，包括努力程度、悟性、执行力等等。</p><h3 id="你该好好经营自己的朋友圈了！"><a href="#你该好好经营自己的朋友圈了！" class="headerlink" title="你该好好经营自己的朋友圈了！"></a>你该好好经营自己的朋友圈了！</h3><p>朋友圈，大家都不陌生，都说朋友圈没落了，但是从每年的数据来看，朋友圈活跃用户仍然是各大社交平台第一名，也就是说，不管你喜不喜欢朋友圈，有很大一部分人都在每天刷朋友圈，但是，很多人都忽略了朋友圈的妙用。</p><p>互联网时代，不再像以往大家走门串巷，让大家相互了解，现在大都比较宅，在网上活跃度是最高的，但是让你的同学、朋友、导师、领导、老板了解你是很必要的，我给大家举个例子你们就知道了。</p><p>假如你加入了一家公司，老板不太可能一天到晚关注到你一个小角色，除了你的直接领导，可以整个公司都对你不是很了解，但是其他同事不了解你没多大关系，让老板了解你，这事关你是否有更好的机会。有人说了，我这人比较内向，不想让老板更多的了解我，我想保持神秘，我敢这么说一句，没有任何一家公司的老板，想让自己的员工如此神秘的？</p><p>而一旦你加了你老板的微信好友，对于中小公司来说，这个是很正常的，你的朋友圈可能是你老板唯一了解你的方式，你在公司取得了什么成就，你有多努力，你对一些业务或者产品有什么看法，这些都可以在朋友圈中进行表达，让你的老板、领导看到，你是个有想法，踏实、努力的人。</p><p>真的，从我接触过的一些不同层次的人群来说，反而是越高级别的人，越爱发朋友圈。比如投资人投资了什么好的项目，他要发朋友圈，向圈内人证明自己的投资能力，比如有的创业公司老板，公司取得了什么成绩与进展，发个朋友圈炫耀下，让一些潜在投资人关注到，比如你加班到很晚，解决了一个很难搞定的问题，事后不经意间发条朋友圈，你的领导就会觉得你是个靠谱、有责任心的人，说不定就因此升值加薪了。</p><p>我以上举的例子，真不是随意瞎编的，就是确确实实存在的现象，包括我，你们知道，经常发朋友圈，取得了什么牛逼的事了，发条朋友圈炫耀下，让不少大佬们认识下我，有什么想法与感悟，发个朋友圈，让别人知道我是个有想法，有深度思考能力的人。我以前就说过，这个时代，如果你有能力，就大胆表现，想办法让别人知道，如果你很有能力，但是没人知道，然后抱怨怀才不遇，我得告诉你，这就是你的问题，你的能力让别人知道，本身就是一种能力。</p><p>当然了，我说的是要借用朋友圈更多的展示自己的能力，但不是要让大家夸大、欺骗，靠着心机的欺骗早晚得露馅的。</p><p>我之前还特地给球友们一个福利，就是我的朋友圈可以任意转发，甚至允许大家都不用注明出处，这真是个大福利。你们知道么，有球友给我反馈说，转过我的朋友圈，被老板看到了，老板特地给他留言讨论，还有的球友说，自己经常转我朋友圈，被他导师看到了，夸奖他很有见地，类似的例子真的不要太多，我想表达的是，很多时候，你想让别人认可你，知道你有能力，你总得向他们证明吧，而朋友圈就是一个不错的路径。</p><p>我很早就跟大家说过写作的重要性，写作是一个长期积累的过程，在未来又是一个很重要的能力，有人问过我，说从什么开始，开了公众号不知道写什么，其实，我想告诉大家，写作是随时随地的，发朋友圈也可以是写作，你连一个几十个字的朋友圈都懒得发，你说你要坚持写作，谁信呢？</p><p>朋友圈，真的很重要，他是一个个人名片，你很努力的加班，你对产品有一些见地，你收到大佬们的认可，你取得了了不起的成就，你就该让别人知道，别以为是不是有点装逼，有点炫耀，自己真实的事情，装逼又何妨？如果不能好好的装逼，我们为什么要这么努力？</p><p>你真该好好经营自己的朋友圈了，就现在，相信我，你很可能会因此得到更多的机会。</p><h3 id="互联网带给普通人的机会"><a href="#互联网带给普通人的机会" class="headerlink" title="互联网带给普通人的机会"></a>互联网带给普通人的机会</h3><p>我们都知道这几年互联网的普及，给我们的生活带来了很大的便利，但与此同时，互联网其实也给我们普通人带来了很大的机会，这些机会，绝大部分人都没注意到。</p><p>我们知道，在没网络的时代，人们是通过报纸、广播获取信息，而这些报纸、广播上的信息其实都是单一渠道的声音，也就意味着获取到的都是官媒的信息，再往深了讲，获取到的是官媒想要普通人获取的信息，所以老一辈思想比较顽固，对官媒深信不疑。再之后，有了电视，各种电视台的出现，丰富了人民的娱乐生活，大家可以看春晚、看电视剧甚至看电影，所以，本质上从电视时代，人们开始追星，大家在电视上看到的主持人、演员就是大家眼中的明星，最简单的例子就是，春晚时代的崔永元、赵本山就是那个时代最大的明星，那火爆程度那个时代的人是亲身经历的。</p><p>但是你仔细想下，有些人之所以是明星，是因为那个时代通过电视这种媒介来传递的，直到后面电视的普及，明星身价越来越高，因为全中国看你节目的人，看你电影的人越来越多，自然明星越来越大牌，身价越来越高。</p><p>但是随着网络的普及，传递信息越来越快，看到的信息也越来越多元化，所以网络时代，人们的思想相对以往是更开放的，但同时信息也更复杂，所以我之前说过，网络普及如此发达的时代，信息的筛选与辨别是一项基本能力，随着你的认知越高，你的这个能力越来越强。这不是重点，重点我想强调的是，人们通过网络可以很方便的连接所有人，我知道你，了解你，再也不像以前只能通过电视才能连接。</p><p>举个例子，微博的出现，所有人通过微博这种介质了解你，围观你，你的微博粉丝越多，知道你的人越多，你的价值也越大，本质上，微博粉丝很高的，就是这个时代的明星，而这个时代的明星绝不向以往有电视、电影作品的才有明星，这个时代哪怕你不是演员，但是微博粉丝几百、几千万，也是明星，只不过我们习惯把他称为草根明星。</p><p>所以，互联网的本质是连接，它让人跟人之间很方便的连接起来，愿意连接你的人越多，你的知名度越高，知名度越高，你就是所谓的明星，我们习惯称为流量越大，你的商业价值越大。</p><p>流量这个词是互联网时代才有的，但其实你仔细想想，电视时代，春晚就是最大的流量获取渠道，所以赵本山的流量几乎占领了全中国。而这个时代，获取流量的介质就很多了，都说阶级固化很难改变，但其实要我说，互联网时代，恰恰是给无数草根逆袭的机会。</p><p>这样的例子应该数不胜数，微博时代，多少草根微博大 V 崛起，直播时代，多少草根靠着直播走红，公众号时代，多少文字工作者迎来了最好的时代。之前有传闻称快手第一直播 MC 天佑参加某节目出场费超过了刘德华，很多人觉得不可思议，要我说，完全有可能，因为流量越大的人，商业价值也越大，所以，现在很多电影，都喜欢请一些流量小生去拍，即使没演技，即使身价高的要死，也要请去演，其实适合符合商业策略的，因为流量小生覆盖的数量更大，号召力也更强，自然身价也更高的。</p><p>所以我一直认为互联网是我们当下最好的时代，普通人最有可能通过互联网来逆袭的时代，如果在以前，根本不可能。</p><p>之前我还说过这样一个逻辑，如果你有一个本事，一个绝活，你给老板打工，只发挥一份价值而已，但是如果可以通过互联网，让你的这个本事，这个绝活造福更多的人，你创造的价值与回报远不止于此。</p><p>拿游戏主播举例，很多职业玩家，以前其实很苦逼的，就那点工资，但是直播时代到来，很多有商业头脑的早就第一时间转去做直播了，如果本身有一点名气，或者有点成就，那赚钱真是太容易了，比如 LOL 的若风，比如 dota 的 09，他们直播赚的钱远比以往拿冠军赚的都要多的多。</p><p>有人问了，他们本就是世界冠军，不是普通人。然而有不少普通人通过直播混的依然不错的，很多草根选手，靠着自己玩的可以，虽然称不上顶尖，但是有自己的特点，要么幽默，要么操作犀利，完全可以活的很好，但是这类人，再以往时代，过的非常辛苦。</p><p>再比如，陈一发、冯提莫靠着网络走红，现在出场费已经不输一线歌手，这类人虽然都有自己的绝活，唱歌确实不错，但是告诉你们的是，在中国论颜值、论唱功不输他们的一大堆，但是很多人就被埋没了，少部分由商业头脑的抓住了新的机会，直接逆袭。</p><p>公众号领域我就更不用举例了，我自己就非常感谢网络带给我的回报，这个领域孕育出一堆草根牛人更不用提了。</p><p>所以，我想说的是，作为普通人的我们，先让自己有一个优势，也就是所谓的绝活，如果你有一个绝活，要想办法让通过这个绝活让更多人知道你，这样你才能创造比打工翻多少倍的价值，微博、知乎、直播、公众号、抖音、快手等都是类比于以往电视的平台，对机会敏感的人会成为上面的创作者与生产者，进而通过这样的渠道提升自己的影响力，连接更多人，对机会不敏感的人，只会成为围观者与消费者，成为那一批整天刷微博、抖音的普通用户而已。</p><p>类似的机会现在有，以后一定还会有，而且互联网还会越来越发达，希望这篇文章能够认清互联网背后带来商业价值的底层逻辑，这样以后有新的机会要敢于尝试，敢于拥抱新事物，另外，即使你看到了机会，想要做成也从不是轻轻松松的，一些主播比谁都勤奋，一些公众号分享者比谁都努力，努力永远是必要条件。</p><h3 id="转行"><a href="#转行" class="headerlink" title="转行"></a>转行</h3><p>大家好。</p><p>今天刚刚办完离职手续，结束了在当前这个公司的实习。趁热总结一下，顺便填一下昨天挖的坑。</p><p>首先还是先自我介绍一下，我是一名学生，浙大研二在读，专业传统工科，转行算法。两段实习经历，n 次面试经历。这里总结一下实习及面试经历。我会写的非常细，如果不太需要这种分享的同学，希望不要继续看下去了，抓紧时间去看看对自己有用的分享。</p><p>我会从时间顺序按面试，在职和离职三个方面来进行总结分享。如果大家在看的过程中对有的地方不太赞同，或者认为我想法有错的地方，欢迎指出，我这个人还是很喜欢别人批评我的。毕竟学生时代，试错成本那么低，多从错误中吸取经验教训一直是我非常喜欢做的。好了，废话不多说，开始吧！</p><ol start="0"><li>写在前面：为什么要去实习？</li></ol><p>从我个人的角度出发，我是传统工科转行算法，硕士期间的目标非常明确，就是毕业之前找到一份目标行业目标方向的工作。而实习，则是为自己找工作增添砝码的有效途径。</p><p>同时，我个人执行力不是很强，虽然实验室放养，可是在实验室的大部分时间都在水，学习效率很低。实习的氛围及任务的 push 效果能够让我专注学习，同时也有项目实践的机会，不仅能够锻炼自己的能力，提高学习效率，还能为自己的简历增色，可以说性价比非常高了。</p><p>想通这一点之后，我从17年3月份左右开始持续地找实习。并且确实在面试及实习中学到了不少东西，下面和大家一一分享。</p><ol><li>面试</li></ol><p>1.1 面试前</p><p>其实面试前没什么需要特别准备的，把简历上的内容尽量熟悉就行了，因为面试官基本上是全程围绕你的简历在问，如果你连自己简历上的内容都不熟悉的话，那么一首 《凉凉》 可以送给你了。</p><p>1.2 面试中</p><p>这里说一下心态问题。相信很多人在面试的时候都会紧张，我总结了一个方法，可以有效缓解这种紧张。想象一下，如果面试你的人是你的室友，或者你的好朋友，你还会紧张吗？</p><p>其实面试官也是和我们一样的普通人，如果你面试成功之后，往后的几个月里，你会和面试官一起工作，一起吃饭，一起玩耍，勾肩搭背成为好朋友也不是不可能。所以不要把面试官想象地太可怕，端正态度，把面试官看做自己未来的好朋友，和好朋友交流交流技术问题而已，没什么可紧张的。</p><p>面试不仅仅是对我们知识的考察，也是我们和这个方向的资深人士学习的大好机会。所以，一定要把握好面试结束环节的提问环节，技术问题也好，择业问题也好，都可以问。问的好了甚至可以成为加分项！</p><p>我一般把面试当做和面试官的探讨，他问的问题我会尽力回答，然后会适当抛出一些问题一起探讨，我很喜欢这种面试氛围，而且实践证明，和面试官聊 high 了拿到 offer 的概率非常高！</p><p>1.3 面试后</p><p>面试后最重要的就是面试总结了。面试总结不是记录一下面试官问了什么问题，自己答得怎么样，而是这次面试暴露了自己的哪些不足，后续应该如何改进。我去年暑假去面网易，面试真的非常惨，不过这次面试也让我意识到了自己的不足，后续针对性地学习让我进步很大。</p><p>所以我建议有条件的同学可以多多面试，不要思想上给自己设限，认为自己能力还不够，面不上。只有去面试了，才知道自己哪些能力不够，才能针对性地改进。特别是转行的同学，想知道目标岗位需要什么技能，看一百篇 JD(职位描述) 都不如直接去问面试官和 HR 。</p><ol start="2"><li>在职</li></ol><p>这一块，我也谈不上经验分享，因为我工作的时间太短，而且我实习期间很多点也没做好。所以和大家说一下我做好的点以及犯过的错误吧。</p><p>2.1 主动</p><p>所谓主动，就是在有问题的时候主动找 leader 沟通。有问题一定要及时发问，及时沟通，不要不好意思，没人会取笑你的。</p><p>这一点我做的不太好，有时会做一些想当然的事情。有次有问题没有问 leader ，就想当然地去写代码，导致代码上线后发生错误；还有一次把公司 github 仓库搞挂了…… </p><p>另外，主动还包括人际交往的主动。在刚到一家公司，人生地不熟时，主动地接近同事，会帮助你迅速融入新的工作环境。</p><p>2.2 机会</p><p>实习时尽可能抓住任何能够锻炼自己的机会。</p><p>刚入职最近实习的这家公司时，有个做 presentation 的机会，我申请到了这个机会 。后来证明，我为了这次 presentation 做的准备，学到的知识，在后面的各个面试中，都给了我很大的帮助。</p><p>除此之外，无论是 presentation 也好，项目也好，只要有机会，就尽可能地利用这些去锻炼自己。不仅是实习，相信工作中也是如此。希望以后在工作中也能坚持这样的想法，不断进步。</p><p>2.3 从错误中学习</p><p>实习生犯错是一件很常见的事，在同事或 leader 指出你的错误，甚至指责你时，只要不是触碰底线地那种指责（比如人身攻击，谩骂），我都认为这是一件学习的大好机会。不要急着伤心难过和自我怀疑，记下自己犯的错误，以后多加注意，一个更好的自己诞生了！</p><ol start="3"><li>离职</li></ol><p>其实离职是一件有点尴尬的事情，特别是因为离职是因为找到了下一份实习。和 leader 和同事说的时候，总会有点不好意思。最后思考再三，我还是实话实说了。毕竟好聚好散。最后他们也都比较支持我，祝福我。所以，能实话实说就实话实说，又不是什么对不起公司的事，没什么好隐瞒的，做自己认为正确的事就行了。</p><p>离职也是一件有点悲伤的事。和一群人在一起工作了将近半年，还是很舍不得的。对于那些帮助过你的同事，当面也好，微信也好，一定要进行感谢。懂得感恩的人，才是值得相交的人。</p><p>好了，前前后后写了两个小时。在写的过程中，再次感觉到了自己表达能力的不足。有很多话都没写出来，因为没有足够的组织能力和逻辑能力将它们正确地表述出来。各位看官能看到现在也是真爱了，送你们一个么么哒</p><p>非常欢迎各位在评论区一起讨论，更欢迎指正和批评！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;电动汽车可能会是未来的一场革命&quot;&gt;&lt;a href=&quot;#电动汽车可能会是未来的一场革命&quot; class=&quot;headerlink&quot; title=&quot;电动汽车可能会是未来的一场革命&quot;&gt;&lt;/a&gt;电动汽车可能会是未来的一场革命&lt;/h3&gt;&lt;p&gt;球友们都知道，我相对比较关注趋势，因
      
    
    </summary>
    
      <category term="知识星球" scheme="https://www.daihuiyou.top/categories/%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/"/>
    
    
      <category term="StromZhang" scheme="https://www.daihuiyou.top/tags/StromZhang/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="https://www.daihuiyou.top/2018/11/01/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://www.daihuiyou.top/2018/11/01/数据库/</id>
    <published>2018-11-01T00:47:08.000Z</published>
    <updated>2018-11-09T06:13:57.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p><strong>数据库</strong>是一个以某种有组织的方式存储的数据集合. </p><p>表是一种结构化的文件, 可用来存储某种特定类型的数据.</p><p><strong>表</strong>:某种特定类型数据的结构化清单．</p><p><strong>模式</strong>：关于数据库和表的布局及特定的信息. </p><p>表由列组成. 列中存储着表中某部分的信息. </p><p><strong>列</strong>: 表中的一个字段. 所有表都是由一个或多个列组成的. </p><p>数据库中每个列都有相应的数据类型.数据类型定义列可以存储的数据种类.</p><p>表中数据都是按行存储的, 所保存的每个记录存储在自己行内. </p><p><strong>行</strong>：表中的一个记录.  记录和行互相代替. </p><p><strong>主键</strong>：一列(或一组列), 其值能够唯一区分表中每个行. </p><p>唯一标识表中的每行的这个列称为主键. </p><p><strong>SQL</strong>: 是结构化查询语言的缩写.</p><p>客户机-服务器应用分为两个不同的部分, 服务器部分是负责所有数据访问和处理的一个软件. 这个软件运行在称为数据服务其的计算机上. </p><p>与数据文件打交道的只有服务器软件. 关于数据, 数据添加, 删除和数据更新的所有请求都由服务器软件完成.这些请求或更改来自运行客户机软件的计算机. <strong>客户机</strong>是与用户打交道的软件.</p><p>​    <strong>客户机和如软件可能安装在两台计算机或一个计算机上. 不管他们在不在相同的计算机上, 为进行所有数据库交互, 客户机软件都要与服务器软件进行通信. </strong></p><p>​    所有这些活动对用户都是透明的. 数据存储在别的地方, 或者数据库服务器为你完成这个处理这一事实是隐藏的. 你不需要直接访问数据文件. 事实上, 多数网络的建立使用户不具有对数据的访问权, 甚至不具有对存储数据的驱动去的驱动器的访问权. </p><ul><li>服务器软件为MySQL DBMS. 你可以在本地安装的副本上运行, 也可以连接到运行在你具有访问权的远程服务期上的一个副本. </li><li>客户机可以是MySQL提供的工具, 脚本语言, web应用开发语言, 程序设计语言. </li></ul><p><strong>熟悉MySQL命令行实用程序,</strong></p><h3 id="数据库的基本概念："><a href="#数据库的基本概念：" class="headerlink" title="数据库的基本概念："></a>数据库的基本概念：</h3><p> 列/字段/属性/数据项（column/field/attribute/data item）</p><p>行/元组/记录（row/tuple/record）</p><p>关系模式： 表名 +表标题（格式）</p><p>表／关系：表名＋表标题（格式）＋表内容（值）</p><p>DataBase：相互之间有关联关系的Table的集合。</p><p>数据库： DB</p><p>数据库管理系统：DBMS</p><p>数据库应用：DBAP</p><p> 数据库管理员：DBA</p><p>DBMS提供了一套数据控制语言（DCL）给用户，DBA-&gt;DCL-&gt;DBMS</p><p>数据操作语言：DML，提供给用户，以便给用户对数据进行操作</p><p>数据控制语言：DCL，用户使用DCL；定义对不同操作的约束，对不同操作者的约束。</p><p>数据定义语言：DDL, 定义表名，表标题，列名其结构形式</p><p>SQL语言： DML, DCL, DDL， 结构化的数据库语言</p><p><strong>数据库语言与高级语言的区别：</strong></p><p>​    一条数据库语言相当于高级语言的一个或多个循环程序。 </p><p>数据模型——模式——数据</p><p>模式：外模式（子模式），概念模式（全局模式，逻辑模式），内模式（存储模式，物理模式）</p><p>E-C映像 ， C-I映像</p><p>三级模式两层映像：实现了逻辑独立性和物理独立性， 数据和应用程序的独立性</p><p>数据模型：</p><ul><li>关系模型</li><li>层次模型</li><li>网状模型</li></ul><p>关系模型的三个要素：</p><ol><li>基本结构</li><li>基本操作</li><li>完整性约束：实体完整性，参照完整性和用户自定义完整性</li></ol><p>关系运算：关系代数和关系演算；关系演算：元组演算和域演算</p><p>关系代数：基于集合的运算，即操作的对象和结果都是集合，是一次一集合的操作。而非关系型的数据操作通常是一次一记录的操作</p><p>“列“的取值范围“称为 ”域（Domain）”</p><p>笛卡尔积的每个元素（d1, d2,…..)称为一个n-元组</p><p>元组的每个值叫做一个分量。</p><p>笛卡尔积中具有某一方面意义的那些元组被称作一个关系。</p><p>关系模式和关系：关系模式是关系的结构，关系是关系模式在某一时刻的数据。</p><p>关系是笛卡尔积的子集。</p><p>列名（属性名）</p><p>列值（来自域）</p><p>关系的特性：</p><ol><li>列位置的互换性：区分哪一列是靠列名</li><li>行位置的互换性：区分哪一行是靠某一或某几列的值</li><li>关系是以内容来区的</li><li>属性不可再分特性：又被称为关系第一范式</li></ol><p>关系的任意两个元组不能完全相同。</p><p>Table：可能有重复的元组存在。</p><p>关系和Table（表） 大部分相同。</p><p>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组总去掉任何一个属性，它就不具有这一性质了，这样的属性称作候选码。</p><p>当有多个候选码，可以选定一个作为主码。</p><p>DBMS以主码为主要线索管理关系中的各个元组。</p><p>主属性：包含在任何一个候选码的属性被称作主属性</p><p>外码/外键：两个关系通常是靠外码连接起来的。</p><p>关系模型中的完整性：</p><ol><li>实体完整性：关系的主码的属性值不能为空</li><li>参照完整性：相对于外码</li><li>用户自定义完整性：用户针对具体的应用环境定义的完整性的约束条件。</li></ol><h3 id="关系代数基本操作："><a href="#关系代数基本操作：" class="headerlink" title="关系代数基本操作："></a>关系代数基本操作：</h3><p>并相容性</p><p>并</p><p>差</p><p>广义笛卡尔积</p><p>选择操作</p><p>投影操作</p><p>关系代数的基本书写思路：</p><ol><li>选出将用到的关系/表</li><li>做“积”运算</li><li>做悬着运算保留所需的行/元组</li><li>做投影运算保留所需的列/属性</li></ol><p>扩张操作</p><p>交运算</p><p>连接操作：在乘积操作的基础上，在做一个选择操作。</p><p>更名操作</p><p>等值连接</p><p>自然连接</p><p>除运算</p><p>关系代数  和 关系演算 </p><p>关系演算：元组演算和域演算</p><p>E-R关系图： 实体表示方框， 属性表示椭圆， 关系表示菱形。</p><p>抽象是理解，区分，命名，表达</p><p>实体， 属性，联系， 关键字（码）</p><p>属性：单一属性和复合属性</p><p>关键字/码，实体中能够用其值唯一区分每个实体的属性或属性组合。</p><p>参与发生联系的实体的数目，称为联系的度， 联系是多样化的。</p><p>实体在联系中的作用称为实体的角色</p><p>当同一实体的不同实例参与一个联系时，为区别各实例参与联系的方式，需要显示指明其角色。</p><p>实体之间的联系有很多种类。</p><p>完全参与联系</p><p>部分参与联系</p><p>不同层次的型与值</p><p>数据模型：概念 </p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p><img src="https://i.imgur.com/gvifg33.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SQL基本概念&quot;&gt;&lt;a href=&quot;#SQL基本概念&quot; class=&quot;headerlink&quot; title=&quot;SQL基本概念&quot;&gt;&lt;/a&gt;SQL基本概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据库&lt;/strong&gt;是一个以某种有组织的方式存储的数据集合. &lt;/p&gt;
&lt;p&gt;表
      
    
    </summary>
    
      <category term="计算机" scheme="https://www.daihuiyou.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="理论" scheme="https://www.daihuiyou.top/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>思维力</title>
    <link href="https://www.daihuiyou.top/2018/11/01/%E6%80%9D%E7%BB%B4%E5%8A%9B/"/>
    <id>https://www.daihuiyou.top/2018/11/01/思维力/</id>
    <published>2018-11-01T00:39:05.000Z</published>
    <updated>2018-11-09T06:10:12.527Z</updated>
    
    <content type="html"><![CDATA[<p>如何清楚的表达？</p><p>思维力：<br><img src="https://i.imgur.com/PlIE6Dk.png" alt=""></p><h3 id="阅读摘抄"><a href="#阅读摘抄" class="headerlink" title="阅读摘抄"></a>阅读摘抄</h3><p>思维力提升是当今时代的要求</p><p>知识积累方式变化下的必然要求</p><p>框架不仅仅体现了系统的构成元素，还体现了系统各构成元素的之间有机联系， 这种联系就是规律。</p><p><strong>系统思维是用框架来系统思考与表达的思维方式。</strong></p><p>系统反应了人们对事物的一种认识论： 系统是由两个或两个以上的元素结合而成的有机整体，而且系统的整体不等于其局部的简单相加–不仅要靠考虑系统的构成元素，更要考虑元素之间的联系。</p><p>系统思维就是以系统论为基本模式的思维形态， 它的客观一句是事物存在的普遍方式和属性。 </p><p>框架是系统思维的核心组成部分。 </p><p>以假设为前提，以事实为基础的工作方法。</p><p>世间万物的本质其实是系统，而框架就是对系统构成元素一级元素间有机联系的简化体现。因此人类大脑的在处理信息时本能地想将其组合为能够被认知的框架，以反应对事物的理解。</p><p>因此，系统思维在表达上应用的核心就是强调要采用自上而下表达的形式，第一时间传递容易认知的框架给受众，从而使受众更轻松，更有效接受你所传递的信息。</p><p>系统思维弥补经验上的不足，加速经验积累。</p><p>运用框架解决问题和加速经验的积累。</p><p>系统思维提高学习效率，加速知识积累。</p><p>我构建了个人的知识体系，我知道自己需要学习什么， 还缺少什么，因此每当我学习新的知识、经历新的事情时，我会不由自主的地了解的新的内容填充进我的知识框架里。随着我构建的知识体系越完整，越秘籍，就好像一张三维的渔网一样， 同一个姿势或同一段经历能够区填充的各自也就越来越多，知识积累的速度也就不停地加快。</p><p>麦肯锡结构化思维的内涵（定义）：分析问题的框架。</p><p>麦肯锡结构化思维的外延（应用范围）：框定假设的范围</p><h3 id="明确问题的构成要素"><a href="#明确问题的构成要素" class="headerlink" title="明确问题的构成要素"></a>明确问题的构成要素</h3><p>5 W 2 H 分析法， 又称 “七何”分析法</p><p>你可以在电话里运用框架跟他一次性确认所有关键要素。</p><ul><li>Why</li><li>What </li><li>When </li><li>Where</li><li>Who</li><li>How</li><li>How much</li></ul><p>其实很简单，这就是我要教给你的“探究问题本质”的第一种方法——5Why分析法。</p><p><strong>5Why分析法的关键：鼓励解决问题的人努力避开主观或自负的假设和逻辑陷阱，从结果着手，沿着因果关系链条，顺藤摸瓜，直至找出原有问题的根本原因。</strong></p><p>因此，我们抛给别人的问题或需求，或别人抛给我们的问题或需要，往往都不是问题本身，而是问题的初步解决方案。 因此，我们在工作、生活和学习中需要多多提醒自己区分清楚问题初步解决方案和问题的本身。</p><p>在现实的工作、生活和学习中，很多时候对方提出的问题都是经过他们初步加工后的解决方案，而非真正的问题。将问题的初步解决方案与问题本身混为一谈是最容易犯的错误之一，也是大量时间和精力浪费的根源之一。你需要找到真正的问题，而不是惯性地将初步解决方案当做问题本身来应对。</p><p>隐含时间的假设广泛存在于我们的工作、生活和学习中，我相信你听过很多隐含时间假设的论断，也可能因未能显性化问题隐含的时间假设而错过了不少机会。例如，领导给你布置一个相当有挑战性的任务时，你的第一反应是“这个工作需要很强的沟通能力，我的沟通能力不行，因此我不能接这个任务”，还是“这个工作需要很强的沟通能力，目前我的沟通能力不行，正好可以借这个任务锻炼提升”呢？若是前者，你不仅辜负了领导的信任，还丧失了一次提升沟通能力的机会。而后者既可以提升沟通能力，又能够得到领导的青睐，即使任务没圆满完成，你的沟通能力的提升也绝对比你不接受这个任务要高得多</p><h3 id="逻辑树是我们运用系统思维分析和解决问题的主要工具"><a href="#逻辑树是我们运用系统思维分析和解决问题的主要工具" class="headerlink" title="逻辑树是我们运用系统思维分析和解决问题的主要工具"></a>逻辑树是我们运用系统思维分析和解决问题的主要工具</h3><p>逻辑树是一种非常有效的问题/议题分解的方法，其价值主要有以下三点：<br>​    1.对问题/议题/假设层层有序分解，有助于理清思路，不做重复和无效的思考；<br>​    2.可有效分解复杂问题/议题，从而简化问题/议题的处理；<br>​    3.通过将问题/议题分解为更细的问题/议题，有助于团队的协作和分工</p><h3 id="80-20法则的作用"><a href="#80-20法则的作用" class="headerlink" title="80/20法则的作用"></a>80/20法则的作用</h3><p>一个人的时间和精力都是非常有限的，“做好每一件事”几乎不可能，因此必须学会合理分配的时间和精力。面面俱到不如重点突破，把80%的资源花在能出关键效应的20%的方面上，这20%的方面又能带动其余80%的发展。</p><h3 id="自上而下的表达"><a href="#自上而下的表达" class="headerlink" title="自上而下的表达"></a>自上而下的表达</h3><p>三点式表示</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何清楚的表达？&lt;/p&gt;
&lt;p&gt;思维力：&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/PlIE6Dk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;阅读摘抄&quot;&gt;&lt;a href=&quot;#阅读摘抄&quot; class=&quot;headerlink&quot; title=&quot;阅读
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="书籍" scheme="https://www.daihuiyou.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>C笔记</title>
    <link href="https://www.daihuiyou.top/2018/11/01/C%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.daihuiyou.top/2018/11/01/C笔记/</id>
    <published>2018-11-01T00:38:24.000Z</published>
    <updated>2018-11-09T06:14:16.147Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;string.h&gt;//sizeof(s) 是计算指针的大小， 大小为4//sizeof(a) 是计算字符串的大小，包括\0//strlen(a) 是计算字符串的大小，不包括\0//常用字符串复制//char *dst = (char *)malloc(strlen(str) + 1);//strcpy(dst, str);void main(int args, char const *argv[]){    char * s = &quot;aaaaaa&quot;;    char a[] = &quot;aaaaaa&quot;;    printf(&quot;%d\r\n&quot;, sizeof(a));    printf(&quot;%d\r\n&quot;, sizeof(s));    printf(&quot;%d\r\n&quot;, strlen(s));    printf(&quot;%d\r\n&quot;, strlen(a));    //7    //4    //6    //6    //请按任意键继续. . .    system(&quot;pause&quot;);}</code></pre><p> c的封装 </p><p>链表的删除 ： 删除链表其中一个结点</p><p>链表的清除： 删除链表所有的结点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
//sizeof(s) 是计算指针的大小， 大小为4
//sizeof(a) 是计算字符串的大小，包括\0
//strlen(a) 是
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="语言" scheme="https://www.daihuiyou.top/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="https://www.daihuiyou.top/2018/10/22/Java%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.daihuiyou.top/2018/10/22/Java笔记/</id>
    <published>2018-10-22T09:51:18.000Z</published>
    <updated>2018-11-09T06:08:53.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h3><p>== : 它的作用判断两个对象的地址是否相等, 判断基本数据类型的值是否相等.</p><p>equals: String 中的 equals() 方法是被重写的, 因为 Object 的 equals 方法是比较对象的内存地址.而 String 的 equals 方法是比较对象的值. </p><h3 id="线程-程序-进程的基本概念和他们之间关系"><a href="#线程-程序-进程的基本概念和他们之间关系" class="headerlink" title="线程, 程序, 进程的基本概念和他们之间关系"></a>线程, 程序, 进程的基本概念和他们之间关系</h3><p><strong>1.    线程</strong>和进程相似, 但线程是一个比进程更小的执行单位. 一个进程在其执行过程中可以产生多个线程. 与线程不同的是同类的多个线程共享同一个内存空间和一组系统资源, 所以系统产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因如此, 线程也被称称为轻量级进程. </p><p><strong>2.    程序</strong>是含有指令和数据的文件,  被存储在磁盘或者其他的数据存储设备中, 也就是说程序是静态的代码. </p><p><strong>3.     进程</strong>是程序一次运行过程, 是系统运行的基本单位, 因为进程是动态. 系统运行一个程序即是一个进程从创建, 运行到消亡的过程.简单来说, 一个进程就是一个执行中的程序, 它在计算机中的一个指令接着一个指令的执行, 同时, 每个进程还占某些系统资源如CPU时间, 内存空间, 文件, 输入输出设备的使用权等等. </p><p><strong>4.    换句话说</strong>, 当程序在执行时, 将会被操作系统载入内存中, 线程是进程划分成的更小的运行单位. 线程和进程最大不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响. 从另一角度出发, 进程属于操作系统的范畴, 主要是同一段时间内, 可以同时执行一个以上的程序, 而线程则是在同一个程序内几乎同时执行一个以上的程序段. </p><h3 id="线程的基本状态和基本状态的定义"><a href="#线程的基本状态和基本状态的定义" class="headerlink" title="线程的基本状态和基本状态的定义"></a>线程的基本状态和基本状态的定义</h3><ol><li><strong>新建（new)</strong>: 新创建了一个线程对象. </li><li><strong>可运行(runnable)</strong>:线程对象创建后, 其他线程(比如main线程)调用了该对象的 start() 方法. 该状态的线程位于可运行线程池中, 等待被线程调度选中, 获取CPU的使用权. </li><li><strong>运行(running)</strong>: 可运行(runnable)的线程获得了 CPU 时间片(time slice), 执行程序代码.</li><li><strong>阻塞(block)</strong>: 阻塞状态是指线程因为某种原因放了CPU的使用权, 也即让出了 CPU time slice. 暂时停止运行. 直到线程进入可运行的状态, 才有机会再次获得 CPU time slice 转到运行状态. <ol><li>阻塞的情况分三种:<ol><li>等待阻塞</li><li>同步阻塞</li><li>其他阻塞　</li></ol></li></ol></li><li><strong>死亡:</strong> 线程 run(), main()方法执行结束后, 或者因异常退出了run()方法, 则该线程接受了生命周期. 死亡的线程不可再次复生.</li></ol><h3 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><pre><code> Java 程序在执行子类的构造方法之前, 如果没有用super()来调用父类特定的构造方法, 则会调用父类中没有参数的构造方法. 因此父类中只定义了有参数的构造方法, 而在子类的构造方法中又没有的super()来调用父类中特定的构造方法, 则编译时将方法错误, 因为 Java 程序在父类中找不到没有参数的构造方法可执行. 解决方法是咋父类里加上一个不做事且没有参数的构造方法. </code></pre><h3 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别"></a>Java 和 C++的区别</h3><p>都是面向对象的语言， 都支持封装，继承和多态</p><p>Java 不提供指针来直接内存，程序内存更加安全</p><p>Java 的类是单继承的， C++支持多继承； 虽然 Java 的类不可以多继承， 但是接口可以多继承</p><p>Java 有自动内存管理机制， 不需要程序员手动释放无用内存</p><h3 id="接口和抽象类的区别："><a href="#接口和抽象类的区别：" class="headerlink" title="接口和抽象类的区别："></a>接口和抽象类的区别：</h3><ol><li>接口的方法默认是 public， 所有方法在接口中不能有实现，抽象类可有非抽象的方法</li><li>接口中实例变量默认是 final 类型， 而抽象类中则不一定</li><li>一个类可以实现多个接口， 但最多只能实现一个抽象类</li><li>一个类实现接口的话， 要实现接口的所有方法， 而抽象类不一定。</li><li>接口不能用 new 实例化， 但可以声明， 必须应用一个实现该接口的的对象</li><li>从设计层面来说， 抽象是对类的抽象，是一种模板设计； 接口是行为的抽象， 是一种行为的规范。</li></ol><h3 id="静态方法和实例方法"><a href="#静态方法和实例方法" class="headerlink" title="静态方法和实例方法"></a>静态方法和实例方法</h3><ol><li>在外部调用静态方法，可以使用“类名.方法名”的方式， 也可以使用“对象.方法名”的方式。 而实例方法只有后面这种方式。 也就是说， 调用静态方法可不需要创建对象。 </li><li>静态方法在访问本类的成员时， 只允许访问静态成员（即静态成员变量和静态方法）， 而不允许访问实例成员变量和实例方法； 实例方法则无此限制。 </li></ol><h3 id="对象的相等与指向他们的引用相等，两者有什么不同？"><a href="#对象的相等与指向他们的引用相等，两者有什么不同？" class="headerlink" title="对象的相等与指向他们的引用相等，两者有什么不同？"></a>对象的相等与指向他们的引用相等，两者有什么不同？</h3><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p><h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h3><p>帮助子类做初始化工作。</p><h3 id="注释和注解的区别"><a href="#注释和注解的区别" class="headerlink" title="注释和注解的区别"></a>注释和注解的区别</h3><p>Java中的注释和其他编程语言一样，注释的内容不会被编译运行，知识源代码中对代码的解释说明， 提高源代码的可读性。</p><p>Java中的注解（Annotation），也叫元数据，是Java 5以后版本引入的一个特性</p><ul><li>注解与类、接口、枚举是在同一个层次，可以用来标注包、类、字段、方法、局部变量、方法参数等元素，达到对这些元素的面数和说明。</li><li>注解是可以允许 jvm 在运行中读取它，这一点与注释完全不同。</li><li>注解作用： 编写文档， 代码分析， 编译检查</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;与-equals&quot;&gt;&lt;a href=&quot;#与-equals&quot; class=&quot;headerlink&quot; title=&quot;== 与 equals&quot;&gt;&lt;/a&gt;== 与 equals&lt;/h3&gt;&lt;p&gt;== : 它的作用判断两个对象的地址是否相等, 判断基本数据类型的值是否相等.&lt;
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="笔记" scheme="https://www.daihuiyou.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://www.daihuiyou.top/2018/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.daihuiyou.top/2018/10/11/数据结构/</id>
    <published>2018-10-11T00:53:13.000Z</published>
    <updated>2018-11-09T06:10:01.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="for循环常用写法"><a href="#for循环常用写法" class="headerlink" title="for循环常用写法"></a>for循环常用写法</h3><p>date: 2018-09-27 11:03:38</p><p>插入元素:<br><img src="https://i.imgur.com/AbGJ8V6.png" alt=""></p><p>删除元素:<br><img src="https://i.imgur.com/Rcci3gt.png" alt=""></p><pre><code class="c++">void main(){    int  i = 0;    int a[20];    int len = 10;    int pos = 5;    i = i - 1; /*结果:i = -1; 不是溢出.*/    printf(&quot;i = %d\n&quot;, i);    /*数组赋值*/    for (i = 0; i &lt; len; i++)        a[i] = i + 1;    printf(&quot;\n&quot;);    /*逆序打印*/    for (i = len-1; i &gt;=0; i--)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    /*插入元素, 往后移动元素(倒序循环)*/    for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/    {        a[i+1] = a[i];  /*表示最后要插入a[6] = a[5] */    }    a[5] = 0;    len = len + 1;        /*逆序打印*/    for (i = len-1; i &gt;= 0; i--)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    /*删除元素, 往前移动(正序循环)*/    for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/    {        a[i] = a[i+1];    }    len = len - 1;    /*逆序打印*/    for (i = len - 1; i &gt;= 0; i--) //倒序循环        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    printf(&quot;\n&quot;);    printf(&quot;hello.&quot;);    system(&quot;pause&quot;);}/*总结:符号要注意区分, 正序循环&lt; 和 倒序循环&gt;A: 正序循环 for(i=0; i&lt;len; i++)              for(i=1; i&lt;=len; i++)B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号           for(i=len; i&lt;0; i--) */</code></pre><h3 id="循序栈和链式栈"><a href="#循序栈和链式栈" class="headerlink" title="循序栈和链式栈"></a>循序栈和链式栈</h3><p>date: 2018-09-25 15:54:15</p><p>stack的采用模型：</p><p>线性表的链式存储：头插法　　　</p><p>线性表的顺序存储：尾插法　</p><h3 id="线性表顺序存储和链式存储"><a href="#线性表顺序存储和链式存储" class="headerlink" title="线性表顺序存储和链式存储"></a>线性表顺序存储和链式存储</h3><p>date: 2018-09-23 19:46:15</p><p>单独把结点的指针域 声明成结构体数据类型， </p><p>指针指向谁， 就把谁的地址赋给指针。</p><p><img src="https://i.imgur.com/1IEmyQY.png" alt=""></p><p><strong>note:</strong></p><p>wrong:</p><pre><code class="c++">current-&gt;next = node-&gt;next;node = current-&gt;next;        // what is wrong?   node is not pointer filed and can&#39;t be assigned.</code></pre><p>right:</p><pre><code class="c++">    node-&gt;next = current-&gt;next;    current-&gt;next = node;</code></pre><p><strong>LinkList Test FrameWork</strong></p><pre><code class="c++">#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;linklist.h&quot;typedef struct Teahcer{    LinkListNode *node;    int age;    int name[64];}Teacher;void main(){    int len = 0;    int i = 0;    Teacher *tmp = NULL;    LinkList *list = NULL;      //note: list is handle that is void type.    list = LinkListCreate();    Teacher t1, t2, t3, t4, t5;    t1.age = 31;    t2.age = 32;    t3.age = 33;    t4.age = 34;    t5.age = 35;    list = LinkListCreate();    LinkListInsert(list, (LinkListNode*)&amp;t1, 0);    LinkListInsert(list, (LinkListNode*)&amp;t2, 0);    LinkListInsert(list, (LinkListNode*)&amp;t3, 0);    LinkListInsert(list, (LinkListNode*)&amp;t4, 0);    LinkListInsert(list, (LinkListNode*)&amp;t5, 0);    len = LinkListGetLength(list);    for (i = 0; i &lt; len; i++)    {        tmp = (Teacher*)LinkListGetElement(list, i);        if (tmp != NULL)        {            printf(&quot;age: %d &quot;, tmp-&gt;age);        }    }    printf(&quot;\n&quot;);    //note: This function deletes LinkList element at the position.    LinkListDeleteElement(list, 2);    printf(&quot;After delete element. \n &quot;);    len = LinkListGetLength(list);    for (i = 0; i &lt; len; i++)    {        tmp = (Teacher*)LinkListGetElement(list, i);        if (tmp != NULL)        {            printf(&quot;age: %d &quot;, tmp-&gt;age);        }    }    printf(&quot;\n&quot;);    LinkListClear(list);    printf(&quot;hello.&quot;);    system(&quot;pause&quot;);}</code></pre><p><strong>linklist.h</strong></p><pre><code class="c++">#pragma once#ifndef _LINKLIST_H#define _LINKLIST_H#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#endif/*    LinkList API*/typedef void LinkList;typedef struct _tag_LinkListNode{    struct _tag_LinkListNode *next;}LinkListNode; //Node type   It&#39;s a great heavest for me..  LinkList *LinkListCreate();int LinkListClear(LinkList *list);LinkListNode * LinkListGetElement(LinkList *list, int pos);int LinkListInsert(LinkList *list, LinkListNode *node, int pos);int LinkListDeleteElement(LinkList *list, int pos);int LinkListGetLength(LinkList *list);</code></pre><p><strong>linklist.c</strong></p><pre><code class="c++">#include &quot;linklist.h&quot;typedef struct _tag_LinkList{    LinkListNode header;    int length;}TLinkList; //It&#39;s still LinkListNode type.LinkList *LinkListCreate(){    TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory.     if (ret == NULL)    {        return NULL;    }    ret-&gt;length = 0;    ret-&gt;header.next = NULL;    return ret;}int LinkListClear(LinkList *list){    if (list == NULL)    {        return 0;    }    TLinkList *tlist = (TLinkList *)list;    free(tlist);    return 0;}LinkListNode * LinkListGetElement(LinkList *list, int pos){    int i = 0;    TLinkList *tlist = NULL;    LinkListNode *current = NULL;    LinkListNode *ret = NULL;    tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type);    current = &amp;tlist-&gt;header;     if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length)    {        return NULL;    }    for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++)    {            current = current-&gt;next;    }    ret = current-&gt;next;    return     ret;}int LinkListInsert(LinkList *list, LinkListNode *node, int pos){    int i = 0;    TLinkList  *tlist = (TLinkList*)list; //transfrom    LinkListNode *current = NULL;    LinkListNode *ret = NULL;    current = &amp;tlist-&gt;header;    for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++)    {        current = current-&gt;next;    }    //insert elememt;    ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element;    current-&gt;next = node;    node-&gt;next = ret;    tlist-&gt;length++;    return 0;}int LinkListDeleteElement(LinkList *list, int pos){    int i = 0;    LinkListNode  *current = NULL;    LinkListNode *ret = NULL;    TLinkList *tlist = (TLinkList *)list;    current = &amp;tlist-&gt;header;    if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length)    {        return NULL;    }    for (i = 0; i &lt; pos; i++)    {        current = current-&gt;next;    }    ret = current-&gt;next;    current-&gt;next = ret-&gt;next;    return 0;}int LinkListGetLength(LinkList *list){    int ret = 0;    TLinkList *tlist = (TLinkList* )list;    ret = tlist-&gt;length;    return ret;}</code></pre><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>date: 2018-09-22 14:22:10</p><p>数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。</p><p>数据项：一个数据元素可以由若干个数据项组成。</p><p>数据对象： 是性质相同的数据元素的集合，是数据的子集。</p><p>抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。  </p><p>逻辑结构：集合结构，线性结构，树形结构，图形结构</p><p>物理结构：顺序存储结构，链接存储结构。</p><p>好的算法还应该具备时间效率高和存储量低的特点。　　</p><p>线性阶：      </p><pre><code class="c++">int i;for(i=0; i&lt;n; i=+){}//对数阶： int count = 1;while (count  &lt; n){count = count * 2;}//平方阶：  int i, j;for (i = 0; i &lt; n; i++){    for (j = 0; j &lt; n; j++)    {    }}//时间复杂（m*n):  int i, j;for (i = 0; i &lt; n; i++){    for (j = i; j &lt; n; j++)    {        /*时间复杂度*/    }}//数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2;/*最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。  平均时间是所有情况中最有意义的，因为他是期望的运行时间。一般没有特殊说明的情况下， 都是指最坏时间复杂度。/*</code></pre><p><strong>可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。</strong></p><p>线性表的抽象数据类型 :</p><ol><li>时间复杂度</li><li><p>空间复杂度  </p></li><li><p>时间换空间  </p></li><li><p>空间换时间</p></li></ol><p>　</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。</p><p>基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树）</p><p>二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。</p><p>满二叉树：每层都“充满”了结点。</p><p>完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。</p><p>性质： <strong>对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2.</strong> 可以通过数组下标，隐藏地找到其左孩子和右孩子。 </p><p>不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。</p><h4 id="二叉树的表示法"><a href="#二叉树的表示法" class="headerlink" title="二叉树的表示法"></a><strong>二叉树的表示法</strong></h4><p>二叉树的二叉链表 表示法</p><p>二叉树的三叉链表 表示法： 添加了 Parent Position</p><p>二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。</p><p>​    </p><pre><code class="c">//二叉链 表示法 typedef struct BitNode {    int data;    struct BitNode *lchild, *rchild;}BitNode, *BitNode;//三叉链表typedef struct TriNode {    int data;    struct TriNode *lchild, *rchild;    struct TriNode *parent;}TriNode, *TriNode;//双亲表示法#define MAX_TREE_SIZE 100typedef struct BPTNode {    int data;    int parentPosition;    char LRTag;}BPTNode;typedef struct BPTree {    BPTNode nodes[MAX_TREE_SIZE];    int num_node;    int root;}BPTree;</code></pre><h4 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h4><p>先序遍历： DLR， 先根再左再右</p><p>中序遍历： LDR， 先左再根再右</p><p>后序遍历： LDR，先左再右再根</p><p>总结： 顺序都是相对于根（root）来说的。</p><p>二叉树表示算数表达式： </p><ol><li>先序遍历： 前缀表示法</li><li>中序遍历： 中缀表示法</li><li>后序遍历： 后缀表示法</li></ol><p>对遍历的分析：</p><p>1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。</p><p>从虚线的出发点到终点的路径上，每个结点经过3次。</p><p>第 1 次经过时访问 = 先序遍历</p><p>第 2 次经过时访问 = 中序遍历</p><p>第 3 次经过时访问 = 后序遍历</p><h3 id="树的非递归中序遍历"><a href="#树的非递归中序遍历" class="headerlink" title="树的非递归中序遍历"></a>树的非递归中序遍历</h3><pre><code class="c++">/*步骤1： 如果结点有左子树，该结点入栈；若果结点没有左子树，访问该结点步骤2： 如果结点有右子树，重复步骤1；如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1如果栈为空，表示遍历结束。*/#include &lt;iostream&gt;using namespace std;#include &quot;stack&quot;typedef struct BitNode {    int data;    struct BitNode *lchild;    struct BitNode *rchild;}BitNode;//参数列表: BitNode *T, stack(BitNode *&gt; &amp;s//返回值: BitNode *BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) {   //&amp;s 引用类型    if (T == NULL) {        return NULL;    }    while (T-&gt;lchild != NULL) {        //如果有左子树， 该结点入栈，并指向左子树。        s.push(T);        T = T-&gt;lchild;    }    //如果没有左子树， 返回该结点。    return T;}void inOrder(BitNode *T) {    BitNode *t = NULL;    stack&lt;BitNode *&gt;s;    t = goLeft(T, s);    while (t) {        printf(&quot;%d &quot;, t-&gt;data); // 访问该结点        //如果t有右子树，重复步骤1        if (t-&gt;rchild != NULL) {            t = goLeft(t-&gt;rchild, s);        }        // 如果t没有右子树，根据栈顶提示，回退        else if (!s.empty()) {            t = s.top();            s.pop();        }        // 如果没有右子树， 并且栈为空        else {            t = NULL;        }    }}void main() {    BitNode t1, t2, t3, t4, t5;    memset(&amp;t1, 0, sizeof(BitNode));    memset(&amp;t2, 0, sizeof(BitNode));    memset(&amp;t3, 0, sizeof(BitNode));    memset(&amp;t4, 0, sizeof(BitNode));    memset(&amp;t5, 0, sizeof(BitNode));    t1.data = 1;    t2.data = 2;    t3.data = 3;    t4.data = 4;    t5.data = 5;    t1.lchild = &amp;t2;    t1.rchild = &amp;t3;    t2.lchild = &amp;t4;    t3.lchild = &amp;t5;    printf(&quot;\r\n 非递归遍历 \r\n&quot;);    inOrder(&amp;t1);    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    system(&quot;pause&quot;);}</code></pre><p>通过中序遍历和先序遍历可以确定一个树</p><p>通过中序遍历和后序遍历可以确定一个树</p><p>通过先序遍历和后序遍历不能确定一个树</p><p>单独先序遍历。</p><p>二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;for循环常用写法&quot;&gt;&lt;a href=&quot;#for循环常用写法&quot; class=&quot;headerlink&quot; title=&quot;for循环常用写法&quot;&gt;&lt;/a&gt;for循环常用写法&lt;/h3&gt;&lt;p&gt;date: 2018-09-27 11:03:38&lt;/p&gt;
&lt;p&gt;插入元素:&lt;br&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="理论" scheme="https://www.daihuiyou.top/tags/%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://www.daihuiyou.top/2018/10/11/C++/"/>
    <id>https://www.daihuiyou.top/2018/10/11/C++/</id>
    <published>2018-10-11T00:17:58.000Z</published>
    <updated>2018-11-09T06:12:53.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>date: 2018-09-20 17:15:00</p><p>匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。</p><pre><code class="c++">class AA{public:    AA()    {        cout &lt;&lt; &quot;调用拷贝构造函数&quot; &lt;&lt; endl;    }    ~AA()    {        cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl;    }};void main(){    //AA a = AA();  //产生一个匿名对象， 有一个变量去接，不会调用析构函数。    AA b;   //调用拷贝构造函数。    b = AA();   //匿名对象， 会调用拷贝构造函数和析构函数。    //func();    system(&quot;pause&quot;);}</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>date: 2018-09-21 14:28:22</p><p>抛出异常是跨函数的。</p><p>c++异常处理机制使得异常的引发和异常的处理不必写在同一个函数中，<br>这样底层的函数可以着重解决具体问题， 而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。</p><p>栈解旋unwinding， 在函数中发生异常时， 立即结束局部变量的生命周期， 并抛出异常（throw）。</p><p>异常接口声明：为了加强程序的可读性， 可以在函数声明中列出可能抛出所有异常类型。</p><pre><code class="c++">void func() thorw(A, B, C, D){}</code></pre><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>date: 2018-09-20 21:51:18</p><p>左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。  </p><p>右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</p><p><img src="https://i.imgur.com/Yq0pat4.png" alt=""></p><p>常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。</p><p>常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。</p><p>字符串常量/字面量</p><p>拷贝构造函数：是一种特殊的构造函数，他在构建对象时， 是使用同一类中之前创建的对象来初始化新创建的对象。   </p><p>迭代器： 是一种检查容器内元素并遍历元素的数据类型，可以代替下标访问vector对象的元素。迭代器是便利容器的同一方法。</p><p>容器： 任何数据类型都能存储。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用分为普通引用和常引用</p><pre><code class="c++">//常引用 //常引用当函数参数 ,可以传字面量或者实参void func1(const int&amp; num){    cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl;}//普通引用当函数参数， 传实参void func2(int &amp;num){    cout &lt;&lt; &quot;num: &quot; &lt;&lt; num &lt;&lt; endl;}void main(){    int a = 10;    int c = a;  //引用当右值， 把变量的值赋值给变量    int &amp;d = c; //引用当左值， 把变量C起另一个别名， 本质把C的地址赋值给D。    cout &lt;&lt; &quot;&amp;d : &quot; &lt;&lt; &amp;d &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;c : &quot; &lt;&lt; &amp;c &lt;&lt; endl;    cout &lt;&lt; &quot;&amp;a : &quot; &lt;&lt; &amp;a &lt;&lt; endl;    cout &lt;&lt; &quot;d : &quot; &lt;&lt; d &lt;&lt; endl;    cout &lt;&lt; &quot;c : &quot; &lt;&lt; c &lt;&lt; endl;    cout &lt;&lt; &quot;a : &quot; &lt;&lt; a &lt;&lt; endl;    //字面量常引用    const int&amp; tmp = 123; //分配内存    cout &lt;&lt; &quot;&amp;tmp : &quot; &lt;&lt; &amp;tmp &lt;&lt; endl;    cout &lt;&lt; &quot;tmp : &quot; &lt;&lt; tmp &lt;&lt; endl;    //普通引用    //int&amp; var = 123;        //不自动分配内存， 编译错误    int var = 123;    func1(123);        //可以传进字面量    func1(var);    //可以传进变量    func2(var); //只能传进变量.    cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl;    system(&quot;pause&quot;);}</code></pre><p><strong>常量必须初始化</strong></p><p><img src="https://i.imgur.com/JVMkB17.png" alt=""></p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>date: 2018-09-20 08:28:05</p><p>重写与重载：</p><ul><li>方法的重写Overriding和重载Overloading是多态性的不同表现。</li><li>重写Overriding是父类与子类之间多态性的一种表现，</li><li>重载Overloading是一个类中多态性的一种表现。</li><li>如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。</li><li>子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；</li><li>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。<br>Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同</li></ul><p>定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。</p><h3 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h3><p>date: 2018-09-19 21:34:18</p><ul><li>左值和右值</li><li>左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；</li><li>右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。<br>-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。</li></ul><p>对象的初始化， 和赋值不一样 </p><pre><code class="c++">A a = b;     //    调用a的拷贝构造函数A a;a = b;  //调用操作符重载=函数, </code></pre><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>date: 2018-09-19 15:41:31</p><pre><code class="c++">#include &quot;iostream&quot;//类模板的本质， 两次编译using namespace std;template &lt;typename T&gt;class Teacher{public :    static T a;private:};template &lt;typename T&gt;T Teacher&lt;T&gt;::a = 0;void main(){        Teacher&lt;int&gt; t1;    t1.a = 10;    t1.a++;    t1.a++;    Teacher&lt;char&gt; t2;    t2.a = &#39;a&#39;;    t2.a++;    t2.a++;    cout &lt;&lt; t2.a &lt;&lt; endl; //两个静态变量， 不一样， 属于不同内存空间    cout &lt;&lt; t1.a &lt;&lt; endl;//类模板机制的本质， 两次编译    cout &lt;&lt; &quot;hello.&quot; &lt;&lt; endl;    system(&quot;pause&quot;);}</code></pre><h3 id="线性链表"><a href="#线性链表" class="headerlink" title="线性链表"></a>线性链表</h3><p>date: 2018-09-18 17:29:04</p><h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>date: 2018-09-17 22:11:16</p><h3 id="指针作引用"><a href="#指针作引用" class="headerlink" title="指针作引用"></a>指针作引用</h3><p>date: 2018-09-11 20:17:36</p><h3 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h3><p>date: 2018-09-11 14:49:20</p><pre><code class="c++">//结构体作函数参数struct Teacher{    char name[60];    int age;};void printTeacher1(Teacher t1){    cout &lt;&lt; t1.age &lt;&lt; endl;}void printTeacher2(Teacher &amp;t2){    t2.age = 20;    cout &lt;&lt;t2.age&lt;&lt; endl;}void printTeacher3(Teacher *t3){    t3-&gt;age = 30;    cout &lt;&lt; t3-&gt;age &lt;&lt; endl;}void main(){    Teacher t1;    t1.age =10;    printTeacher1(t1);    printTeacher2(t1);    //引用方式，结构体作函数参数    printTeacher3(&amp;t1);    //作用与指针间接赋值一样。    system(&quot;pause&quot;);    return;}</code></pre><p><strong>Type &amp;name = var;//等效于C语言 Type *const name = var;</strong></p><p>引用作函数参数， 当左值和右值。</p><p>当左值的条件：要有内存空间；C++编译器帮助程序员取了一个地址而已  </p><p>引用就是给内存取多个门牌号（多个别名）</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>date: 2018-09-11 07:21:16</p><pre><code class="c++">//struct 和 class完成的功能一样//布尔类型  bool类型//关于左值（必须是一个变量，即有内存空间）//111 = 33；（111不能当左值， 不是一个变量，没有内存空间）//三目运算符， C返回是一个数（不能当左值）， C++返回是一个变量（能当左值）void main(){    bool b1, b2, b3;    b1 = 10;    b2 = -10;    b3 = 0;    cout &lt;&lt; &quot;sizeof(bool)&quot; &lt;&lt; sizeof(bool) &lt;&lt; endl;    cout &lt;&lt; b1 &lt;&lt; endl;    cout &lt;&lt; b2 &lt;&lt; endl;    cout &lt;&lt; b3 &lt;&lt; endl;    system(&quot;pause&quot;);    return;}//结果显示：//sizeof(bool)1//1//1//0//请按任意键继续. . .</code></pre><p><strong>const 和 #define 相同之处</strong></p><ol><li>#define 是单纯的文本替换， 作用域具有全局性 </li><li>#undef 限制作用域</li></ol><p><strong>引用的基本用法</strong></p><p>C++的引用: 已定义变量再起个别名</p><p>Type&amp; name = var;</p><pre><code class="c++">//引用作函数参数: 与指针类似void myswap1 (int a, int b) //不能间接赋值{    int c = 0;    c = a;    a = b;    b = c;}void myswap2(int *a, int *b) //指针做函数参数， 实现间接赋值。{    int c = 0;    c = *b;    *b = *a;    *a = c;}void myswap3(int &amp;a, int &amp;b) //引用做函数参数， 实现间接赋值。{    int c = 0;    c = a;    a = b;    b = c;}void main(){    int a = 10;    int b = 20;    myswap1(a, b);    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;    myswap2(&amp;a, &amp;b);    printf(&quot;a = %d, b = %d\n&quot;, a, b);    myswap3(a, b);    cout &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; endl;    system(&quot;pause&quot;);    return;}/*结果显示:    10    20    a = 20, b = 10    10    20    请按任意键继续. . .*/</code></pre><p><strong>函数返回值当左值右值</strong></p><pre><code class="c++">int&amp; func(void){    int a = 10;    return a;}void main(){    int a = func(); //将栈变量的值赋值给a.    int &amp;b = func(); //传递栈变量的地址    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl;    cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; endl; //显示乱码    system(&quot;pause&quot;);}</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>date: 2018-09-10 17:49:28</p><pre><code class="c++">#include &quot;iostream&quot;using namspace std;void main(){    cout&lt;&lt;&quot;hello.\n&quot;&lt;&lt;endl;    system(&quot;pause&quot;):    retun;}</code></pre><p>//endl 相当于 \n</p><p>类是一种数据类型， 是固定大小内存块的别名  </p><p>定义一个类，是一个抽象的概念， 不会分配内存</p><p><strong>using namespace std;</strong></p><p>C中的命名空间，只有一个全局作用域。<br>C语言中所有的全局标识符共享一个作用域。</p><p><strong>命名空间</strong></p><ul><li>C++中提出了命名空间的概念：  </li><li>不同命名空间中的标识符可以同名而不会发生冲突  </li><li>命名空间可以相互嵌套   </li><li>全局作用域也叫默认命名空间。   </li></ul><pre><code class="c++">namespace namespaceA{    int age = 10;}namespace namespaceB{    int age = 20;    namespace namespaceC    {        struct Teacher        {            int age;        };    }}void main(){    cout &lt;&lt; &quot;hell.&quot; &lt;&lt; endl;    using namespace namespaceA;    using namespace namespaceB;    cout &lt;&lt; namespaceA::age&lt;&lt;endl;    cout &lt;&lt; namespaceB::age&lt;&lt;endl;    using namespaceB::namespaceC::Teacher  ;    //注意事项， 缺少namespace    Teacher t1;    t1.age = 30;    cout &lt;&lt; t1.age &lt;&lt;endl;    system(&quot;pause&quot;);    return;}</code></pre><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;匿名对象&quot;&gt;&lt;a href=&quot;#匿名对象&quot; class=&quot;headerlink&quot; title=&quot;匿名对象&quot;&gt;&lt;/a&gt;匿名对象&lt;/h3&gt;&lt;p&gt;date: 2018-09-20 17:15:00&lt;/p&gt;
&lt;p&gt;匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="语言" scheme="https://www.daihuiyou.top/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C</title>
    <link href="https://www.daihuiyou.top/2018/10/10/C/"/>
    <id>https://www.daihuiyou.top/2018/10/10/C/</id>
    <published>2018-10-10T13:58:34.000Z</published>
    <updated>2018-11-09T06:09:26.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>date: 2018-09-10 13:57:09</p><p>链表是一种结构体， 包括数据域和指针域。</p><p>链表是一种物理存储单元上非连续的线性存储结构。</p><p>链表遍历</p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>date: 2018-09-06 17:20:42</p><ul><li>h头文件是编译时必须的，</li><li>lib库是链接时需要的，</li><li>dll动态链接库是运行时需要的。</li></ul><p><strong>.h .lib .dll三者的关系是：</strong></p><ul><li>h文件作用是：声明函数接口</li><li>lib文件作用是：二进制函数实现代码或函数在dll文件中的索引地址</li><li>dll文件作用是：函数可执行文件</li></ul><p>动态库是底层函数的调用入口。<br>动态库与测试框架相结合。</p><p><strong>void SockInit(void *handle)：</strong></p><ul><li>handle(句柄) 理解是调用者不需了解据类型，只要求主调函数分配内存，传参数于被调用函数；</li><li>被调函数将传进来的参数handle 强制转换相应的数据类型。</li></ul><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>date: 2018-09-06 11:44:51</p><p><strong>文件句柄</strong>： 就是内存块的首地址或者资源首地址。</p><p><strong>测试框架 和  分层模块的区别</strong></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>date: 2018-09-05 13:53:11</p><pre><code class="c">//结构体定义typedef struct Teacher{    char name[30];    int age;}Teacher;Teacher *SortTeacher(int num) //堆区分配内存{    Teacher *pArray = NULL;    pArray = (Teacher *) malloc(sizeof(Teacher) *num);    if(pArray == NULL)    {        printf(&quot;pArray = NULL.&quot;);    }    return pArray.} //返回值//优化int CreateTeahcer_good( Teacher **pArray, int num)    //    用二级指针修改一级指针的值{    Teacher * temp;    temp = (Teacher *)malloc(sizeof(Teacher)*num);    if(temp == NULL)    {        return -1;        printf(&quot;堆区分配失败.&quot;);    }    *pArray = temp;    return 0;}</code></pre><p><strong>用结构体套一级指针</strong></p><pre><code class="c">//结构体定义typedef struct Teacher{    char name[30];    int age;    char *id;  //需要分配内存空间才有效。}Teacher;int CreateTeahcer_good( Teacher **pArray, int num)    //    用二级指针修改一级指针的值{    Teacher * temp;    int i = 0;    temp = (Teacher *)malloc(sizeof(Teacher)*num);    if(temp == NULL)    {        return -1;        printf(&quot;堆区分配失败.&quot;);    }    for(i=0; i&lt;num; i++)    {        temp[i].id = (char *)malloc(sizeof(char)*120);    }    *pArray = temp;    return 0;}//需要两次释放堆内存  void freeMem(Teacher *pArray){    if(pArray == NULL)    {        printf(&quot;error.&quot;);    }    if(pArray-&gt;id != NULL)    {        free(pArray-&gt;id);        pArray-&gt;id = NULL;    }    free(pArray);    pArray = NULL;}/* 结构体嵌套二级指针C语言的高效（数组作函数的参数的退化现象）指针作间接赋值的应用。（修改主函数一级指针的值，被调函数的参数为二级指针）。什么时候用一级指针，什么时候用二级指针。  被调用函数分配内存，供主调函数使用，二级指针。  主调函数分配内存，供被调函数使用，一级指针。 *p间接赋值成立的条件：3个条件：- 2个变量（通常一个实参，一个形参）- 建立关系，实参取地址赋给形参- *p形参区间接修改形参的值不断修改指针变量的值越界场景：char from[5] = &quot;abcde&quot; //数组越界 &quot;abcde&quot;包含&#39;\0&#39;总结:     函数调用时，用n级指针（形参）改变n-1级指针（实参）的值/*</code></pre><h3 id="const-的用法"><a href="#const-的用法" class="headerlink" title="const 的用法"></a>const 的用法</h3><p>date: 2018-09-04 09:17:33</p><pre><code class="c">//const char *p 指针所指向的内存不能被修改void getMem(const char *p){    p++;    //*p = 1;}//char *const p 指针变量的值的不能被修改。void getMem2(char *const p){    //p++;    *p = 1;}//const char *const p 指针变量的值和它所指向的内存不能被修改。void getMem3(const char *const p){    //p++;    //*p = 1;}</code></pre><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>date: 2018-09-04 16:57:20</p><pre><code class="c">void main(){    int a[] = {1, 2};    int b[100] = {1, 3};    int c[200] = {0}; //编译的是 就已经确定 所有的值 为零    memset(c, 0, sizeof(c)); //显示的 重置内存块    //对一维数组  C规定：    //c是数组首元素的地址 c+1 步长 4个字节    //&amp;c 是整个数组的地址 //&amp;c+1 步长 200*4     printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}//怎么样表达int a[10]这种数据类型那？int[]    //类型本质：固定大小内存块的别名  //定义数组类型   </code></pre><pre><code class="c">void main(){    typedef int (MyArrayType)[5]; //定义了一个数据类型  数组数据类型    int i = 0;    MyArrayType  myArray;  //int myArray[5];    for (i=0; i&lt;5; i++)    {        myArray[i] = i+1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, myArray[i]);    }printf(&quot;myArray代表数组首元素的地址 myArray:%d myArray+1:%d \n&quot;, myArray, myArray+1);printf(&quot;&amp;myArray代表整个数组的地址 &amp;myArray:%d &amp;myArray+1:%d \n&quot;, &amp;myArray, &amp;myArray+1);    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>定义数组指针变量的方法1</strong></p><pre><code class="c">void main(){    char *Myarray[] = {&quot;1111&quot;, &quot;33333&quot;, &quot;aaaa&quot;}; //指针 数组    //数组指针  用一个指针 来指向一个数组    typedef int (MyArrayType)[5]; //定义了一个数据类型  数组数据类型    int i = 0;    MyArrayType  myArray;  //int myArray[5]; //用类型定义变量     MyArrayType *pArray; //定义一个指针变量 这个指针变量 指向一个数组    {        int myArray2[5]; //相当于一级指针        pArray = &amp;myArray2; //相当于2级指针        for (i=0; i&lt;5; i++)        {            (*pArray)[i] = i+1;        }        for (i=0; i&lt;5; i++)        {            printf(&quot;%d &quot;, (*pArray)[i]);        }    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>定义数组指针变量的方法2</strong></p><pre><code class="c">void main(){    //定义声明一个数组指针类型    typedef int (*PArrayType)[5];    PArrayType pArray;  //告诉编译器 给我分配一个指针变量    int c[5];    int i  = 0;    pArray = &amp;c;    for (i=0; i&lt;5; i++)    {        (*pArray)[i] = i + 1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, (*pArray)[i]);    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p>定义数组指针变量的方法3</p><pre><code class="c">void main(){    //int [][5]    int (*pMyArray)[5]; //直接定义一个指向数组的 数组指针变量    int c[5];    int i  = 0;    pMyArray = &amp;c;    for (i=0; i&lt;5; i++)    {        (*pMyArray)[i] = i + 1;    }    for (i=0; i&lt;5; i++)    {        printf(&quot;%d &quot;, (*pMyArray)[i]);    }    printf(&quot;hello...\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><p><strong>多维数组名的本质是数组指针</strong></p><p><strong>多维数组作参数退化问问题</strong></p><pre><code class="c">//多维数组作参数的退化问题void getArray1(int buff[3][5])//buff退化为数组指针{    int num = 0;    int i, j;    int temp = 0;    num = sizeof(buff);    printf(&quot;num:%d\n&quot;, num);    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            *(*(buff+i)+j) = temp++;        }    }}void getArray2(int buff[][5]){    int i, j;    int temp = 0;    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            buff[i][j] = temp++;        }    }}void getArray3(int (*buff)[5]){    int i, j;    int temp = 0;    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            *(*(buff+i)+j) = temp++;;        }    }}/*    多维数组名的本质  数组指针 ，步长 一维的长度    (a+i) 代表是整个第i行的地址  二级指针    *(a+i) 代表 1级指针  第i行首元素的地址    *(a+i) + j  ===&gt; &amp;  a[i][j]    *( *(a+i) + j) ===&gt;a[i][j]元素的值*/void main(){        int a[3][5];    int i, j;    int temp = 0;    getArray3(a);    for(i=0; i&lt;3; i++)    {        for(j=0; j&lt;5; j++)        {            printf(&quot;%d &quot;, a[i][j]);        }    }        printf(&quot;hello.\n&quot;);    system(&quot;pause&quot;);    return;}/*    等价关系    | 数组参数 | 等效数组参数     | ------ | ------ |    | 一维数组 char a[30] | 一级指针 char *a     | 指针数组 char *a[30] | 二级指针char **a     | 二维数组 char a[5][30] | 数组指针变量char (*a)[30]*/</code></pre><h3 id="二级指针的三种内存模型"><a href="#二级指针的三种内存模型" class="headerlink" title="二级指针的三种内存模型"></a>二级指针的三种内存模型</h3><p>date: 2018-09-04 11:28:19</p><pre><code class="c">void main(){    int num = 3;    int i, j;    char *p[] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;};     char myArray[10][10] = {&quot;asdv&quot;, &quot;abcd&quot;, &quot;123&quot;};    char **buff = (char**)malloc(sizeof(char*)*4);    for(i=0; i&lt;num; i++)    {        buff[i] = (char*)malloc(sizeof(char)*10);        sprintf(buff[i], &quot;%d%d%d&quot;,i+1,i+1,i+1);    }    for(i=0;i&lt;num; i++)    {        printf(&quot;%s\n&quot;, buff[i]);    }    system(&quot;pause&quot;);}</code></pre><p><img src="https://i.imgur.com/7xWidmb.png" alt=""></p><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><p>date: 2018-09-03 15:02:59</p><p><strong>字符串COPY函数优化过程</strong></p><pre><code class="c">/*buf[3] 和 *(p+3)   1.[]的本质 ： 和 *p 是一样的， 只不过是符合程序员的阅读习惯   2.buf是一个指针， 只读的常量， 是一个常量的指针， 析构内存的时候，保证buf所指向的内存空间安全释放。   3.p普通指针 和 数组第一个元素地址的区别*/void str_copy(char *from, char *to)  //表明主调函数分配内存，供被调函数内部使用{    for( ; *from != &#39;\0&#39;; from++, to++)    {        *to = *from;    }    *to = &#39;\0&#39;;}void str_copy1(char *from, char *to){    while( (*to = *from) != &#39;\0&#39;)    {        to++;        from++;    }}void str_copy2(char *from, char *to){    while((*to++ = *from++) != &#39;\0&#39;)  //等效与*to = *from; to++; from++;    {        ;    }}//建议不要直接修改形参的值， 要引入临时指针变量，把形参接过来void str_copy_good(char *from, char *to){    char *tempfrom = from;    char *tempto = to;    if( tempfrom ==NULL || tempto == NULL)    {        return;    }    while((*tempto++ = *tempfrom++) != &#39;\0&#39;);    printf(&quot;to : %s\n&quot;,to); //这样可以直接打印，避免COPY后，指针指向\0，打印不出来。}</code></pre><p><strong>正确示范</strong></p><pre><code class="c">void main(){    char *p = &quot;abcd&quot;;     char buff[123]; //分配内存    str_copy2(p, buff);    printf(&quot;buff:%s\n&quot;,buff);    system(&quot;pause&quot;);}</code></pre><p><strong>错误示范</strong> </p><pre><code class="c">void main(){    char *p = &quot;abcd&quot;;     char *to = NULL;//没有分配内存    str_copy2(p, to);//直接在0X0地址写值，程序运行中断。    printf(&quot;buff:%s\n&quot;,to);    system(&quot;pause&quot;);}</code></pre><p><strong>项目开发中字符串模型</strong></p><pre><code class="c">/* (*count)++和 *count++的区别：*count++ 等效于 *(count++)1. 输入特性 in：主函数分配内存，供被调函数使用。2. 输出特性out：被调函数分配内存，供主调函数。*/int getCount(char *mystr /*in*/, char *sub/*in*/, char *ncount/*in*/){    char * p = mystr;    char * count = ncount;    int ret;    if( mystr == NULL || sub == NULL || ncount == NULL)    {        ret = -1;        printf(&quot; mystr == NULL || sub == NULL || ncount == NULL)&quot;);    }    do    {        p = strstr(p, sub);        if(p != NULL)        {            (*count)++;  //(*count)++和 *count++的区别：*count++ 等效于 *(count++)            p = p + strlen(sub);        }    }while(*p != &#39;\0&#39;);    ret = 0;    return ret;}void main(){    char *p = &quot;123123adcd123123abcd123&quot;;    char *substr = &quot;123&quot;;     char count = 0;    int  ret;    ret = getCount(p, substr, &amp;count);    if (ret != 0)    {        printf(&quot;getCount() error;&quot;);        return;    }    printf(&quot;count :%d\n&quot;, count);    system(&quot;pause&quot;);}</code></pre><p><strong>字符串反转</strong></p><p>​    </p><p>​    </p><pre><code class="c">int reverse(char *str){    int length;    char *temp = str;    char *p1;    char *p2;    char c;    if(temp == NULL)    {        return -1;        printf(&quot;str = NULL.&quot;);    }    length = strlen(temp);    p1 = temp;    p2 = temp + length -1;    while(p1 &lt; p2)    {        c = *p1;        *p1 = *p2;        *p2 = c;        ++p1;        --p2;    }    return 0;}void main(){    char buff[] = &quot;123123abcd123123abcd123&quot;;    //char q[] = &quot;123123abcd123123abcd123&quot;;全局区不能被调用函数reverse()修改值    char *substr = &quot;abcd&quot;;     char count = 0;    int  ret;    printf(&quot;buff[]: %s\n&quot;, buff);    ret = reverse(buff);    if(ret != 0)    {        printf(&quot;reverse() error.&quot;);        return;    }    printf(&quot;buff = %s\n&quot;, buff);    system(&quot;pause&quot;);}</code></pre><p>​    </p><p><strong>通过递归方式和局部变量的方式实现的逆序打印字符串。</strong></p><pre><code class="c">void  inverse(char *p, char *mybuf){    if( p == NULL)    {        return ;        printf(&quot; p = NULL.&quot;);    }    if(*p == &#39;\0&#39;)    {        return;    }    inverse(p+1, mybuf);    strncat(mybuf, p, 1); //}void main(){    char buf[] = &quot;abcdfg&quot;;    char mybuf[100]={0};    inverse(buf,mybuf);    printf(&quot;%s\n&quot;, mybuf);    system(&quot;pause&quot;);    }</code></pre><p>​    </p><h3 id="二级指针的间接赋值"><a href="#二级指针的间接赋值" class="headerlink" title="二级指针的间接赋值"></a>二级指针的间接赋值</h3><p>date: 2018-09-02 19:07:59</p><pre><code class="c">void getMem(int **p)  //通过二级指针形参， 指向主函数的一级指针{    *p = (int*)malloc(100);}void getMem2(int *p) //一级指针形参，不能修改主函数的一级指针的值{    p = (int*)malloc(sizeof(char)*100);}void main(void){    int **p2 = NULL;    int *p1 = NULL;    p2 = &amp;p1;    getMem(p2);    printf(&quot;int *p :%d\n&quot;, p1); //修改了p1的值    getMem2(p1); //无修改p1的值    printf(&quot;int *p: %d\n&quot;, p1);    system(&quot;pause&quot;);    return ;}//结果显示：//int *p :7746448//int *p: 7746448//请按任意键继续. . .</code></pre><p><strong>间接赋值的应用</strong></p><pre><code class="c">    void getMem(char** p1/*out*/, int *len1/*out*/, char** p2/*out*/, int *len2/*out*/)    {        char *temp1 = NULL;        char *temp2 = NULL;        temp1 = (char *)malloc(100);        strcpy(temp1, &quot;12312312&quot;);        *len1 = strlen(temp1);        *p1 = temp1;        temp2 = (char *)malloc(200);        strcpy(temp2, &quot;asdfasdfasdf&quot;);        *len2 = strlen(temp2);        *p2 = temp1;    }    void main(void)    {        char *p1 = NULL;        char *p2 = NULL;        int  len1, len2;        getMem(&amp;p1, &amp;len1, &amp;p2, &amp;len2);//可以修改main函数的变量        printf(&quot;p1 = %s\n&quot;, p1);        printf(&quot;len1 = %d\n&quot;, len1);        printf(&quot;p2 = %s\n&quot;, p2);        printf(&quot;len2 = %d\n&quot;, len2);        system(&quot;pause&quot;);        }</code></pre><p><strong>指针作函数参数, 具有输入输出特性</strong></p><ul><li>输入特性 in：主函数分配内存，供被调函数使用。</li><li>输出特性out：被调函数分配内存，供主调函数。</li></ul><h3 id="指针也是一种数据类型"><a href="#指针也是一种数据类型" class="headerlink" title="指针也是一种数据类型"></a>指针也是一种数据类型</h3><p>date: 2018-09-02 10:07:52</p><ul><li>指针是一种数据类型，是指它指向的内存空间的数据类型  </li><li>含义1：指针步长（p++），根据所致内存空间的数据类型来确定  </li><li>p++=(unsigned char )p + sizeof(a);  </li><li>结论：指针的步长，根据所指内存空间类型来定</li></ul><pre><code class="c">void main(){    int b[40];    printf(&quot;b=%d, b+1=%d, &amp;b=%d, &amp;b+1=%d\n&quot;, b, b+1, &amp;b, &amp;b+1);    system(&quot;pause&quot;);     return;} 结果显示:    b=3013888, b+1=3013892, &amp;b=3013888, &amp;b+1=3014048  //b = &amp;b, b+1 != &amp;b+1; //b 表明 数组第一个数的地址。  //&amp;b 表明 整个数组的首地址。  //b 和 &amp;b 所代表的数据类型不一样 //&amp;b+1 加整个数组的大小得到的地址。  //&amp;b 加数组中第一个数的大小得到的地址。</code></pre><h3 id="堆栈区和函数调用分析"><a href="#堆栈区和函数调用分析" class="headerlink" title="堆栈区和函数调用分析"></a>堆栈区和函数调用分析</h3><p>date: 2018-09-02 08:57:39</p><p><strong>栈的生长方向</strong><br><img src="https://i.imgur.com/HEIBUoh.png" alt=""></p><p><strong>函数调用分析</strong><br><img src="https://i.imgur.com/qPse2Og.png" alt=""></p><pre><code class="c">//栈的开口向上向下,,测试 release和dubug;//一般认为:栈开口向下 //不管栈开口向上还是向下,buf的内存地址buf+1,永远向上的..void main(void){    int a;     int b;    char buf[99];  //静态编译的时候 buf所代表的内存空间的标号 就已经定义下来了....    printf(&quot;&amp;a:%d\r\n&quot;, &amp;a);    printf(&quot;&amp;b:%d\r\n&quot;, &amp;b);    printf(&quot;buf:%d\r\n&quot;, buf);    printf(&quot;hello\n&quot;);    system(&quot;pause&quot;);    return ;}</code></pre><h3 id="堆栈区的理解"><a href="#堆栈区的理解" class="headerlink" title="堆栈区的理解"></a>堆栈区的理解</h3><p>date: 2018-09-01 20:40:25    </p><pre><code class="c">//堆区char *getMem(int num){    char *p;    p = (char *)malloc(sizeof(char)*num); //在栈区存放 堆分配内存    if(p == NULL)    {        return;    }    return p;}//栈区char * getMem2(){    char *p = NULL;    char a[40]; //局部变量，临时变量    p = a;    return p;}void main(void){    char *p1 = NULL;    char *p2 = NULL;    p1 = getMem(10);    if(p1 == NULL)    {        return;    }    p2 = getMem2();    if(p2 == NULL)    {        return;    }    strcpy(p1, &quot;123123&quot;); //&quot;123123&quot; 复制到 p1中    strcpy(p2, &quot;123123&quot;);    //打印p1 p2 所指向内存空间的数据    printf(&quot;p1:%s p2:%s\r\n&quot;, p1, p2);    //打印p1 p2 的值    printf(&quot;p1:%d , p2:%d \n&quot;, p1, p2);     printf(&quot;hello\n&quot;);    system(&quot;pause&quot;);    return ;}//结果显示：//p1:123123 p2:乱码//p1:2896568 , p2:1572272//hello...//请按任意键继续. . .mallc()分配出来的堆区，可以通过指针， 使两个函数共享一块内存块，正是C语言强大的地方 </code></pre><h3 id="数据类型的大小-内存四区的划分"><a href="#数据类型的大小-内存四区的划分" class="headerlink" title="数据类型的大小, 内存四区的划分"></a>数据类型的大小, 内存四区的划分</h3><p>date: 2018-09-01 15:57:49</p><h3 id="函数参数退化问题-退回一个指针"><a href="#函数参数退化问题-退回一个指针" class="headerlink" title="函数参数退化问题, 退回一个指针"></a>函数参数退化问题, 退回一个指针</h3><p>date: 2018-09-01 12:01:59</p><ul><li><p>结论： 把数组的内存首地址和数组的有效长度传给被调用函数  </p></li><li><p>实参的 a 的 形参的 a的数据类型不一样  </p></li><li><p>形参中的数组， 编译器会把它当成指针处理， 这是C语言的特色。   </p></li><li><p>形参写在函数上，和卸载函数内是一样的，只不过是具有对外的属性而已。  </p><pre><code class="c">void SortArray(int a[], int num) // int a[] 数组的形参自动退化成指针。{    int i = 0, j = 0;    int temp = 0;    int num1 = 0;    num1 = sizeof(a) / sizeof(a[0]);    printf(&quot;num1: %d\r\n&quot;, num1); // num1  = 1, 结果表明形参中的a[]是指针类型。    for(i=0; i&lt;num; i++)    {        for(j=0; j&lt;i+1; j++)        {            if(a[i] &lt; a[j])            {                temp = a[i];                a[i] = a[j];                a[j] = temp;            }        }    }}void printfArray(int a[], int num){    int i = 0;    for(i=0; i&lt;6; i++)    {        printf(&quot;%d &quot;, a[i]);    }    printf(&quot;\n&quot;);}//排序void main(void){int a[] = {123,321,231,332,221,1};int    i, j, temp;int num = 0;num = sizeof(a) / sizeof(a[0]);printf(&quot;num = %d \r\n&quot;, num); // num = 6, 结果表明a[]为数组类型。SortArray(a, num);printfArray(a, num);printf(&quot;\n&quot;);printf(&quot;hello...\n&quot;);system(&quot;pause&quot;);return;}</code></pre><p><code>`</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;p&gt;date: 2018-09-10 13:57:09&lt;/p&gt;
&lt;p&gt;链表是一种结构体， 包括数据域和指针域。&lt;/p&gt;
&lt;p&gt;链表是一种物理存储
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="语言" scheme="https://www.daihuiyou.top/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Java</title>
    <link href="https://www.daihuiyou.top/2018/10/10/Java/"/>
    <id>https://www.daihuiyou.top/2018/10/10/Java/</id>
    <published>2018-10-10T13:51:26.000Z</published>
    <updated>2018-11-09T06:09:10.891Z</updated>
    
    <content type="html"><![CDATA[<p>java中类名第一个字母都是大写的.</p><h3 id="常量分类"><a href="#常量分类" class="headerlink" title="常量分类:"></a>常量分类:</h3><ol><li>字符型常量: “HelloWorld”</li><li>整形常量: 12</li><li>小数常量: 0.21</li><li>布尔常量: true</li><li>空常量: null</li></ol><h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类:"></a>数据类型分类:</h3><ol><li>基本数据类型<ol><li>注意: 整数默认是int 类型, 浮点数默认是double类型</li><li>定义long类型数据的时候, 要加L或者l</li><li>定义float类型数据的时候, 要加F或者f</li></ol></li><li>引用数据类型(类, 接口, 数组)</li></ol><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>标识符常见命名规则: <ul><li>包(就是文件夹, 用于对类进行管理)<ul><li>全部小写, 举例：com, com.itheima</li></ul></li><li>类<ul><li>一个单词的首字母大写</li><li>多个单词每个单词的首字符大写</li></ul></li><li>方法和变量<ul><li>一个单词首字母小写</li><li>多个单词组成, 从第二个单词开始每个单词的首字母大写. </li></ul></li></ul></li></ul><h3 id="变量定义和注意事项"><a href="#变量定义和注意事项" class="headerlink" title="变量定义和注意事项"></a>变量定义和注意事项</h3><ul><li>变量未赋值, 不能直接使用</li><li>变量只在它所属的范围内有效,变量属于它所在的那对大括号</li><li>一行上可以定义多个变量, 但是不建议</li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>隐式转换<ul><li>byte, short, char – int –long – float – double 从小变大</li></ul></li><li>强制转换<ul><li>目标类型 变量名 = (目标类型) (被转换的数据);</li><li>建议:　数据作运算，结果应该是什么类型，就用什么类型接受，不要随意转换类型，否则会有精度的损失．　</li></ul></li></ul><h3 id="字符串参与加法运算"><a href="#字符串参与加法运算" class="headerlink" title="字符串参与加法运算"></a>字符串参与加法运算</h3><pre><code class="JAVA">public class OperatorDemo01 {    public static void main(String[] args) {        int a = 10;        int b = 20;        System.out.println(a + b + &quot;hello wolrd.&quot;);        System.out.println(&quot;hello wolrd&quot; + a + b);        System.out.println(&quot;hello world&quot; + a);    }}</code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul><li><p>注意:扩展的赋值运算符，隐含了强制类型转换．</p><pre><code class="JAVA">short s = 1;s += 1; //s = (short)(s+1);System.out.println(s);</code></pre></li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li>&amp; 和 &amp;&amp;的区别:<ul><li>相同点:  &amp;&amp; 和 &amp; 的结果一样, || 和 | 的结果一样</li><li>不同点: &amp; 左边无论是什么, 右边都会执行. &amp;&amp;有短路效果, 左边为FALSE,右边都不执行.</li></ul></li></ul><h3 id="键盘录入-Scanner"><a href="#键盘录入-Scanner" class="headerlink" title="键盘录入 Scanner"></a>键盘录入 Scanner</h3><ul><li><p>导入包中类 :　</p><pre><code class="java">import java.util.Scanner;//快捷键(推荐) Ctrl + shift + o</code></pre></li><li><p>分配内存，定义对象</p><pre><code class="java">Scanner sc = new Sanner(System.in);    </code></pre></li></ul><h3 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h3><pre><code class="java">Random r = new Random(); //产生随机数for(int i=0; i&lt;10; i++) {    int ret = r.nextInt(10); //随机数的范围为[0, 10), 包括0, 不包括10;    System.out.println(ret);}int ret = r.nextInit(100) + 1; // 随机数的范围:[1, 100];</code></pre><h3 id="Java-中的内存分配"><a href="#Java-中的内存分配" class="headerlink" title="Java 中的内存分配"></a>Java 中的内存分配</h3><ul><li>Java 程序在运行时, 需要在内存中分配空间. 为了提高运算效率, 就对空间进行了不同区域的划分, 因为每一片区域都有特定的处理数据方式和内存管理方式. <ul><li>栈 存储局部变量</li><li>堆 存储new出来的东西</li><li>方法区(面向对象进阶讲)</li><li>本地方法区(和系统相关）</li><li>寄存器（给 cpu 使用)<br>-<img src="https://i.imgur.com/CADcID4.png" alt=""></li></ul></li></ul><h3 id="数组的动态初始化和静态初始化"><a href="#数组的动态初始化和静态初始化" class="headerlink" title="数组的动态初始化和静态初始化"></a>数组的动态初始化和静态初始化</h3><pre><code class="java">        //动态初始化        int [] myArray = new int[3];        //静态初始化        int [] myArray2 = new int[] {1,2,3};        //简化格式:int[] myArray2 = {1,2,3};</code></pre><ul><li><strong>引用类型</strong>: 类, 接口, 数组</li></ul><h3 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h3><pre><code class="java">System.out.println(); //输出内容并换行System.out.print(); //只输出内容,不换行. </code></pre><h3 id="方法的形参"><a href="#方法的形参" class="headerlink" title="方法的形参"></a>方法的形参</h3><ul><li><strong>基本数据类型</strong>:　形参的改变　不影响　实际参数．</li><li><strong>引用数据类型</strong>:　形参的改变直接　影响　实际参数．　</li></ul><h3 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h3><p><img src="https://i.imgur.com/Y5RDGbQ.png" alt=""></p><h3 id="方法共用的内存图"><a href="#方法共用的内存图" class="headerlink" title="方法共用的内存图"></a>方法共用的内存图</h3><p><img src="https://i.imgur.com/aq4c00z.png" alt=""></p><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ul><li>在类中的位置不同<ul><li>成员变量：　类中，方法外．</li><li>局部变量：　方法中或者方法声明中（形式参数）</li></ul></li><li>在内存中的位置不同<ul><li>成员变量：在堆内存分配</li><li>局部变量:　在栈内存分配</li></ul></li><li>生命周期不同<ul><li>成员变量随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量随着方法的调用而存在，随着方法的调用完成而消失．</li></ul></li><li>初始化值的问题<ul><li>成员变量有默认值</li><li>局部变量没有默认值，必须先定义，赋值，才可以使用．　</li></ul></li></ul><h3 id="类名作形式参数和返回值"><a href="#类名作形式参数和返回值" class="headerlink" title="类名作形式参数和返回值"></a>类名作形式参数和返回值</h3><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul><li><pre><code class="java">/* *      通过构造方法创建字符串对象和直接赋值方式创建字符串对象的区别 *      通过构造方法创建字符串对象在堆内. *      直接赋值方式创建对象在方法区的常量池. *   *  ==: *      基本数据类型:：比较是基本数据类型的值是否相等 *      引用数据类型:    比较是引用数据类型的地址值是否相等.  * */public class StringDemo {    public static void main(String[] args) {        String s1 = new String(&quot;Hello&quot;);        System.out.println(&quot;s1 &quot; + s1);        System.out.println(&quot;----------&quot;);        String s2 = &quot;Hello&quot;;        System.out.println(&quot;s2 &quot; + s2);        System.out.println(&quot;----------&quot;);        System.out.println(&quot;s1 == s2 : &quot; + (s1==s2));        String s3 = &quot;Hello&quot;;        System.out.println(&quot;s3 == s2: &quot; + (s3 == s2));    }}</code></pre></li><li><p>内存图:</p><ul><li><img src="https://i.imgur.com/FqjxClK.png" alt=""></li></ul></li><li><p>String类的判断功能</p><ul><li>Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类</li><li>如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象. </li></ul></li></ul><pre><code class="java">/* * Object: 是类层次结构的根类, 所有的类都直接或者间接继承该类 * 如果一个方法的形式参数是Object, 那么这里我们就可以传递它任意子类的对象.  * String类的判断功能: *  boolean equals(Object obj);  比较字符串的内容是否相同 *  boolean equalsIgnoreCase(String str); 比价字符串的内容是否相同, 忽略大小写 *  boolean startsWith(String str); 比较字符创对象是否以指定的str开始. *  boolean endsWith(String str); 比较字符创对象是否以指定的str结尾. *  * */public class StringDemo {    public static void main(String[] args) {        String s1 = &quot;hello&quot;;        String s2 = &quot;hello&quot;;        String s3 = &quot;Hello&quot;;        System.out.println(&quot;s1 == s2 :&quot; + s1.equals(s2));        System.out.println(&quot;s1 == s3 :&quot; + s1.equals(s3));        System.out.println(&quot;-------------&quot;);        System.out.println(&quot;s1 == s2 :&quot; + s1.equalsIgnoreCase(s2));        System.out.println(&quot;s1 == s3 :&quot; + s1.equalsIgnoreCase(s3));        System.out.println(&quot;-------------&quot;);        System.out.println(&quot;s1 == s2 :&quot; + s1.startsWith(&quot;he&quot;));        System.out.println(&quot;s1 == s3 :&quot; + s1.startsWith(&quot;he&quot;));        System.out.println(&quot;-------------&quot;);        System.out.println(&quot;s1 == s2 :&quot; + s1.endsWith(&quot;llo&quot;));        System.out.println(&quot;s1 == s3 :&quot; + s1.endsWith(&quot;llo&quot;));        System.out.println(&quot;-------------&quot;);    }</code></pre><ul><li>String类的获取功能</li></ul><pre><code class="java">/* *  String类的获取功能 *  int length():获取字符串长度, 其他也就是字符个数. *  char charAt(int index); 获取指定索引处的字符 *  int indexOf(String str); 获取str在字符串对象中第一次出现的索引 *  String substring(int start); 从start开始截取字符串 *  String substring(int start, int end); 从start到end之间截取字符串, 包括start, 不包括end *  * */public class StringDemo {    public static void main(String[] args) {        String s = &quot;helloworld&quot;;        System.out.println(s.length());        System.out.println(&quot;-----------&quot;);        System.out.println(s.charAt(0));        System.out.println(s.charAt(1));        System.out.println(&quot;-----------&quot;);        System.out.println(s.indexOf(&quot;ell&quot;));//获取str在字符串对象中第一次出现的索引        System.out.println(&quot;------------&quot;);        System.out.println(s.substring(5));         System.out.println(&quot;------------&quot;);        System.out.println(s.substring(0, 5));//从start到end之间截取字符串, 包括start, 不包括end    }}</code></pre><ul><li><p>String类的转换功能</p><pre><code class="java">/*    char[] toCharArray(): 把字符串转换为字符数组    String toLowerCase(): 把字符串转换为小写字符串    String toUpperCase(): 把字符串转换为大写字符串*/</code></pre></li><li><p>String类的其空格和分割功能   </p></li></ul><pre><code class="java">/*    String trim(): 去除字符串两端的空格    String[] spilt(String str): 按照指定符号分割字符串,注意返回的是字符数组*/public class StringDemo {public static void main(String[] args) {    String s = &quot;  aa,bb,cc&quot;;    String tmpStr = s.trim(); //去除字符串两端的空格, 不包括中间空格    System.out.println(tmpStr);    System.out.println(&quot;---------&quot;);    String[] strArray = tmpStr.split(&quot;,&quot;);//返回值是字符串数组.     for(int i=0; i&lt;strArray.length; i++) {        System.out.println(strArray[i]);    }}}</code></pre><ul><li><p>StringBulder类</p><ol><li><p>作用:　如果对字符串进行拼接操作，每次拼接，都会构建新的String的字符串对象, 即耗时,又浪费空间.而StringBuilder 可以解决这个问题. </p></li><li><p>内存分配示意图:<br><img src="https://i.imgur.com/4WkiZlo.png" alt=""></p></li><li><p>常用方法:</p><pre><code class="java">/* * StringBuilder: 是一个可变的字符串. 字符串数组缓冲类 *  * String 和 StringBuilder的区别 * String: 是内容是固定的.  * StringBilder: 是内容可变的 *  * StringBuilder的常用方法: * public String  append(任意类型); * public String reverse(String str); */public class StringDemo {    public static void main(String[] args) {        StringBuilder sb = new StringBuilder();        System.out.println(&quot;容量为:&quot; + sb.capacity());          System.out.println(&quot;长度为: &quot; + sb.length());        StringBuilder sb2 = sb.append(&quot;hello&quot;);  //返回本身对象的地址        System.out.println(sb);        System.out.println(sb2);        System.out.println(sb == sb2);           //链式编程        sb.append(123).append(123).append(123);        System.out.println(sb);        System.out.println(&quot;------------&quot;);        //public String reverse(String str)        sb.reverse();        System.out.println(sb);    }}</code></pre></li><li><p>String 和 StringBuilder 相互转换.</p><pre><code class="java">/*String 和 StringBuilder的相互转换StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;String     public String toString(); 通过toString()就可以实现把StringBuilder转换成StringString &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;StringBuilder    StringBuilder(String str); 通过构造方法, 将String转换成StringBuilder*/public class StringDemo {    public static void main(String[] args) {        //StringBuilder &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; String        StringBuilder sb = new StringBuilder();        sb.append(&quot;hello&quot;);        String s = sb.toString();        System.out.println(s);        //String &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; StringBuilder        String ss = &quot;hello&quot;;        StringBuilder sb2 = new StringBuilder(ss);        System.out.println(sb2);    }}</code></pre></li></ol></li></ul><h3 id="自动生成方法"><a href="#自动生成方法" class="headerlink" title="自动生成方法"></a>自动生成方法</h3><pre><code class="java">/* *  *  快速自动生成构造方法  Set() 和 Get()方法. *  右键:  source  *  Generate Constructor from Superclass 无参构造方法 *  Generate Constructor using Fields 有参构造方法 *  Generate constructor Getter and Setters ..  */public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        super();        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><p>内存图</p><p><img src="https://i.imgur.com/P0Ff6Ab.png" alt=""></p><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><ol><li>集合类的特点: 长度可变</li><li>ArrayLIst 集合的增加 删除 修改 查找的方法</li></ol><pre><code class="JAVA">/* *  *     获取元素  *         public E get (int index): 返回指定索引处的元素 *    集合长度 *        public int size():返回集合元素的个数 *    删除元素 *        public boolean remove(Object o): 删除指定元素, 返回删除是否成功 *    修改元素 *        public E set(int index, E, element):修改指定索引处的元素, 返回被修改的元素 */public class ObjectDemo {public static void main(String[] args) {    ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();    arr.add(&quot;hello&quot;);    arr.add(&quot;world&quot;);    arr.add(&quot;Java&quot;);    System.out.println(arr);    System.out.println(arr.size());    System.out.println(arr.remove(&quot;hello&quot;));    System.out.println(arr.set(1, &quot;android&quot;));    System.out.println(arr);}}</code></pre><ol><li>ArrayList 集合的遍历</li></ol><pre><code class="java">//集合的遍历  public class ObjectDemo {public static void main(String[] args) {    ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;();    arr.add(&quot;hello&quot;);    arr.add(&quot;world&quot;);    arr.add(&quot;Java&quot;);    //标准的遍历操作    for(int x=0; x&lt;arr.size(); x++) {        String s = arr.get(x);        System.out.println(s);    }}}</code></pre><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><strong>从程序角度出发:</strong></p><ol><li><strong>输入流</strong>,  文件读数据.</li><li><strong>输出流</strong>  文件写数据</li></ol><p><strong>输出流</strong></p><pre><code class="java">import java.io.FileWriter;import java.io.IOException;/* *  *     相对路径:　相对于当前项目的路径 *     绝对路径：系统盘符 *     flush() 和 close()的方法的区别: *     flush(): 刷新缓存区. 流对象还可以继续使用 *     close(): 先刷新缓冲区, 然后通知系统释放资源. 流对象不可以再被使用. */    public class FileDemo {public static void main(String[] args) throws IOException {    FileWriter fw = new FileWriter(&quot;a.txt&quot;);     fw.write(&quot;IO流&quot;);    fw.flush();    fw.close();}}</code></pre><p><strong>数据换行:</strong></p><pre><code class="java">/* *     如何实现数据的换行 *     \n 可以实现换行, 但是Windows系统自带的记事本打开并没有换行. *      Windows识别的换行符不是 &quot;\n&quot;, 而是&quot;\r\n&quot; *     常见的操作系统识别的换行符: *     windows:\r\n *  linux: \n *  mac: \r *   *     如何实现文本的追加 *  FileWriter fw = new FileWriter(String fileName, boolean append); */public class FileWirterDemo {public static void main(String[] args) throws IOException {    FileWriter fw = new FileWriter(&quot;b.txt&quot;, true); //实现的文本的追加    for(int x=0; x&lt;10; x++) {        fw.write(&quot;hello&quot;+x);        fw.write(&quot;\r\n&quot;);    }    fw.close();}}</code></pre><h3 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h3><pre><code class="java">public class fileDemo{    public static void main(String[] args) throws IOException {        FileReader fr = new FileReader(&quot;fr.txt&quot;);        int ch = 0;        //输入流 标准操作, 读到末尾时候值为-1        while((ch=fr.read())!=-1) {            System.out.print((char)ch);        }    }}</code></pre><h3 id="高效的IO流"><a href="#高效的IO流" class="headerlink" title="高效的IO流"></a>高效的IO流</h3><p>BufferedReader类 </p><p>BufferedWriter类</p><pre><code class="java">public class fileDemo{    public static void main(String[] args) throws IOException {        BufferedReader br = new BufferedReader(new FileReader(&quot;fr.txt&quot;);            String line;                                           while((line=br.readline())!=null) {            System.out.print((line);        }    }}</code></pre><h3 id="static-的作用"><a href="#static-的作用" class="headerlink" title="static 的作用"></a>static 的作用</h3><p> 一个JAVA源文件只能包含一个public类的</p><pre><code class="JAVA">/* * static 的特点: *     被所有的对象所共享 *     可以使用类名调用 *     静态的加载优先于对象 *     随着类的加载而加载, 加载到方法区中 *     总结: static修饰的成员变量和成员方法不属于的所有对象. *      */public class StaticDemo {public static void main(String[] args) {    System.out.println(&quot;hello world&quot;);    Person.school = &quot;wyu&quot;;    //静态的加载优先与对象, 随着类的加载而加载    //static赋值, 可以使用类名调用, 无需实例化对象.    Person p = new Person(&quot;xiaoming&quot;, &quot;21&quot;);}}class Person{    private String age;    private String name;    static String school;    public Person() {    }    public Person(String age, String name) {        super();        this.age = age;        this.name = name;    }    public void printIf() {        System.out.println(name+ &quot; &quot; + age+&quot; &quot;+ school);    }}</code></pre><p>注意事项:</p><pre><code class="java">/* * static的注意事项: *     静态方法:     *         可以调用静态成员变量和成员方法 *         不可以调用非静态成员方法和非静态成员变量 *     非静态的方法: *         全部都可以调用 *  静态的方法不含有this对象. */public class StaticDemo_01 {public static void main(String[] args) {    Student.school = &quot;s&quot;;    Student.sleep(); //方法区中}}class Student{    public String name;    static public String school;    public void print() {        System.out.println(name + school);    }    static void  sleep() {        System.out.println(&quot;slepp&quot;);    }}</code></pre><p>static的应用场景:</p><p>​    <strong>工具类</strong>: Math类的应用, 其方法中全部被static修饰</p><h3 id="自定义工具类"><a href="#自定义工具类" class="headerlink" title="自定义工具类"></a>自定义工具类</h3><pre><code class="JAVA">package myStatic;//自定义工具类的使用public class StaticDemo_02 {    public static void main(String[] args) {        int[] arr = {10, 3, 2, 4, 6};        int max = myArray.max(arr);        System.out.println(max);    }}-----------------------------------------------------------------------------------package myStatic;//自定义一个工具类public class myArray {//用 private修饰构造方法, 使class不可以实例化对象    private myArray() {    }    static int max(int[] arr) {        int max = 0;        for(int x=0; x&lt;arr.length; x++) {            if(max &lt; arr[x]) {                max = arr[x];            }        }        return max;    }}</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>局部代码块 构造代码块 和 静态代码块</p><pre><code class="java"></code></pre><p>代码块的执行顺序:</p><pre><code class="java">    /* *     代码块块的调用顺序: *         BlockTest 静态代码块 &gt;&gt;&gt; BlockTest 的主函数调用了  &gt;&gt;&gt; *         Phone 静态代码块 &gt;&gt;&gt;Phone 构造代码块 &gt;&gt;&gt;Phone 调用无参构造 *         Phone 构造代码块&gt;&gt;&gt;Phone 调用有参构造 */public class BlockTestDemo {    {        System.out.println(&quot;BlockTest 构造代码块&quot;);    }    static {        System.out.println(&quot;BlockTest 静态代码块&quot;);    }public static void main(String[] args) {    System.out.println(&quot;BlockTest 的主函数调用了&quot;);    Phone p = new Phone();    Phone p1 = new Phone();}}class Phone {    private String name;    private String prices;    {        System.out.println(&quot;Phone 构造代码块&quot;);    }    static {        System.out.println(&quot;Phone 静态代码块&quot;);//随着类的加载而加载    }    public Phone() {        System.out.println(&quot;Phone 调用无参构造&quot;);    }    public Phone(String name, String prices) {        System.out.println(&quot;Phone 调用有参构造&quot;);        this.name = name;        this.prices = prices;    }//    结果显示:    //    BlockTest 静态代码块//    BlockTest 的主函数调用了//    Phone 静态代码块//    Phone 构造代码块//    Phone 调用无参构造//    Phone 构造代码块//    Phone 调用无参构造}</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code class="java">/* * 继承: 多个类有共同的成员变量和方法, 抽取到另外一个类中(父类),   *         再让多个类去继承这个父类,  我们就可以获取得到父类的成员了. */public class ExtendsDemo {public static void main(String[] args) {    System.out.println(&quot;hello world&quot;);    Dota d = new Dota();    d.sart();    LOL l = new LOL();    l.sart();}}//抽取多个类的共性, 得到父类class Game {     String agend;     double version;     public void sart() {        System.out.println(&quot;游戏开始了&quot;);    }    public void end() {        System.out.println(&quot;游戏关闭了&quot;);    }}class Dota extends Game{/*     String agend;     double version;     public void sart() {        System.out.println(&quot;游戏开始了&quot;);    }    public void end() {        System.out.println(&quot;游戏关闭了&quot;);    }*/}class LOL extends Game{/*     String agend;     double version;     public void sart() {        System.out.println(&quot;游戏开始了&quot;);    }    public void end() {        System.out.println(&quot;游戏关闭了&quot;);    }*/}</code></pre><p> <strong>继承中的成员变量的特点</strong></p><pre><code class="java">/* *     super: 可以获取父类的成员变量和成员方法, 用法和this相同.  */public class ExtendsDemo_01 {public static void main(String[] args) {    System.out.println(&quot;hello world&quot;);    Child c = new Child();    c.show();}}class Dad {    String name = &quot;张三&quot;;}class Child extends Dad{    String name = &quot;张四&quot;;    void show() {        String name = &quot;张五&quot;;        System.out.println(super.name); //调用父类的成员变量        System.out.println(this.name);     //调用成员变量        System.out.println(name);//    就近原则:谁离我近就用谁    }}</code></pre><p><strong>继承中成员方法的特点</strong></p><p>重写和重载的区别</p><p><strong>继承中的构造方法的执行顺序</strong> </p><pre><code class="java">/* *     继承中构造方法的执行循序 *         在有子类继承关系的类中, 创建子类对象, 调用子类的构造方法, *         如果子类构造方法的第一行代码没有调用父类的构造方法, 则会默认的调用父类的无参构造. *     可以使用super()在子类构造方法的第一行中调用父类的构造方法 *     总结: *         始终都要调用父类的构造函数 */public class ExtedndsDemo {public static void main(String[] args) {    Child c = new Child();}}//运行结果:    //调用 父类无参构造    //调用 子类有参构造    //调用 子类无参构造class Dad {    public Dad() {        System.out.println(&quot;调用 父类无参构造&quot;);    }    public Dad(int num) {        System.out.println(&quot;调用 父类有参构造方法&quot;);    }}class Child extends Dad{    public Child() {        this(2); //调用子类的有参构造        System.out.println(&quot;调用 子类无参构造&quot;);    }    public Child(int num) {        //调用父类无参构造        System.out.println(&quot;调用 子类有参构造&quot;);    }}</code></pre><p>继承的优缺点</p><p>​    优点: 提高了代码的复用性, 代码的可维护性</p><p>​    缺点:类的耦合性增强了，　</p><p>​    开发原则：高内聚低耦合</p><p>​    内聚：就是自己完成某件事情的能力. </p><p>​    耦合：类与类的关系</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>​    </p><pre><code class="java">/* *     abstract 抽象类 *    抽象类不能实例化 *    抽象类有构造函数 * @Override *     在子类继承抽象类中, 需要重写抽象类的方法 */public class abstractDemo {public static void main(String[] args) {    Cat c = new Cat(&quot;Ruby&quot;, 10);    c.eat();    c.run();    Dog d = new Dog(&quot;Bruces&quot;, 7);    d.eat();    d.run();}}abstract class Animals {    String name;    int age;    public Animals(String name, int age) {        this.name = name;        this.age = age;    }    public abstract void eat(); //提供接口的功能    public void run() {        System.out.println(&quot;run&quot;);    }}class Cat extends Animals {    public Cat(String name, int age) {        super(name, age);    }    @Override    public void eat() {        System.out.println(&quot;The cat eats fishing.&quot;);    }}class Dog extends Animals {    public Dog(String name, int age) {        super(name, age);    }    @Override    public void eat() {        System.out.println(&quot;The dog eats food.&quot;);    }}</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code class="java">/* * Java语言是继承是单一继承, 一个子类只能有一个父类(一个儿子只能有一个亲爹) * Java语言给我们提供了一种机制,用于处理继承单一的局限性, 接口 *  *     接口: 接口是一个比抽象类还抽象的类, 接口里所有方法全是抽象方法, 接口和类的关系是implements(实现) *     interface  *  *     接口成员特点: *         只有抽象方法 *         只能有常量 *         默认和只能使用public abstract 修饰方法 *         默认使用 public static final 修饰变量 *     注意: *         接口不能创建对象(不能实例化) *         类与接口的关系是实现关系, 一个类的实现一个接口, 必须实现它所有的方法. *  *     类与类: 继承关系, 单一继承, 多层继承 *     类与接口: 实现关系, 多实现 *     接口与接口的关系: 继承关系, 多层继承 */public class interfaceDemo {public static void main(String[] args) {    Tiger t = new Tiger();    t.eat();    Demo d = new Demo();    d.function();    d.method();}}interface Animals {    public static final int age = 10;    public abstract void eat();}class Tiger implements Animals {    @Override    public void eat() {        System.out.println(&quot;eat&quot;);        }}//接口与接口的关系是单一继承interface interA {    public abstract void method();}interface interB extends interA{    public abstract void function();}//类与接口是实现关系, 多实现//每个接口都需要一个实现类, Demo是interA, interB的实现类class Demo implements interA, interB {    @Override    public void function() {    }    @Override    public void method() {        }}</code></pre><p>接口的优点:　</p><p>​    打破了继承的局限性，　</p><p>​    对外提供规则</p><p>​    降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发效率．　    </p><p>分析问题：</p><p>​    分析: 由下至上, 不断向上抽取的过程</p><p>​    实现: 由上至下, 先实现共性</p><p>​    使用: 使用具体的子类. </p><p>​    </p><pre><code class="java">/*    抽象类可以继承普通类*/class Person {    String name;    int age;    public void sleep() {        System.out.println(&quot;sleep&quot;);    }    public void eat() {        System.out.println(&quot;eat&quot;);    }}abstract class  Player extends Person{    public abstract void study();}</code></pre><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p>匿名对象: 没有名字的对象</p><p>应用场景：</p><p>​    当方法只调用一次的时候, 可使用匿名对象</p><p>​    可以当作参数进行传递</p><pre><code class="java">//普通创建对象 Student st =  new Student();//匿名对象 new Student() //匿名对象可以当作参数 function (new Studnet);</code></pre><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>​    自定义常量必须初始化, 可以选择显示初始化或者构造初始化</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><pre><code class="java">/* *    多态的前提: *        子父类的继承关系 *        方法的重写 *        父类引用指向子类对象 *    动态绑定: *        运行期间调用的方法,是根据具体类型. */public class Demo {public static void main(String[] args) {    System.out.println(&quot;hello world&quot;);    Animals a = new Cat(); //多态的实现    a.eat();}}class Animals{    public void eat() {        System.out.println(&quot;吃东西&quot;);    }}class Cat extends Animals {    //方法的重写    public void eat() {        System.out.println(&quot;猫吃鱼&quot;);    }}</code></pre><p>多态成员的特点:</p><pre><code class="java">/*成员变量: 编译时看的是左边, 运行时看的是左边  成员方法: 编译时看的是左边, 运行时看的是右边  静态防范: 编译时看的是左边, 运行时看的也是左边.  总结:      编译时看的都是左边，运行时成员方法看的是右边，其他（成员变量和静态方法)看的都是左边.*/ Dad d = new Kid();//左边是 Dad d//右边是 new Kid()</code></pre><p>多态中的向上转型和向下转型</p><pre><code class="java">Anmials a =new Dog(); //多态实现, 向上转型, 子类转化为父类Dog d = (Dog)a; //向下转型, 父类转化为子类</code></pre><p>多态的优缺点以及如何实现多态</p><pre><code class="java">/* *      多态的优缺点: *         优点: 可以提高可维护性(多态提前保证的), 提高代码的扩展性, *         缺点:无法直接访问子类特有的成员． */public class Demo02 {public static void main(String[] args) {    System.out.println(&quot;hello world&quot;);    PhoneFactory pf = new PhoneFactory();    //实现多态    pf.createPhone(new XiaoMi()); //调用匿名对象    pf.createPhone(new HongMi());}}//实现多态.class PhoneFactory {    //用父类对象作参数    public void createPhone(Phone p) {        p.create();    }}interface Phone {    public abstract void create();}class XiaoMi implements Phone {    @Override    public void create() {        System.out.println(&quot;小米手机&quot;);    }}class HongMi implements Phone{    @Override    public void create() {        System.out.println(&quot;红米手机&quot;);    }}</code></pre><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>​    public: 当前类, 相同包下不同的类, 不同包下的类 可以访问</p><p>​    default: 当前类, 相同包下的不同类    可以访问</p><p>​    private:当前类</p><p>​    protected: 当前类, 不同包下的类</p><p>​    default 和 protected 的区别:  </p><p>​        default: 当前包下使用</p><p>​        protected: 让子类对象使用</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>​    方法内部类</p><p>​    局部内部类</p><p>​    匿名内部类</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是依赖于集合的， 相当于集合的一个副本，当迭代器在操作的时候， 如果发现和集合不一样， 则抛出异常（并发修改异常）</p><p>foreach：增强for循环， 一般用于遍历集合或者数组。 </p><h3 id="List的常用子类"><a href="#List的常用子类" class="headerlink" title="List的常用子类"></a>List的常用子类</h3><p>​    ArrayList： 底层数据结构是数组， 查询快，增加删除慢</p><p>​    LinkedList： 底层数据结构是链表，查询慢， 增加删除块</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程的执行方式</p><pre><code class="java">/* * 多线程的实现方式： *     方式1：一种方法是将声明为Thread的子类。 该子类应重写Thread类的run方法，接下来可以分配并启动子类的实例。 *  * CPU执行程序的随机性 */public class Demo {public static void main(String[] args) {    myThread mt = new myThread();    mt.setName(&quot;Thread 1 &quot;);    mt.start();    myThread mt1 = new myThread();    mt1.setName(&quot;Thread 2 &quot;);    mt1.start();    myThread mt2 = new myThread();    mt2.setName(&quot;Thread 3 &quot;);    mt2.start();}}</code></pre><p>多线程出现数据访问问题：</p><pre><code class="java">/*        要有多个线程    要有被多个线程所共享的数据    多个线程并发的访问共享数据*/synchronized: 同步（锁）， 可以修饰代码块和方法， 被修饰和代码块和方法一旦被某个线程访问，则直接被锁住，其他线程无法访问。同步代码块：synchronized{        ......}同步方法：public synchronized void method();</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java中类名第一个字母都是大写的.&lt;/p&gt;
&lt;h3 id=&quot;常量分类&quot;&gt;&lt;a href=&quot;#常量分类&quot; class=&quot;headerlink&quot; title=&quot;常量分类:&quot;&gt;&lt;/a&gt;常量分类:&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;字符型常量: “HelloWorld”&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="编程" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="语言" scheme="https://www.daihuiyou.top/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>软考</title>
    <link href="https://www.daihuiyou.top/2018/10/03/%E8%BD%AF%E8%80%83/"/>
    <id>https://www.daihuiyou.top/2018/10/03/软考/</id>
    <published>2018-10-03T13:57:52.000Z</published>
    <updated>2018-11-09T06:14:36.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第-1-章-计算机系统基础知识"><a href="#第-1-章-计算机系统基础知识" class="headerlink" title="第 1 章 计算机系统基础知识"></a>第 1 章 计算机系统基础知识</h3><p>基本的计算机硬件系统由运算器, 控制器, 存储器, 输入设备和输出设备组成.</p><p>运算器和控制器以及其相关部件已被集成到一起, 统称为中央处理单元(CPU)</p><p>移码表示法: 是在数X上增加一个偏移量来定义的, 常用与表示浮点数中的阶码.</p><p><strong>移码</strong>:不管正负数, 只要将其补码的符号位取反即可. </p><p>例如：X=-101011 , [X]原= 10101011 ，[X]反=11010100，[X]补=11010101，[X]移=01010101</p><p>十进制数与字符的编码表示: 数值, 文字, 英文字母都被认为是字符, 任何字符进入计算机时, 都必须转换成二进制表示形式, 成为字符编码.</p><p>用4位二进制代码表示以为十进制数, 称为二-十进制编码, 简称BCD编码.  </p><p>直接存储器存取(Direct Memory Access, DMA) 方式的基本思想是通过硬件控制实现主存与I/O设备之间的直接数据传送. 数据的传送过程由 DMA 控制器( DMAC ) 进行控制, 不需要 CPU 的干预. </p><p>CPU 所能完成的操作是由其执行的指令决定的, 这些指令成为机器指令.  CPU 能执行的所有机器指令的集合称为该 CPU 的指令系统. 指令系统是计算机硬件与软件之间的接口. </p><p>指令是指挥计算机完成各种操作的基本命令. 一般来说, 一条指令包括两个基本组成部分: 操作码和地址码. </p><p><strong>操作码</strong>说明指令的功能机操作性质. </p><p><strong>地址码</strong>用来指出指令的操作对象, 它指出操作数或操作数的地址及指令结果的地址. </p><p>操作码用二进制编码来表示, 该字段越长, 所能表示的指令就越多. </p><p>寻址方式: 就是如何对指令中的地址字段进行解释, 以获得操作数的方法或获得程序转移地址的方法, 操作数的位置可能在指令中, 寄存器中, 存储中或 I/O 端口. 常用的寻址方式有立即寻址, 直接寻址, 寄存器寻址, 寄存器间接寻址等.  </p><p>磁盘存储器的主要技术指标：</p><p> 道密度：沿盘面半径方向单位长度内磁盘的数目，　单位是道/毫米</p><p> 位密度：磁道圆周上单位长度存储的二进制位的个数，单位是位/毫米</p><p> 存储容量：总的盘面数 x 每面的磁道数 x 每道扇区数 x 每个扇区存储的字节数。</p><p> 平均访问时间： 平均寻道（址）时间 +平均等待时间</p><p> 数据传输率： 单位时间内写入或读出的字节数。 数据传输率 = 每道扇区数 x 每个扇区包括的字节数 x 磁盘的转数</p><h3 id="第-2-章-操作系统基础知识"><a href="#第-2-章-操作系统基础知识" class="headerlink" title="第 2 章 操作系统基础知识"></a>第 2 章 操作系统基础知识</h3><p>操作系统是计算机系统中必不可少的核心系统软件, 其他软件的(编辑程序, 汇编乘车, 编译程序, 数据库管理程序等系统软件, 以及大量的应用的软件)是建立在操作系统的基础上的. </p><p>操作系统的作用是通过资源管理提高计算机系统的效率.</p><p>操作系统的 4 个特征是并发性, 共享性, 虚拟性和不确定性.  从资源管理的观点来看, 操作系统的功能可分为5大部分: 处理机管理, 文件管理, 存储管理, 设备管理和作业管理. </p><p>处理机管理, 实质上是对处理机的执行时间进行管理, 采用多道程序等技术将CPU 的时间合理地分配给每个任务. 主要包括进程控制, 进程同步, 进程通信和进程调度. </p><p>处理机管理也称为进程管理, 其核心是如何合理地分配处理机的时间, 提高系统的效率. 在计算机系统中有多个并发执行的程序, 采用 程序 这个静态概念已经不能描述程序执行时的动态变化过程, 所以引入了 进程 .</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="程序执行时的特征"><a href="#程序执行时的特征" class="headerlink" title="程序执行时的特征."></a>程序执行时的特征.</h4><p>进程 (Process) 是程序的一次执行. 进程通常有程序, 数据和进程控制模块 (Process Control Block, PCB ) 组成.  进程控制模块是进程存在的唯一标志. </p><p>进程的状态及其状态键的转换</p><p>三态模型, 在多道程序系统中, 进程的运行是走走停停的, 在处理器上交替运行, 状态也不断地发生变化, 因此一般有三种基本状态: 运行, 就绪和阻塞, 也成为三态模型. </p><ul><li>运行:　当一个进程在处理机上运行时，称为进程处理运行状态．显然，对于单处理机系统，处理运行状态的进程只有一个．　</li><li>就绪：一个进程获得了除处理机外的一切说需要的资源，一旦得到处理机即可运行，则称为进程处于就绪状态．</li><li><p>阻塞：也称为等待或睡眠状态，一个进程正在等待某一事件发生而暂时停止运行，　这时及时把处理机分配给进程，这时及时把处理机分配给该进程，他也无法运行，故称为该进程处于堵塞状态．　</p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ol><li>进程控制是对系统中所有进程从创建到消亡的全过程实施有效的控制．在操作系统中通过设置一套控制机构堆进程实施控制，其主要功能包括创建一个新进程，撤销一个已经运行完的进程，改变进程的状态，实现进程间的通信．进程控制是由操作系统内核中的原语实现的．　</li><li><p>原语是指由若干条机器指令组成，用于完成特定功能的程序段，　</p><h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h4></li><li><p>在多道程序环境的系统中，存在多个可并发执行的进程，因此进程间必然存在资源共享和相互合作的问题．进程通信是指各个进程交换信息的过程．　</p><ul><li>进程间的同步:是指进程间完成一项任务时直接发生相互作用的关系. </li><li>进程间的互斥: 在多道程序系统中, 各进程可以共享各类资源, 但有些资源一次只能供一个进程使用, 称为临界资源.  如打印机. 进程间的互斥是指系统中各进程互斥使用临界资源. </li><li>临界区是进程中对临界资源实施操作的那段程序.<ul><li>有空即进.</li><li>无空则等</li><li>有限等待</li><li>让权等待</li></ul></li><li>信号量机制: 是一种有效的进程同步与互斥工具.<ul><li>整形信号量与 PV 操作<ul><li>信号量是一个整形变量, 根据控制对象的不同被赋予不同的值. <ul><li>公用信号量. 实现进程间的互斥, 初值为 1 或资源的数目</li><li>私用信号量. 实现进程间的同步, 初值为 0 或某个正整数. </li></ul></li><li>信号量 S 的物理意义: 若 S &gt;= 0, 表示某资源的可用数; 若 S &lt;０，则其绝对值表示阻塞队列中等待该资源的进程数．　</li><li>对系统中的每个进程，其工作的正确与否不仅取决于它自身的正确性，而且与它在执行中能否与其他相关进程正确地实施同步互斥有关．　</li><li>PV 操作是实现进程同步与互斥的常用方法. P 操作和 V操作是低级通信原语, 在执行期间不可分割. 其中, P 操作表示申请一个资源, V 操作表示释放一个资源. </li></ul></li></ul></li><li>高级通信:<ul><li>为了提高通信效率, 能传递大量数据, 减轻程序的复杂度, 系统引入了高级通信方式. <ul><li>高级通信方式主要分为<ul><li>共享存储模式,  相互通信的进程共享某些数据结构 ( 或存储区), 实现进程之间的通信.</li><li>消息传递模式, 进程间的数据交换以消息为单位, 程序员直接利用系统提高的一组通信命令 (原语) 来实现通信. 如Send(A), Receive(A) </li><li>管道通信: 管道是用于连接一个读进程和一个写进程, 以实现它们之家你通信的共享文件 (pipe文件)，向管道提供输入的发送数据（即写进程), 以字符流的形式将大量的数据送入管道; 而接受进程可从管道接受大量的数据. </li></ul></li></ul></li></ul></li><li>直接和间接通信<ul><li>直接通信是将消息直接发送给制定进程.</li><li>间接通信是以信箱为媒体来是实现通信的, 接受信件的进程只需设疑一个信箱, 若干个进程都可以向同一个进程发送信件. </li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>​    进程调度方式是指当有更高优先级的进程到来时, 如何分配 CPU. 调度方式分为可剥夺和不可剥夺两种. </p></li></ol><ul><li>三级调度</li><li>调度算法:　常用的进程调度算法有先来先服务，　时间片轮转，　优先级调度和多级反馈调度算法．　</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ol><li>在计算机系统中有各种互斥资源(如磁带机, 打印机和绘图仪) 和 软件资源(如进程表, 临界区等),  若两个进程互相要求对方已占用的资源. <strong>所谓死锁, 是指两个以上的进程互相要求使用对方已经占有的资源而导致无法继续运行的现象.</strong></li><li>进程推进顺序不当, 同类资源分配不当, PV 操作使用不当等情况都可能造成死锁.</li></ol><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol><li><p>传统的进程有两个基本属性: 可拥有资源的独立单位, 可独立调度和分配的基本单位. 由于在进程的创建, 撤销和切换中, 系统必须为之付出较大的时空开销, 因此在系统中的设置的进程数目不宜过多, 进程切换不宜太高, 这就是限制了并发程度的提高. 引入了线程后, 将传统进程的两个基本属性分开, 线程作为调度和分配的基本单位, 进程作为独立分配资源的单位. 用户可以通过创建线程来完成任务, 以减少程序并发执行时付出的时空开销. </p><ol><li>进程: 资源分配的最小单位</li><li>线程: 程序执行的最小单位.</li><li>线程是进程中的一个实体, 是被系统独立分配和调度的基本的单位. 线程基本上不拥有资源, 只拥有一点运行中必不可少的资源. 它可与同属一个进程的其他线程共享进程所拥有的全部资源. </li></ol><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4></li><li><p>存储器管理的对象是(主存, 内存).  存储管理的主要功能包括分配和回收住存空间, 提高主存的利用率, 扩充主存, 对主存信息实现有效保护. </p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4></li><li><p>文件是就有符号名的, 在逻辑上具有完整意义的一组相关信息项的集合. </p><h3 id="第-3-章-数据库基础知识"><a href="#第-3-章-数据库基础知识" class="headerlink" title="第 3 章  数据库基础知识"></a>第 3 章  数据库基础知识</h3></li><li><p>文件系统是操作系统中的一个子系统, 它按一定的规则将数据组织成为一个文件, 应用程序通过文件系统堆文件的数据进行存取和加工. 文件系统对数据管理的, 实际上是通过应用程序和数据之间的一种接口实现. </p></li><li>文件系统的最大特点是解决了应用程序和数据之间的一个公共接口问题, 使得应用程序采用统一的存取方法来操作数据. </li><li>数据库系统是由计算机软件, 硬件资源组成的系统, 它实现了大量关联数据有组织地, 动态第存储, 方便用户访问. 它与文件系统的重要区别是数据的充分共享, 交叉访问, 与应用程序高度独立.</li><li><p>数据模型</p><ol><li>模型是对现实世界特征的模拟和抽象, 数据模型是对现实世界数据特征的抽象.</li></ol><h3 id="第-4-章-多媒体基础知识"><a href="#第-4-章-多媒体基础知识" class="headerlink" title="第 4 章 多媒体基础知识"></a>第 4 章 多媒体基础知识</h3><p>色调:指颜色的类别，　如红色，绿色和蓝色等不同颜色．</p></li></ol><h3 id="第-5-章-网络基础知识"><a href="#第-5-章-网络基础知识" class="headerlink" title="第 5 章 网络基础知识"></a>第 5 章 网络基础知识</h3><p>   数据在网络中是以”包”的形式传递, 但不同网络的”包”的格式不同. 因此, 在不同的网络间传送数据时, 就需要网络间的连接设备充当翻译工作. </p><p>   <strong>中继器</strong>: 可以”延长”网络的距离, 在网路传输中其到放大的作用.  数据经过中继器, 不需要进行数据包的转换. 中继器连接的两个网络在逻辑上是同一个网络. 中继器工作物理层, 对高层协议完全透明. </p><p>   <strong>集线器</strong>: 集线器是中继器的一种, 区别仅在于集线器能够提供更多的端口服务, 所有集线器又称多口中集器. 集线器主要用于优化网络布线结构, 简化网络管理.  集线器是对网络进行集中管理的最小单元, 只是分配带宽, 可以放大和中转信号.</p><p>   ​    使用集线器的优点是:当网络系统中某条线路或某结点出现故障时，　不会影响网上其他结点的正常工作，因为它提高了多通道的通信，大大提高了网络通信速度．　</p><p>   <strong>网桥</strong>：　当一个单位有多个LAN, 或一个LAN由于通信距离受限无法覆盖所有结点而不得不使用多个局域网时, 举要将这些局域网互联起来, 以实现局域网之间的通信. </p><p>   ​    使用网桥可扩展局域网的范围, 网桥的每个端口与一个网段(这里说所的网段就是普通局域网)相连.</p><p>   ​    网段:一般指一个计算机网络使用同一物理层设备，能够直接通信那那一部分．例如，从192.168.0.1到192.168.255.255这之间就是一个网段。</p><p>   <strong>交换机</strong>：</p><p>   ​    交换机提高了另一种提高数据传输速率的方法．</p><h3 id="第-7-章-软件工程基础知识"><a href="#第-7-章-软件工程基础知识" class="headerlink" title="第 7 章 软件工程基础知识"></a>第 7 章 软件工程基础知识</h3><p>   面向对象的基本概念</p><p>   １.对象</p><p>   ２.消息：对象之间进行通信的一种构造叫做信息。　当一个消息发送给某个对象时，包含要求接受对象去执行某些活动的信息。接受到信息的对象经过解释，然后给予响应。这种通信机制叫做消息传递。发送消息的对象不需要知道接受消息的对象如何响应应该请求。</p><p>   ３.类：一个类定义了一组大体上相似的对象。一个类所包含的方法和数据描述了一组对象的共同行为和属性。把一组对象的共同特征加以抽象并存在一个类中，而是面向对象技术最重要的一点，是否建立了一个丰富的类库，是衡量一个面向对象程序设计语言成熟与否的重要标志。　</p><p>   ４.继承：是父类和子类之间共享数据和方法的机制。</p><p>   ５.多态：对象收到消息时，要给予响应。不同的对象收到同一消息可以进行不同的响应，产生完全不同的结果，这种现象叫做多态。</p><p>   ６.动态绑定：绑定是一个把过程调用和响应调用需要执行的代码加以结合过程。</p><p>   软件测试的目的及原则</p><p>   ​    软件测试是为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试。</p><p>   ​    测试的目的就是希望能以最少的人力和时间发现潜在的各种错误和缺陷。</p><p>   维护：</p><p>   改正性维护是指诊断和改正在使用过程中发现的软件错误；</p><p>   适应性维护是值修改软件以适应环境的变化</p><p>   完善性维护是根据用户的要求改进或扩充软件是它更完善</p><p>   预防性维护是指修改软件为将来的维护活动预先做准备。</p><p>   常见的软件生存模型：</p><p>   瀑布模型：一个待开发的系统需求是完整的、简明的、一致的</p><p>   增量模型：假设将需求分段为一系列的增量产品。</p><p>   演化模型：针对事先不能完整定义需求的软件开发，是在一个快速开发的基础上，根据用户在使用模型的过程中提出的意见和建议对原型进行改进。</p><p>   螺旋模型：将瀑布模型和演化模型结合。 </p><p>   喷泉模型：</p><p>   软件过程：生产一个最终满足需求并且达到工程目标的团建产品所需的步骤。过程是活动的集合，活动是任务的集合。</p><p>   软件能力成熟度模型：CMM。</p><p>   CMM将软件过程改进分为5个成熟度： 初始级，可重复级，已定义级，已管理级，优化级。</p><p>   软件调试：试探发， 回溯法，对分查找法，归纳法，演绎法</p><h3 id="第-8-章-数据结构与算法"><a href="#第-8-章-数据结构与算法" class="headerlink" title="第 8 章 数据结构与算法"></a>第 8 章 数据结构与算法</h3><p>   ​    数据结构是指数据元素的集合及元素间的相互关系的构造方法。</p><p>   ​    矩阵是很多科学与工程计算领域研究的数学对象。在数据结构中主要讨论如何在尽可能节省存储空间的情况下，使矩阵的各种运算能搞笑地运行。</p><h3 id="第-12-章-Java-程序设计语言"><a href="#第-12-章-Java-程序设计语言" class="headerlink" title="第 12 章 Java 程序设计语言"></a>第 12 章 Java 程序设计语言</h3><pre><code class="java">   /*       这里将main方法定义公共方法的目的是为了让Java解释器能够调用此方法       而定义为静态static，因为调用main方法的时候还不存在任何对象，main方法只能属于类，而不能和对象相关联。   */   public class Demo {       public static void main(String[] args) {       }   }</code></pre><p>   <strong>StringBuffer 字符串</strong>：</p><p>   类StringBuffer的对象也表示字符串，与String不同的是， StringBuffer是线程安全的可变的字符序列， StringBuffer对象引用的字符串能够通过特定的方法调用被直接修改。</p><p>   <strong>StringBuilder 字符串</strong></p><p>   ​    StringBuilder 是 Java1.5引入的一个可变的字符序列，提供了和 StringBuffer 相同的API， 但是不保证同步（非线程安全），<strong>在只有一个线程时替代 StringBuffer 使用</strong>。 StringBuilder  的大多数实现要比 StringBuffer快速， 推荐优先使用  StringBuilder  。</p><p>   Java程序中不需要明确删除一个对象，因为Java有自动的垃圾回收机制。 当一个对象没有任何变量引用时， 该对象的生存期结束，其存储空间由系统自动回收。</p><p>   <strong>包：</strong></p><p>   ​    定义包： package</p><p>   ​    引入包： import来引入包</p><p>   <strong>注解@override 表示子类 getValue() 是覆盖了父类的 getValue()</strong>， 如果程序员不小心拼写错误， 或者方法签名对不上被覆盖的方法， 编译器就会发生错误提示。</p><p>   <strong>接口</strong>： 也是实现代码重用的一种方式， Java不支持多重继承， 接口是顺应多重继承的需要的而产生的， 以另一种方式实现多重继承，<strong>接口实际是一组抽象方法和常量的集合。</strong></p><p>   <strong>异常</strong>： </p><p>   ​    异常分为两种： Error 和 Exception。 编程程序时应该考虑异常的产生和处理。 通常， 程序不需处理 Error 类型的异常， 但是应关注 Exception 类型的异常。</p><p>   <strong>文件输入、输出和流</strong></p><p>   ​    一个流是一个输入设备或输出设备的抽象表示， 一般分为字符流和字节流。 </p><p>   <strong>字节流</strong>：字节流处理单元为8位的字节，数据源中如何含有非字符数据的二进制的数据，如音频，图片，歌曲文件等， 就是字节流来处理输入/输出。 所有的字节流都是抽象基类 InputStream 或者 OutputStream 的子类， 这两个类是<strong>抽象</strong>的， 不能直接创建其对象来创建一个流， 而要通过他们的子类来创建一个流。</p><p>   <strong>集合类</strong>：Java提供了容纳对象（或者对象的句柄）的多种形式，以设计好的类库形式提供了读数据进行有效管理的数据结构和算法， 如链表、二叉树、栈和散列表等。</p><p>   Java集合框架分为集合和映射两组， 分别从两个基本接口继承而来： Collection 和  Map， 他们是相互独立的， 包含了常用的数据结构</p><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><h3 id="第-1-章"><a href="#第-1-章" class="headerlink" title="第 1 章"></a>第 1 章</h3><p>   CPU包括运算器，控制器，寄存器三大部分。</p><p>   时钟周期是最基本，最小的时间单位。指令周期 &gt; 机器周期 &gt; 时钟周期</p><p>   海明码是利用奇偶性来检错和纠错的校验方法。</p><p>   在同一时间处理二进制数的位数称为字长。通常称处理字长为8位数据的CPU为8位CPU。</p><p>   光盘格式中，不能多次擦除重写数据的是 CD-R</p><p>   地址总线的宽度决定了CPU可以访问的物理地址空间，简单地说就说CPU到底能够使用多大容量的内存。</p><p>   在微型计算中，通常用主频来描述CPU的运算速度；对计算机磁盘工作影响最小的因素是噪声。</p><p>   CPU执行算术运算或者逻辑运算时，算术运算部件(ALU)将计算结果保存在累加器AC中。</p><p>   PCI 是系统总线， USB 是串行总线， IEEE-1394也是高速串行接口标准， IEEE-488是并行外部总线。</p><p>   若指令系统中设置了专用I/0操作指令，则I/0接口可以独立编址。</p><h3 id="第-2-章"><a href="#第-2-章" class="headerlink" title="第 2 章"></a>第 2 章</h3><p>   操作系统的定义</p><p>   操作系统的作用</p><p>   操作系统的特征：并发性，共享性，虚拟性和不确定性， 4个基本特征。虚拟性是操作系统的重要特征，所谓虚拟是把物理上的一台设备变成逻辑上的多台设备。 不确定性：通常一个程序的初始条件相同时，无论何时运行，结构都应该相同。但由于操作系统并发执行系统内的各种进程。</p><p>   操作系统的功能：</p><p>   ​    1.处理机管理负责解决如何把CPU时间合理地、动态地分配给程序运行的基本单位–进程，是处理机得到充分利用。</p><p>   ​    2.存储管理：存储器是运行程序或存放工作数据的部件，存储管理的工作的主要是对内存存储器进行分配，扩充和保护。</p><p>   ​    3.设备管理</p><p>   ​    4.文件管理</p><p>   存储器的功能是保存数据</p><p>   虚拟地址：数据的存放地址是友符号决定的， 故又称为符号名地址，或者成为名地址。</p><p>   地址重定位：是指程序的逻辑地址转换成主存的物理地址的过程。在可执行文件装入时需要解决可执行文件中的地址和主存地址的对应关系。</p><p>   存储管理：分区存储管理，分页存储管理，分段存储管理，段页式存储管理和虚拟存储管理、其中存储管理是把主存中的用户区划分成若干个区域，每个区域分配給一个用户作用使用，并限定他们只能在自己的区域运行。按划分的不同方式，可分为固定分区，可变分区和重定位分区。</p><p>   分页式存储管理： </p><p>   ​    分页管理：将一个进程的地址空间划分为若干个大小相等的区域，称为页。相应的，将内存空间划分成与页相同的大小的物理块，成为块或页框。</p><p>   分段存储管理：</p><p>   ​    作业的地址空间被划分成若干个段，每个段是一组完整的逻辑信息，如有主程序段，子程序段，数据段和堆栈段等，每个段都有自己的名字，都是从0开始编址的一段连续的地址空间，各段的长度是不等的。</p><p>   虚拟存储器管理：</p><p>   ​    存储管理策略的基础是局部原理——进程往往会不均匀地，高度局部化地访问主存。</p><p>   ​    虚拟存储器的定义：一个作业在运行之前，没必要全部装入内存中，而仅将当前要运行的那部分分页面或段先装入主存启动运行，其余部分暂时时留在磁盘上。</p><p>   虚拟存储器具有请求调入功能和置换功能，仅能把作业的一部分装入内存便可运行作业的存储器系统，能从逻辑上对主存容量进行扩充。</p><p>   设备管理：</p><p>   ​    DMA 技术：在外围设备和主存之间开辟直接的数据交换通路。在内存与输入/输出设备间传送一个数据块的过程中，不需要CPU的任何干涉，只需要CPU在过程中开始启动和过程结束时处理，实际操作由DMA硬件直接执行完成。</p><p>   ​    缓冲技术：硬件缓冲是利用专门的硬件寄存器作为缓冲区；软件缓冲是利用操作系统的管理，用主存中一个或多个区域作为缓冲区，进而可以形成缓冲池。</p><p>   磁盘调度： 对磁盘的存储访问一般要有三部分时间。 首先要将磁头移动到相应的磁道或柱面上，这个时间叫做寻寻道时间。信息在磁盘和内存之间的实际传送时间叫做传送时间。磁盘调度的目的是平均寻道时间最少。</p><p>   数据库概念模式：是数据库中全部数据的逻辑结构和特征的描述，由若干个概念记录类型组成。</p><p>   外模型：是用户与数据库系统的接口</p><h3 id="软件工程基础知识"><a href="#软件工程基础知识" class="headerlink" title="软件工程基础知识"></a>软件工程基础知识</h3><p>   风险分析：风险控制，风险预测，风险控制。风险回避，损失控制，风险转移和风险保留。</p><p>   常见的生命周期模型：</p><p>   软件生命周期六个阶段：问题的定义及规划，需求分析，软件设计，程序编码，软件测试，运行维护</p><p>   软件工具：软件开发工具， 软件维护工具， 软件管理和软件支持工具。 </p><p>   UML图：统一建模语言是用来对软件密集系统进行可视化建模的一种语言。 </p><p>   UML图：用例图，静态图，行为图，状态图，交互图，实现图。</p><p>   类之中的关系：UML中规定，类中共有4中基本关系：依赖， 关联，泛化，实现。</p><p>   面向对象分析模型5个层次：主题层，对象类层，结构层， 属性层和服务层。 </p><p>   结构化设计方法：是一种面向数据流的方法</p><p>   相对对象建模得到的模型包含对象的三个要素：静态结构，交互次序和数据交互。</p><p>   面向对象设计原则：封装，信息隐蔽，高内聚，低耦合。</p><p>   耦合关系</p><ol><li>内容耦合：一组模块都访问同一个公共数据环境。</li><li>外部耦合：一组模块都访问同一个全局简单变量而不是同一全局数据结构。</li><li>控制耦合：一个模块把控制信息传递给另一个模块，对其功能进行控制。</li><li>标志耦合：一组模块通过参数传递记录信息，这组模块就是标记模块，注释：事实上模块共享了某一数据结构的子结构，而不是简单的变量。</li><li>数据耦合：一个模块访问另一个模块彼此之间通过数据参数来交换输入，输出信息。</li><li>非直接耦合：两个模块之间没有直接关系，它们间的联系完全通过主模块的控制和调用来实现的。</li></ol><p>   软件质量管理和质量保证</p><p>   ​    功能性、可靠性、易用性、效率、可维护性、可移植性。这六中质量特性都由质量特性（第一层6个），子特性（第二次21个）和度量 三个层次组成。 </p><p>   测试分类：</p><p>   ​    黑盒测试：是一种功能测试，就是将被测试系统看成一个黑盒，单纯从外界取得输入后进行输出。</p><p>   ​    白盒测试：逻辑测试，也叫结构测试，它把程序看成白盒，即测试时了解被测对象的内部逻辑结构，并且以程序内部的设计结构及具体的代码实现为基础来设计测试用例。</p><p>   软甲测试分四步：</p><p>   ​    单元测试，集成测试，系统测试，确认测试。</p><p>   软件工程是计算机软件的一个重要的分支和研究方向。</p><p>   软件生存周期：可行性分析和项目开发计划，需求分析，软件设计，编码，测试和维护6个阶段。</p><p>   软件开发项目管理是指在软件生存周期中软件管理者所今进行的一系列活动，是软件系统或软件产品按原定的计划和质量要求如期完成。 </p><p>   软件开发项目管理：进度管理，成本管理，质量管理，人员管理，资源管理，标准化管理。 </p><p>   成本估算，风险分析，进度管理，人员管理。</p><p>   风向分析的主要活动有风险识别，风险估算，风险管理策略，风险解决和风险监督。</p><p>   面向对象 = 对象 + 分类 + 继承 + 通过消息的通信</p><p>   多态是指同一个操作作用于不同的对象可以有不同的解释，产生不同的执行结果。</p><p>   与多态密切相关的一个概念是动态绑定，传统的程序设计语言，把过程调用与目标代码的连接放在程序运行前进行，而动态绑定则是把这种连接推辞到运行时才进行。</p><p>   软件测试方法：</p><ol><li>静态测试又称为代码审查。通过对程序静态结构的检查，找出编译时不能发现的错误。</li><li><p>动态测试：</p><ol><li>白盒测试：完全了解程序的内部结构和处理过程，它，根据程序的内部逻辑来设计程序用例，检查程序的逻辑通路是否都按预订的要求正确地工作。</li><li>黑盒测试：完全不考虑程序的内部结构和处理过程，而只是测试软件的外部特性。 </li></ol><p>软件测试的主要过程：</p></li><li><p>单元测试，也称为模块测试，通常采用白盒测试</p></li><li>组装测试，也称为集成测试，它是由各模块组装而成的程序进行测试，主要检查模块间的接口和通信。通常采用黑盒测试。</li><li>确认测试，检查软件的功能，性能以及其他特征是否与用户的需求一致。通常采用黑盒测试</li><li><p>系统测试：和其他因素结合在一起，进行信息系统的各种组装测试的确认测试，主要目的是通过与系统的需求相比较，来发现所开发的系统与用户需求不符合和矛盾的地方。</p><p>软件调试： 试探法，回溯法，对分查找法，归纳法，演绎法。</p><p>软件测试的目的及原则，软件测试是发现软件中错误和缺陷的主要手段。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第-1-章-计算机系统基础知识&quot;&gt;&lt;a href=&quot;#第-1-章-计算机系统基础知识&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 计算机系统基础知识&quot;&gt;&lt;/a&gt;第 1 章 计算机系统基础知识&lt;/h3&gt;&lt;p&gt;基本的计算机硬件系统由运算器, 控制
      
    
    </summary>
    
      <category term="考试" scheme="https://www.daihuiyou.top/categories/%E8%80%83%E8%AF%95/"/>
    
    
      <category term="考试" scheme="https://www.daihuiyou.top/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="https://www.daihuiyou.top/2018/08/28/markdown%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://www.daihuiyou.top/2018/08/28/markdown使用总结/</id>
    <published>2018-08-28T08:09:25.000Z</published>
    <updated>2018-11-09T06:13:21.596Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>换行：<br>1.方法1： 连续两个以上空格+回车。  </p></li><li><p>首行缩进两个字符：（每个表示一个空格，连续使用两个即可）</p><pre><code>  1.&amp;ensp;半角的空格  </code></pre><p>  ​    2.&emsp;全角的空格</p></li><li><p>字体、字号、颜色</p><pre><code>  - &lt;font color=red&gt;red&lt;/font&gt;  - &lt;font color=blue&gt;blue&lt;/font&gt;  - &lt;font color=green&gt;green&lt;/font&gt;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;换行：&lt;br&gt;1.方法1： 连续两个以上空格+回车。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;首行缩进两个字符：（每个表示一个空格，连续使用两个即可）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1.&amp;amp;ensp;半角的空格  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.daihuiyou.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>clovers</title>
    <link href="https://www.daihuiyou.top/2018/08/28/clover/"/>
    <id>https://www.daihuiyou.top/2018/08/28/clover/</id>
    <published>2018-08-28T07:38:38.000Z</published>
    <updated>2018-11-09T06:12:27.590Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/DQ79vXy.png" alt=""></p><p><strong>快捷键技巧：</strong></p><font color="red"><br>Ctrl+W关闭页面<br><br>Ctrl+Tab切换页面<br></font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DQ79vXy.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快捷键技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;font color=&quot;red&quot;&gt;&lt;br&gt;Ctrl+W关闭页面&lt;br&gt;&lt;br&gt;Ctrl+Tab切换页
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="clovers" scheme="https://www.daihuiyou.top/tags/clovers/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://www.daihuiyou.top/2018/08/28/Git/"/>
    <id>https://www.daihuiyou.top/2018/08/28/Git/</id>
    <published>2018-08-28T07:35:41.000Z</published>
    <updated>2018-11-09T06:13:12.598Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub基本概念"><a href="#GitHub基本概念" class="headerlink" title="GitHub基本概念"></a>GitHub基本概念</h3><ul><li><strong><em>Repository</em></strong>： 开源项目</li><li><strong><em>Issue</em></strong>： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个<strong><em>Issue</em></strong> ，然后这些问题逐个去修复，即一个一个<strong><em>Close</em></strong>掉。</li><li><strong><em>Star</em></strong>：关注</li><li><strong><em>Fork</em></strong>：引用别人的开源项目</li><li><strong><em>Pull Request</em></strong>：在<strong><em>Fork</em></strong>的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 <strong><em>review</em></strong>, 就接受你的<strong><em>Pull Request</em></strong>。</li><li><strong><em>Watch</em></strong>： <strong><em>Watch</em></strong>了该项目，它的任何更新消息，会通知你。</li><li><strong><em>Gist</em></strong>： 单纯分享代码段。</li></ul><h3 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h3><p>ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。  </p><p>将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。</p><h3 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h3><p>git push origin master : 把本地代码推到远程master分支。  </p><p>git pull origin master : 远程master的最新代码拉下来。</p><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:stromzhang/test.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。  </p><p>在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里  </p><pre><code>git config -global user.name &quot;stromzhang&quot;  git config -global user.eamil &quot;stromzhang.dev@gmail.com&quot;</code></pre><p> <strong><em>Pull requests</em></strong>： 我们每个人都可以一起参与开发，一起来完善，而这都通过<strong><em>Pull requestss</em></strong>来完成。  </p><ul><li><strong><em>fork</em></strong> 他人项目</li><li><strong><em>git clone</em></strong> （fork 来项目）</li><li>在本地，自己修改这个项目</li><li><strong><em>git push</em></strong> 到自己远程仓库</li><li><strong><em>Pull requests</em></strong> 到 他人项目上</li><li>他人 <strong><em>reviews</em></strong> 你在他项目修改什么， 并觉得合理， 就接受你的PR。</li><li>完成这个项目的贡献。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;GitHub基本概念&quot;&gt;&lt;a href=&quot;#GitHub基本概念&quot; class=&quot;headerlink&quot; title=&quot;GitHub基本概念&quot;&gt;&lt;/a&gt;GitHub基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Repository&lt;/em&gt;&lt;/str
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.daihuiyou.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>知道自己不知道的</title>
    <link href="https://www.daihuiyou.top/2018/08/28/%E7%9F%A5%E9%81%93%E8%87%AA%E5%B7%B1%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84/"/>
    <id>https://www.daihuiyou.top/2018/08/28/知道自己不知道的/</id>
    <published>2018-08-28T04:55:17.000Z</published>
    <updated>2018-11-09T06:07:21.896Z</updated>
    
    <content type="html"><![CDATA[<h3 id="入门篇："><a href="#入门篇：" class="headerlink" title="入门篇："></a>入门篇：</h3><ol><li>python 和 java Script 选择 入门语言</li><li>学习使用操作系统linux </li><li>学习使用编程工具 vs 和 vs code</li></ol><h3 id="正式入门"><a href="#正式入门" class="headerlink" title="正式入门"></a>正式入门</h3><ul><li>推荐文章： <strong><em>The Key To Accelerating Your Coding Skills</em></strong></li><li>编程技巧方面：怎么把程序写好的书（代码大全）。</li><li>java语言学习：Java核心技术卷一，</li><li>spring: spring in action</li><li>操作系统：鸟哥的Linux私房菜</li><li>网络协议：HTTPS文档，</li><li>数据库设计：慕课网 数据库设计那些事</li><li>数据库：MySQL必知必会</li><li>前端方面：</li><li>编码方面：ASCII, UNICODE, </li><li>编程工具方面：JAVA VS CODE</li><li>版本管理工具：GIT,</li><li>调试前端工具：</li><li>数据库设计工具：</li></ul><ol><li>java语言 综合性实力最强</li><li>IDE</li><li>版本管理工具 git </li><li>调试前端工具</li><li>数据库设计工具</li></ol><h3 id="程序员修养"><a href="#程序员修养" class="headerlink" title="程序员修养"></a>程序员修养</h3><ol><li>英文能力</li><li>问问题的能力</li><li>写代码的修养</li><li>安全防范意识</li><li>软件工程和上线规范</li><li>编程规范</li></ol><h3 id="专业技术篇"><a href="#专业技术篇" class="headerlink" title="专业技术篇"></a>专业技术篇</h3><ol><li>编程语言: c, c++, java</li><li>理论学科: 算法与数据结构，网络模型，计算机原理，操作系统原理，编译原理，数据库原理。（工人和工程师的差别）</li><li>系统知识：Unix, Linux, TCP/IP, C10K</li><li>从业方向：底层，大数据，分布式开发等等。</li></ol><h3 id="软件设计能力"><a href="#软件设计能力" class="headerlink" title="软件设计能力"></a>软件设计能力</h3><p>&emsp;&emsp;<strong>工程师走向架构师</strong></p><h3 id="程序员荒谬之言还是至理名言"><a href="#程序员荒谬之言还是至理名言" class="headerlink" title="程序员荒谬之言还是至理名言"></a>程序员荒谬之言还是至理名言</h3><ol><li>如果你把一个技术搞精搞深，你的知识面自然会很广的。</li><li>面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会（依据自己兴趣学习）</li><li>为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。</li><li>不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。</li><li>永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。<font color="red">（特别赞同）</font></li></ol><h3 id="Teach-Yourself-Programming-in-Ten-Years——用十年教会自己编程"><a href="#Teach-Yourself-Programming-in-Ten-Years——用十年教会自己编程" class="headerlink" title="Teach Yourself Programming in Ten Years——用十年教会自己编程"></a>Teach Yourself Programming in Ten Years——用十年教会自己编程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;入门篇：&quot;&gt;&lt;a href=&quot;#入门篇：&quot; class=&quot;headerlink&quot; title=&quot;入门篇：&quot;&gt;&lt;/a&gt;入门篇：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;python 和 java Script 选择 入门语言&lt;/li&gt;
&lt;li&gt;学习使用操作系统linux &lt;/li
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="系统知识" scheme="https://www.daihuiyou.top/tags/%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>学会提问</title>
    <link href="https://www.daihuiyou.top/2018/08/21/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE/"/>
    <id>https://www.daihuiyou.top/2018/08/21/学会提问/</id>
    <published>2018-08-21T04:19:37.000Z</published>
    <updated>2018-11-09T06:07:44.765Z</updated>
    
    <content type="html"><![CDATA[<p>日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。</p><p>但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 </p><p>看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。</p><h3 id="读书摘抄"><a href="#读书摘抄" class="headerlink" title="读书摘抄"></a>读书摘抄</h3><p><strong>价值观</strong>：  </p><ol><li>苏格拉底说过的话:”我唯一所知的就是我一无所知。”  </li><li>找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。</li></ol><p>关键问题：论题和结论。</p><p>没有把证据支撑的断言称为纯观点。</p><p>写作建议：在写作之前最好确定好论题，引导读者得出你的结论</p><p>如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。  </p><p>一个论证的表面结构由理由和结论两部分组成。</p><p>我们把没有明说出来的想法成为假设。</p><p>先检查理由，然后检查结论，寻找价值观假设和描述性假设。  </p><p>假设越可疑，推理和结论的相关程度也就越小。</p><p>用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。</p><p>单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。</p><ul><li>价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。  </li><li>价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。</li><li>谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。</li><li>过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。  </li><li>以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。</li><li>循环论证谬误指在推理过程中已然假设自己的结论成立的论证。</li><li>人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。&lt;/p&gt;
&lt;p&gt;但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="摘抄" scheme="https://www.daihuiyou.top/tags/%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建流程</title>
    <link href="https://www.daihuiyou.top/2018/08/20/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.daihuiyou.top/2018/08/20/hexo博客搭建流程/</id>
    <published>2018-08-20T06:03:47.000Z</published>
    <updated>2018-11-09T06:12:02.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录总体的搭建流程"><a href="#记录总体的搭建流程" class="headerlink" title="记录总体的搭建流程"></a>记录总体的搭建流程</h2><ol><li>搭建Node.js环境：命令行使用<strong>node -v</strong>查看版本。</li><li>安装Hexo博客框架：<strong>npm install hexo-cli -g</strong></li><li><strong>安装git, git同步在github上</strong>。</li><li>开启GitHub Pages服务： <strong>注意要选择主题，才有效。</strong></li><li>创建文件夹，存放博客文件： hexo init  myHexoBlog   </li><li>hexo g  //g是generetor的缩写，生成博客</li><li>hexo s  //s是server的缩写，启动服务</li><li><strong>hexo与github关联起来</strong></li><li>绑定域名</li><li>更换主题</li></ol><hr><h2 id="安装git-git同步在github上"><a href="#安装git-git同步在github上" class="headerlink" title="安装git, git同步在github上"></a>安装git, git同步在github上</h2><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><ol><li><strong>生成ssh密钥文件：</strong>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</li><li>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</li><li>打开GitHub_Settings_keys 页面，新建new SSH Key</li><li>在Git Bash中检测GitHub公钥设置是否成功，输入 <strong>ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> </strong></li></ol><hr><h2 id="hexo与github关联起来：打开站点的配置文件-config-yml"><a href="#hexo与github关联起来：打开站点的配置文件-config-yml" class="headerlink" title="hexo与github关联起来：打开站点的配置文件_config.yml"></a>hexo与github关联起来：打开站点的配置文件_config.yml</h2><pre><code>deploy:      type: git      repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git      branch: master</code></pre><hr><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><pre><code>ping www.daihuiyou.github.io #得到IP值</code></pre><p> 第一步：在阿里云解析服务： 填写</p><pre><code>主机记录www对应 daihuiyou.github.io主机记录@对应 www.daihuiyou.github.io主机记录www对应 185.199.111.153主机记录@对应 185.199.111.153</code></pre><p> 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top</p><p> 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top</p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>待更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录总体的搭建流程&quot;&gt;&lt;a href=&quot;#记录总体的搭建流程&quot; class=&quot;headerlink&quot; title=&quot;记录总体的搭建流程&quot;&gt;&lt;/a&gt;记录总体的搭建流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;搭建Node.js环境：命令行使用&lt;strong&gt;node -v&lt;/st
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="博客" scheme="https://www.daihuiyou.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://www.daihuiyou.top/2018/08/19/My-New-Post/"/>
    <id>https://www.daihuiyou.top/2018/08/19/My-New-Post/</id>
    <published>2018-08-18T16:06:36.000Z</published>
    <updated>2018-11-09T06:11:44.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Have-a-good-day"><a href="#Have-a-good-day" class="headerlink" title="Have a good day!"></a>Have a good day!</h4><h4 id="Cease-to-struggle-and-you-cease-to-live"><a href="#Cease-to-struggle-and-you-cease-to-live" class="headerlink" title="Cease to struggle and you cease to live."></a>Cease to struggle and you cease to live.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Have-a-good-day&quot;&gt;&lt;a href=&quot;#Have-a-good-day&quot; class=&quot;headerlink&quot; title=&quot;Have a good day!&quot;&gt;&lt;/a&gt;Have a good day!&lt;/h4&gt;&lt;h4 id=&quot;Cease-to-st
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="the first post." scheme="https://www.daihuiyou.top/tags/the-first-post/"/>
    
  </entry>
  
</feed>
