<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Will&#39;s notebook</title>
  
  <subtitle>Share My Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.daihuiyou.top/"/>
  <updated>2019-06-18T02:46:17.127Z</updated>
  <id>https://www.daihuiyou.top/</id>
  
  <author>
    <name>Will</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件工程之美</title>
    <link href="https://www.daihuiyou.top/2019/06/09/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    <id>https://www.daihuiyou.top/2019/06/09/软件工程之美/</id>
    <published>2019-06-09T14:56:51.000Z</published>
    <updated>2019-06-18T02:46:17.127Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是软件？"><a href="#什么是软件？" class="headerlink" title="什么是软件？"></a>什么是软件？</h3><p>软件的目标用户是面向用户，然而程序是面向硬件的。</p><h3 id="看待问题的角度"><a href="#看待问题的角度" class="headerlink" title="看待问题的角度"></a>看待问题的角度</h3><p>很多时候， 自己在分析问题时往往陷入细节中， 并不能迅速想出解决方案。</p><p>类似写作，并不是确定好一个题目， 自己想到哪，写到哪， 往往结果是离题了。好的做法应该是：确定好题目，确定好架构（即你要写的大概的内容），架构好了，最后去写就是了。</p><p>当用工程方式去思考，会更多站在整体而非局部去思考， 更有大局观。</p><p>everthing is project。 </p><h3 id="会议的价值"><a href="#会议的价值" class="headerlink" title="会议的价值"></a>会议的价值</h3><p><strong><em>你是砍材的，他是放羊的，你和他聊一天，他的羊吃饱了，你的材呢？</em></strong></p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>在编写自己的函数时，仅仅假设一个特定样本数据的输入， 并满足该函数的输出要求，就马不停蹄实现下一个函数的定义。 完全没有考虑这函数的健壮性，即没有足够的样本数据进行单元测试， 这样的函数犹如建房子的砖瓦「够用就行」。</p><p><img src="https://github.com/DaiHuiYou/Material/blob/master/pic/software.png?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://www.daihuiyou.top/2019/06/06/leetcode/"/>
    <id>https://www.daihuiyou.top/2019/06/06/leetcode/</id>
    <published>2019-06-06T14:25:18.000Z</published>
    <updated>2019-06-18T03:21:32.564Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><hr><ul><li>算法 sort() 时间复杂度</li></ul><p>Sort() 因为它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高！</p><p>果断放弃的自己造轮子， 来实现 时间复杂度为 O(n^2) 的冒泡或者选择算法。 ^_^</p><ul><li>list.sort()</li></ul><p>list::iterator it  没有重载 + 运算符，不能 it+5,  只能 it++;</p><p>由于算法 sort() 支持随机访问的容器, 即需要满足 it+5类似的操作。所以在list中另外实现成员函数sort() 。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><hr><ul><li><strong>unordered_map</strong></li></ul><p>在 unordered_map 中，键值通常用于唯一标识元素，而映射值是与该键关联的内容的对象。键和映射值的类型可能不同。</p><p>在内部，unordered_map 中的元素<strong>没有按照它们的键值或映射值的任何顺序排序</strong>，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</p><p>unordered_map 容器比映射容器更快地通过它们的键来访问各个元素，尽管它们通过其元素的子集进行范围迭代通常效率较低。</p><p>关键词：无序的 快速的检索 达到的是更快的访问 但是子集的范围迭代效率低。</p><h3 id="vector-and-deque"><a href="#vector-and-deque" class="headerlink" title="vector  and deque"></a>vector  and deque</h3><hr><ul><li>都为动态数组，支持随机存取,  具有自动增长空间。 </li><li>deque 区别与 vector： deque 在头尾都支持插入和弹出。 而 vector 只能在尾部插入和弹出。</li></ul><h3 id="stack-and-queue"><a href="#stack-and-queue" class="headerlink" title="stack and queue"></a>stack and queue</h3><hr><p>stack 不支持<strong>随机存取</strong>（没有 [] operator 重载），<strong>不能遍历</strong>（没有迭代器），只能通过栈顶获取元素和删除元素。</p><p>queue 不能进行遍历， 不支持随机存取； 一端插入，另一端删除。</p><h3 id="vector-lt-vector-gt"><a href="#vector-lt-vector-gt" class="headerlink" title="vector&lt;vector\&gt;"></a>vector&lt;vector\<int>&gt;</int></h3><hr><p><strong>1. vector&lt;vector\&lt;int>&gt; v;</strong></p><p> 由于vector对 []operator 进行重载, 可以采用 v[i][j]</p><ul><li>[i] 表示获取一个为vector的元素；</li><li>[j] 在vector中，获取一个int的值。</li></ul><p><strong>2. vector&lt;stack\<int>&gt; vs;</int></strong></p><p> 由于stack 不对 []operator 进行重载， vs[i][j] 为错误写法。</p><h3 id="运算溢出"><a href="#运算溢出" class="headerlink" title="运算溢出"></a>运算溢出</h3><hr><ul><li>防止数据溢出</li></ul><pre><code class="c++">int res = 100000000;int num = 0;int pop;if(num&lt;INT_MAX/10)    num = num*10 + pop;else if(num==INT_MAX &amp;&amp; pop&lt;7)    num = num*10 + pop;else if(num&lt;INT_MIN/10)    num = num*10 - pop;else if(num==INT_MIN/10 &amp;&amp; pop&lt;8)    num = num*10 - pop;else ;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OS</title>
    <link href="https://www.daihuiyou.top/2019/05/28/OS/"/>
    <id>https://www.daihuiyou.top/2019/05/28/OS/</id>
    <published>2019-05-28T00:52:06.000Z</published>
    <updated>2019-06-18T03:22:03.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><hr><p>并发： 同一「时间点」顺序执行，同一「时间段」交替重叠。 （本质性上也顺序执行，利用单个 CPU 实现宏观层面的并行）</p><p>并行：正真意义上并行，无论微观和宏观上都是并行。完全是多个 CPU 执行。</p><p>并发 <strong><em>VS</em></strong> 并行： 单个CPU <strong><em>VS</em></strong> 多个CPU</p><h3 id="线程是处理机调度的基本单位"><a href="#线程是处理机调度的基本单位" class="headerlink" title="线程是处理机调度的基本单位"></a>线程是处理机调度的基本单位</h3><hr><p>结合我以前的经历，通常单片机的裸机程序的编程都是模块和模块之间的顺序执行，当一个模块因某种原因阻塞，从而导致接下来的模块不能执行而延迟响应，所以不能呈现出良好的实时性。</p><p>那么可以通过单片机的「硬件计时」，自己分配处理机的时间片，通过「中断」切换模块和模块之间的执行流程。进而实现模块和模块之间的并发执行。</p><p>裸机程序的模块间的并发类似与多线程，理解为模块间是手动分配处理机的执行时间， 而多线程是处理机调度的基本单位，是由操作系统依据特定算法分配线程的处理机执行时间。</p><p>只不过单片机未引入操作系统之前，需要自己要分配时间片和确定好中断流程，在操作系统中多线程这不需要这些操作，单纯调用语句就行了。</p><h3 id="进程是资源调度的基本单位"><a href="#进程是资源调度的基本单位" class="headerlink" title="进程是资源调度的基本单位"></a>进程是资源调度的基本单位</h3><hr><p>单片机通常是执行一个特定的程序（进程）， 不存在进程间的资源争斗问题，一个进程拥有在单片机的全部资源。</p><p>我认为多进程的引入是为了充分利用资源。怎么说，属于临界资源的打印机，  一个进程需要打印机资源， 另一个进程也需要打印机资源，并不能让两个进程在同一「时间段」拥有打印机资源。</p><p>多进程的实现，在宏观层面上实现进程间的资源共享。当然， 同一时间段， 进程间的资源不能共享。这需要资源分配策略 「 银行家算法的实现 」。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="OS" scheme="https://www.daihuiyou.top/categories/OS/"/>
    
    
      <category term="OS" scheme="https://www.daihuiyou.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>编程范式</title>
    <link href="https://www.daihuiyou.top/2019/05/21/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://www.daihuiyou.top/2019/05/21/程序设计/</id>
    <published>2019-05-21T12:21:08.000Z</published>
    <updated>2019-06-18T03:25:02.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="编程范式："><a href="#编程范式：" class="headerlink" title="编程范式："></a>编程范式：</h3><hr><ul><li>面向对象</li></ul><p>强调数据，名词为类，动词为该类的成员方法。</p><ul><li>面向过程</li></ul><p>整体到局部。</p><ul><li>泛型编程</li></ul><p>C 的泛型编程的实现</p><p>C++ 的泛型编程的实现</p><ul><li>函数式编程</li></ul><h3 id="C-类方法和-C-函数的区别"><a href="#C-类方法和-C-函数的区别" class="headerlink" title="C++ 类方法和 C 函数的区别"></a>C++ 类方法和 C 函数的区别</h3><hr><ul><li><strong>在变量的角度</strong></li></ul><p>在 C 的函数中，只能使用 local variable（函数内部的所有变量），global variable （独立于该函数外的所有变量）。</p><p>在C++的 类方法中，可以使用 局部变量，可以使用属于对象的成员变量，可以使用属于类的静态成员变量，以及属于该文件的全局变量。 </p><ul><li><strong>在数据输出的角度</strong></li></ul><p>C 的函数在执行后，通过形参 pointer 来返回结果 或 通过 return 返回结果。结果只能是局部变量的值或者全局变量。</p><p>C++的类方法在执行后，可以通过 形参 或者 return  输出 成员变量，静态成员变量， 全局变量，局部变量的值或引用。</p><h3 id="对象调用成员方法-和-类调用成员方法："><a href="#对象调用成员方法-和-类调用成员方法：" class="headerlink" title="对象调用成员方法 和 类调用成员方法："></a>对象调用成员方法 和 类调用成员方法：</h3><hr><p>obj.func(): 对象调用成员方法，可能会改变对象状态，也就是说将对象中的成员变量的值因成员方法的调用而所改变。</p><p>Class.func(): 类调用成员方法， 由于类无成员变量， 静态成员变量除外。所以 类调用成员方法只是单纯调用函数。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><hr><ul><li>内部类的拥有外围的所有元素的访问权限</li></ul><h3 id="头文件声明和类的声明"><a href="#头文件声明和类的声明" class="headerlink" title="头文件声明和类的声明"></a>头文件声明和类的声明</h3><hr><p>C 的头文件的声明 和 C++ 的类的声明类似，</p><p>在 C 中，头文件声明变量和函数， 变量可在函数中使用。</p><p>在 c++ 中， 类的声明，成员变量和成员函数在 class 中声明， 通常一个文件包含一个类。</p><p>类的声明可以当做一个文件。</p><h3 id="变与不变的问题"><a href="#变与不变的问题" class="headerlink" title="变与不变的问题"></a>变与不变的问题</h3><hr><p> 需求不可能是固定的，为了应对需求的改变，  避免以前代码推倒重写，这需要开闭原则（对外支持功能扩展，对已有的代码封闭）</p><p>类的成员变量：不变<br>类的成员函数的形参：变</p><ul><li>委托模式：接口不变，支持扩展功能。</li><li>适配器模式：功能相同，接口不同</li><li>策略模式：接口相同，功能不同</li><li>代理模式：引用技术，智能指针</li><li>装饰模式：不修改原有的代码，进行添加功能</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="编程范式" scheme="https://www.daihuiyou.top/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
    
      <category term="编程范式" scheme="https://www.daihuiyou.top/tags/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SOCKET</title>
    <link href="https://www.daihuiyou.top/2019/05/20/SOCKET/"/>
    <id>https://www.daihuiyou.top/2019/05/20/SOCKET/</id>
    <published>2019-05-20T04:36:46.000Z</published>
    <updated>2019-06-18T03:23:06.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="TCP连接的粘包问题"><a href="#TCP连接的粘包问题" class="headerlink" title="TCP连接的粘包问题"></a>TCP连接的粘包问题</h3><hr><p>由于TCP是面向连接，二进制流传输，由于 Send()是发送给操作系统的缓冲区，并不是立即发送给客户端，等缓冲区有一定大小，再一次性发送给客户端。</p><p>所以由于这样的机制，多次消息的发送，可能一次性消息的接受。导致粘包问题，即是多个消息粘在一起发送。</p><ul><li><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5>发送一次消息，等待接受消息，即判断对方是否接受到消息，确定对方接受到了消息，再继续发送下一条消息。</li></ul><h3 id="多媒体文件传输"><a href="#多媒体文件传输" class="headerlink" title="多媒体文件传输"></a>多媒体文件传输</h3><hr><p>多媒体文件并不是文本文件，采取文本文件读取，对方接受到多媒体文件无法解码。所以文件读取的方式采取是二进制。</p><ul><li><h5 id="传输文件的方法"><a href="#传输文件的方法" class="headerlink" title="传输文件的方法"></a>传输文件的方法</h5></li></ul><p>服务端：读取文件，连续 send()，直到发送完成。等待客户端接受完成消息。</p><p>客户端：接受服务端的消息，以二进制的方式存储到文件中，接受完成后，发送服务端接受完成消息。</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><hr><p>阻塞即是有消息则接受消息，没有消息则一直等待，不去执行其他操作。</p><p>在 TCP中 recv() 是采用阻塞方式接受。</p><p>非阻塞即有消息接受消息，没有消息则执行其他操作。</p><h3 id="多线程实现多个客户端连接"><a href="#多线程实现多个客户端连接" class="headerlink" title="多线程实现多个客户端连接"></a>多线程实现多个客户端连接</h3><hr><p>多线程实现多个客户端连接，线程的数量等于客户端的数量， 当客户端连接数量大到一定程序，服务端容易崩溃。</p><h3 id="Select模型实现多个客户端连接"><a href="#Select模型实现多个客户端连接" class="headerlink" title="Select模型实现多个客户端连接"></a>Select模型实现多个客户端连接</h3><hr><p>select 模型时 Winsock 中最常见的 I/0 模型， 它的中心思想是利用 select 函数，实现多个套接字 I/0 的管理。 利用 select 函数，可以判断套接字上是否存在数据，或则能否向一个套接字写入数据。 只有在条件满足时，才对套接字进行输出操作。</p><p>异步 I/0 模型通过调用 WSAAsynocSelect 函数实现，利用这个模型，应用程序可在一个套接字上接受以 windows 消息为基础的网络事件。</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><hr><p>PING ，使用 ICMP 协议， 基于网络层， 包加上 源IP 和 目的IP， 在 数据链路层中加上源 MAC 地址和目的 MAC 地址，发送到局域网的另一台主机。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="SOCKET" scheme="https://www.daihuiyou.top/categories/SOCKET/"/>
    
    
      <category term="项目" scheme="https://www.daihuiyou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://www.daihuiyou.top/2019/01/04/%E6%8E%92%E5%BA%8F/"/>
    <id>https://www.daihuiyou.top/2019/01/04/排序/</id>
    <published>2019-01-04T05:13:37.000Z</published>
    <updated>2019-06-18T03:33:18.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h2><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><pre><code class="c++">// 未优化template&lt;typename T&gt;void selectionSort1(T arr[], int n){    for (int i = 0; i &lt; n; i++) {        for (int j = i + 1; j &lt; n; j++) {            if (arr[j] &lt; arr[i])                swap(arr[j], arr[i]);        }    }    return;}// 优化template &lt;typename T&gt;void selectionSort2(T arr[], int n){    for (int i = 0; i &lt;= n - 1; i++){        int minIndex = i;        for (int j = i+1; j &lt;= n - 1; j++) {            if (arr[minIndex] &gt; arr[j])                minIndex = j;        }        swap(arr[minIndex], arr[i]);    }    return;}</code></pre><ul><li>测试</li></ul><p>从 1 万个 0~100 的随机数中，从小到大排序。</p><p>selectionSort1 :  <font color="red"> 2.208 s </font></p><p>selectionSort2  : <font color="red">0.108 s</font></p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><pre><code class="c++">// 未优化template&lt;typename T&gt;void InsertionSort1(T arr[], int n){    for (int i = 1; i &lt; n; i++)    {        for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1]; j--) {            swap(arr[j], arr[j - 1]);        }    }    }// 优化template&lt;typename T&gt;void InsertionSort2(T arr[], int n) {    for (int i = 1; i &lt; n; i++) {        T e = arr[i];        int j;        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; e; j--)            arr[j] = arr[j - 1];        arr[j] = e;    }    return;}</code></pre><ul><li>测试</li></ul><p>从1万个 0~100 的随机数中，从小到大排序。</p><p>InsertionSort1 : <font color="red">2.653 s </font></p><p>InsertionSort2 : <font color="red">0.064 s</font></p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><pre><code class="c++">// 希尔排序template&lt;typename T&gt;// n 表示数组 capacityvoid shellSort(T arr[], int n){    int cnt = n - 1;  // 数组元素个数    int tmp = 0;       // 临时变量    // d：distance，     for (int d = n/2; d&gt;=1; d=d/2) {        // 遍历        for (int i = d; i &lt;=cnt; i++) {            // 插入排序            tmp = arr[i];            for ( int j = i - d; j&gt;=0 &amp;&amp; arr[j + d] &lt; arr[j]; j = j - d) {                arr[j + d] = arr[j];                arr[j] = tmp;            }        }    }}</code></pre><ul><li><p>测试</p><p>从 1 万个 0~100 的随机数中，从小到大排序。</p><p>Insertion Sort  :  <font color="red">6.332 s </font></p><p>Shell Sort       : <font color="red">0.029 s</font></p></li></ul><h2 id="O-nlogN"><a href="#O-nlogN" class="headerlink" title="O(nlogN)"></a>O(nlogN)</h2><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><pre><code class="c++">int __partition(int arr[], int l, int r){    int v = arr[l];    int j = l;    for (int i = l + 1; i &lt;= r; i++) {        if (arr[i] &lt; v) {            j++;            swap(arr[i], arr[j]);        }    }    swap(arr[j], arr[l]);    return j;}void __quickSort(int arr[], int l, int r){    if (l &gt;= r)        return;    int p = __partition(arr, l, r);    __quickSort(arr, l, p - 1);    __quickSort(arr, p + 1, r);}// 快速排序void quickSort(int arr[], int n){    __quickSort(arr, 0, n - 1);}</code></pre><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><pre><code class="c++">void shiftDown(int arr[], int n, int k){    while (2 * k + 1 &lt; n) {        int j = 2 * k + 1;        if (j+1&lt;n &amp;&amp; arr[j] &lt; arr[j + 1]) {            j++;        }        if (arr[k] &lt; arr[j]) {            swap(arr[k], arr[j]);            k = j;        }        else            break;    }}void heapSort1(int arr[], int n){    // heapify    for (int i = (n - 1) / 2; i &gt;= 0; i--) {        shiftDown(arr, n, i);    }    for (int i = n - 1; i &gt; 0; i--) {        swap(arr[0], arr[i]);        shiftDown(arr, i, 0);    }}// n 为数组元素个数// k 当前要筛选的索引// arr[0] 为临时存储变量void shift(int arr[], int n, int k) {    while (2 * k &lt; n) {        int j = 2 * k;        if (j + 1 &lt; n &amp;&amp; arr[j] &lt; arr[j + 1])            j++;        if (arr[k] &lt; arr[j]) {            // arr[j] 与 arr[k] 交换            arr[0] = arr[j];            arr[j] = arr[k];            arr[k] = arr[0];            k = j;        }        else             break;    }}// n 为数组元素个数// arr[0] 为临时存储变量void heapSort2(int arr[], int n){    for (int i = (n - 1) / 2; i &gt;= 1; i--) {        shift(arr, n, i);    }    for (int i = n - 1; i &gt;=2; i--) {        // arr[i] 与 arr[1] 交换        arr[0] = arr[i];        arr[i] = arr[1];        arr[1] = arr[0];        shift(arr, i, 1);    }}</code></pre><ul><li><p>测试</p><p>从100 万个 0~100 的随机数中，从小到大排序。</p><p>Heap Sort 1 : <font color="red">2.228 s </font></p><p>Heap Sort 2 : <font color="red">0.248 s</font></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++Primer</title>
    <link href="https://www.daihuiyou.top/2018/12/02/C++Primer/"/>
    <id>https://www.daihuiyou.top/2018/12/02/C++Primer/</id>
    <published>2018-12-02T14:04:10.000Z</published>
    <updated>2019-05-28T02:31:50.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Variables-and-Basic-Types"><a href="#Variables-and-Basic-Types" class="headerlink" title="Variables and Basic Types"></a><strong>Variables and Basic Types</strong></h2><p>C++ programmers tend to refer to 「variables」 as 「variables」 or 「objects」 interchangeably.</p><p>To support 「separate complication」, C++ distinguishes between declaration  and definition.</p><p>The preprocessor — which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs.</p><h3 id="1-Main-Function-and-Library"><a href="#1-Main-Function-and-Library" class="headerlink" title="1. Main Function  and Library"></a><strong>1. Main Function  and Library</strong></h3><p>「Main function」 called by the Operation System to execute a C++ program. Each program must have one and only one function named main.</p><p>Standard library collection of types and function that every C++ compiler must support.</p><p>They also tend to refer to particular  part of the library by referring to a  library type, such as the “ iostream library “ meaning the part of the standard library that defines the IO classes.</p><p>By default, reading cin flushes cout,  cout is also flushed when the program end normally.</p><p>To handle input, we use an object of type istream named cin, This object is also referred to as the standard input.</p><p>In C++ an expression yields a result.</p><p>When you write a long literal, use the uppercase 「L」; the lowercase letter l is too easily mistaken for the digit 1.</p><p>The word 「nullptr」 is a pointer literal. </p><p>The value of a decimal literal is never of negative number, -42, the minus sign is not part of the literal. The minus sign is an operator that negates the values of its operand.</p><p>To attain a declaration that is not also a definition, add the 「extern」 keyword.</p><p>An extern that has an initializer is a definition.</p><h3 id="2-Variables"><a href="#2-Variables" class="headerlink" title="2. Variables"></a><strong>2. Variables</strong></h3><ul><li>Initialization</li></ul><p>Initialization is not assignment. Initialization happens when a variable is given a value when it is created. Assignment obliterates an object’s current value and replaces that value with a new one.</p><p>Uninitialized objects of <em>built-in type</em> defined inside a function body have undefined value. Objects of <em>class type</em> that we do not explicitly initialize have a value that is defined by the class.</p><p>We recommend initializing every object of built-in type. It is not always necessary, but it is easier and safer to provide an initializer until you can be certain it is safe to omit the initializer.</p><p>Separate compilation lets us split our programs into several files, each of which can be compiled independently.</p><ul><li>Declaration and Definition</li></ul><p>To support separate compilation, C++ distinguishes between declarations and definitions.</p><p>To obtain a <em>declaration</em> that is not also a definition, we add the <em>extern</em> keyword and may not provide an explicit initializer:</p><pre><code class="c++">extern int i;   // declares but does not define iint j;          // declares and defines j</code></pre><p>Variables must be defined exactly once but can be declared many times.</p><p>To use a variable in more than one file requires declarations that are separate from the variable’s definition.</p><p>To use the same variable in multiple files, we must define that variable in one—and only one—file. Other files  that use that variable must declare—but not define—that variable.</p><ul><li>Reference</li></ul><p>A reference is not an object. Instead, a reference is just another name for an already existing object.</p><p>A reference must be initialized</p><p>A reference may be bound only to an object, not to a literal or to the result of a more general expression:</p><p>Unlike a reference, a pointer is an object in its own right.</p><p>Unlike a reference , a pointer need not be initialized at the time it is defined.</p><p>references are not objects, they don’t have addresses. Hence, we may not define a pointer  to a reference.</p><h3 id="3-Pointer"><a href="#3-Pointer" class="headerlink" title="3. Pointer"></a><strong>3. Pointer</strong></h3><ul><li>Pointer Value</li></ul><p>The types must match because <em>the type of the pointer</em> is used to infer the type of the object to which the pointer points.</p><p>It can be a  null pointer , indicating that it is not bound to any object.</p><ul><li>Using a Pointer to Access an object</li></ul><p>When a pointer points to an object, we can use the <em>dereference</em> operator (the * operator) to access that object:</p><p>We may dereference only a valid pointer that points to an object.</p><p>Dereferencing a pointer yields the object to which the pointer points.</p><ul><li>Null Pointers</li></ul><p>A null pointer does not point to any object.</p><p>Older programs sometimes use a preprocessor variable named <em>NULL</em>, which the cstdlib header defines as 0.</p><p><em>nullptr</em> is a literal that has a special type that can be converted  to any other pointer type.</p><p>Modern C++ programs generally should avoid using NULL and use nullptr instead.</p><ul><li>void* Pointers</li></ul><p>The type void* is a special pointer type that can hold the address of any object.</p><p>We cannot use a void* to operate on the object it addresses—we don’t know that object’s type, and the type determines what operations we can perform on the object.</p><ul><li>Understanding Compound Type Declarations</li></ul><p>A variable definition consists of a base type and a list of declarators. Each declarator can relate its variable to the base type differently from the other declarators in the same definition. Thus, a single definition might define variables of different types</p><ul><li>Reference to Pointers</li></ul><p>A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer.</p><pre><code class="c++">int i = 42;int *p;            // p is a pointer to intint *&amp;r = p;       // r is a reference to the pointer pr = &amp;i;         //  r refers to a pointer; assigning &amp;i to r makes p point to i*r = 0;     //  dereferencing r yields i, the object to which p points; changes i to//  the base type of the declaration says that r is a reference to a pointer to an int.</code></pre><p>It can be easier to understand complicated pointer or reference declarations if you read them from right to left.</p><h3 id="4-const-Qualifier"><a href="#4-const-Qualifier" class="headerlink" title="4. const Qualifier"></a><strong>4. const Qualifier</strong></h3><p>By Default, const Objects Are Local to a File</p><p>We want to define the const in one file, and declare it in the other files that use that object.</p><p>To share a const object among multiple files, you must define the variable as extern.</p><ul><li>References to const</li></ul><pre><code class="c++">const int ci = 1024;const int &amp;r1 = ci;   // ok: both reference and underlying object are constr1 = 42;              // error: r1 is a reference to constint &amp;r2 = ci;         // error: non const reference to a const object</code></pre><ul><li>Initialization and Reference to const</li></ul><p>In particular, we can bind a reference to const to a nonconst object, a literal, or a more general expression</p><p>A Reference to const May Refer to an Object That Is Not const</p><pre><code class="c++">int i = 42;int &amp;r1 = i;          // r1 bound to iconst int &amp;r2 = i;    // r2 also bound to i; but cannot be used to change ir1 = 0;               // r1 is not const; i is now 0r2 = 0;               // error: r2 is a reference to const</code></pre><ul><li>const Pointers  and Pointer to const</li></ul><p>Unlike references, pointers are objects. Hence, as with any other object type, we can have a pointer that is itself const.</p><p>We use the term top-level const to indicate that the pointer itself is a const.</p><p>When a pointer can point to a const object, we refer to that const as a low-level const.</p><p>The distinction between top-level and low-level matters when we copy an object. When we copy an object, top-level consts are ignored</p><pre><code class="c++">int errNumb = 0;int *const curErr = &amp;errNumb;  // curErr will always point to errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; // pip is a const pointer to a const object</code></pre><p>On the other hand, low-level const is never ignored. When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects.</p><pre><code class="c++">int *p = p3; // error: p3 has a low-level const but p doesn&#39;tp2 = p3;     // ok: p2 has the same low-level const qualification as p3</code></pre><ul><li>constexpr and Constant Expressions</li></ul><p>A constant expression is an expression whose value cannot change and that can be evaluated at compile time.</p><p>Such functions must be simple enough that the compiler can evaluate them at compile time.</p><p>Generally, it is a good idea to use constexpr for variables that you intend to use as constant expressions.</p><ul><li>Pointers and constexpr</li></ul><pre><code class="c++">const int *p = nullptr;     // p is a pointer to a const intconstexpr int *q = nullptr; // q is a const pointer to int</code></pre><p>The difference is a consequence of the fact that constexpr imposes a top-level const on the objects it defines.</p><pre><code class="c++">constexpr int *np = nullptr; // np is a constant pointer to int that is nullint j = 0;constexpr int i = 42;  // type of i is const int// i and j must be defined outside any functionconstexpr const int *p = &amp;i; // p is a constant pointer to the const int iconstexpr int *p1 = &amp;j;      // p1 is a constant pointer to the int j</code></pre><h3 id="5-Dealing-with-Types"><a href="#5-Dealing-with-Types" class="headerlink" title="5. Dealing with Types"></a><strong>5. Dealing with Types</strong></h3><ul><li>Type Aliases</li></ul><p>Type aliases let us simplify complicated type definitions, making those types easier to use. Type aliases also let us emphasize the purpose for which a type is used.</p><p>We can define a type alias in one of two ways. Traditionally, we use a typedef</p><pre><code class="c++">typedef char *pstring;const pstring cstr = 0; // cstr is a constant pointer to charconst pstring *ps;      // ps is a pointer to a constant pointer to char</code></pre><p>When we use pstring in a declaration, the base type of the declaration is a pointer type. When we rewrite the declaration using char<em>, the base type is char and the </em> is part of the declarator.</p><ul><li>The auto Type Specifier</li></ul><p>Under the new standard, we can let the compiler figure out the type for us by using the auto type specifier. Unlike type specifiers, such as double, that name a specific type, auto tells the compiler to deduce the type from the initializer. By implication, a variable that uses auto as its type specifier must have an initializer.</p><ul><li>The decltype Type Specifier</li></ul><p>Sometimes we want to define a variable with a type that the compiler deduces from an expression but do not want to use that expression to initialize the variable.</p><p>For such cases, the new standard introduced a second type specifier, decltype, which returns the type of its operand.</p><p>The compiler analyzes the expression to determine its type but does not evaluate the expression:</p><pre><code class="c++">decltype(f()) sum = x; // sum has whatever type f returnsconst int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x has type const intdecltype(cj) y = x; // y has type const int&amp; and is bound to xdecltype(cj) z;     // error: z is a reference and must be initialized</code></pre><ul><li>decltype and References</li></ul><p>Generally speaking, decltype returns a reference type for expressions that yield objects that can stand on the left-hand side of the assignment</p><pre><code class="c++">// decltype of an expression can be a reference typeint i = 42, *p = &amp;i, &amp;r = i;decltype(r + 0) b;  // ok: addition yields an int; b is an (uninitialized) intdecltype(*p) c;     // error: c is int&amp; and must be initialized// decltype of a parenthesized variable is always a referencedecltype((i)) d;    // error: d is int&amp; and must be initializeddecltype(i) e;      // ok: e is an (uninitialized) int// The type is a reference to the type of the left-hand operand.int a = 3, b = 4;decltype(a) c = a;decltype(a = b) d = a; //  equal to :int &amp;d = a;</code></pre><p>Another important difference between decltype and auto is that the deduction done by decltype depends on the form of its given expression.</p><h3 id="6-Defining-Our-Own-Data-Structures"><a href="#6-Defining-Our-Own-Data-Structures" class="headerlink" title="6. Defining Our Own Data Structures"></a><strong>6. Defining Our Own Data Structures</strong></h3><p>In C++ we define our own data types by defining a class. The library types string, istream, and ostream are all defined as classes.</p><ul><li>Defining the Sales_data Type</li></ul><pre><code class="c++">struct Sales_data {    std::string bookNo;    unsigned units_sold = 0;    double revenue = 0.0;};</code></pre><p>The close curly that ends the class body must be followed by a semicolon. The semicolon is needed because we can define variables after the class body.</p><p>It is a common mistake among new programmers to forget the semicolon at the end of a class definition.</p><ul><li>Writing Our Own Header Files</li></ul><p>In order to ensure that the class definition is the same in each file, classes are usually defined in header files. </p><p>classes are stored in headers whose name derives from the name of the class.</p><p>Whenever a header is updated, the source files that use that header must be recompiled to get the new or changed declarations.</p><ul><li>A Brief Introduction to the Preprocessor</li></ul><p>The preprocessor—which C++ inherits from C—is a program that runs before the compiler and changes the source text of our programs.</p><p>Our programs already rely on one preprocessor facility, #include. When the preprocessor sees a #include, it replaces the #include with the contents of the specified header.</p><p>Preprocessor variables have one of two possible states: defined or not defined.</p><p>The #define directive takes a name and defines that name as a preprocessor variable.</p><p>#ifdef is true if the variable has been defined, and #ifndef is true if the variable has not been defined.</p><p>If the test is true, then everything following the #ifdef or #ifndef is processed up to the matching #endif.</p><p>Preprocessor variable names do not respect C++ scoping rules.</p><p>Preprocessor variables, including names of header guards, must be unique throughout the program.</p><h3 id="7-Defined-Terms"><a href="#7-Defined-Terms" class="headerlink" title="7. Defined Terms"></a><strong>7. Defined Terms</strong></h3><p><strong>const reference</strong> Colloquial synonym for reference to const.</p><p><strong>constant expression</strong> Expression that can be evaluated at compile time.</p><p><strong>declaration</strong> Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared.</p><p><strong>definition</strong> Allocates storage for a variable of a specified type and optionally initializes the variable.</p><p><strong>object</strong> A region of memory that has a type. A variable is an object that has a name.<br>outer scope Scope that encloses another scope.</p><p><strong>preprocessor variable</strong> Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled.</p><p><strong>reference</strong> An alias for another object.</p><p><strong>struct</strong> Keyword used to define a class.</p><p><strong>typedef Defines</strong> an alias for another type.</p><p><strong>void* Pointer</strong> type that can point to any nonconst type. Such pointers may not be dereferenced.</p><h2 id="Strings-Vectors-and-Arrays"><a href="#Strings-Vectors-and-Arrays" class="headerlink" title="Strings, Vectors, and Arrays"></a><strong>Strings, Vectors, and Arrays</strong></h2><p>C++ defines a rich library of abstract data types.</p><p>Among the most important library types are string, which supports variable-length character strings, and vector, which defines variable-size collections.</p><p>Associated with string and vector are companion types known as iterators, which are used to access the characters in a string or the elements in a vector.</p><p>The built-in types represent facilities present in most computer hardware, such as numbers or characters.</p><p>The standard library defines a number of additional types of a higher-level nature that computer hardware usually does not implement directly.</p><p>A string is a variable-length sequence of characters. A vector holds a variable-length sequence of objects of a given type.</p><h3 id="1-Namespace-using-Declaration"><a href="#1-Namespace-using-Declaration" class="headerlink" title="1. Namespace using Declaration"></a><strong>1. Namespace using Declaration</strong></h3><p>Headers Should Not Include using Declarations.</p><p>If a header has a using declaration, then every program that includes that header gets that same using declaration. As a result, a program that didn’t intend to use the specified library name might encounter unexpected name conflicts.</p><h3 id="2-Library-string-Type"><a href="#2-Library-string-Type" class="headerlink" title="2. Library string Type"></a><strong>2. Library string Type</strong></h3><p>A string is a variable-length sequence of characters. To use the string type, we must include the string header.</p><p>When we initialize a variable using =, we are asking the compiler to copy initialize the object by copying the initializer on the right-hand side into the object being created.</p><p>Otherwise, when we omit the =, we use direct initialization.</p><pre><code class="c++">string s5 = &quot;hiya&quot;;  // copy initializationstring s6(&quot;hiya&quot;);   // direct initializationstring s7(10, &#39;c&#39;);  // direct initialization; s7 is cccccccccc</code></pre><p>The string input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered.</p><p>Using 「getline 」to Read an Entire Line: In such cases, we can use the getline function instead of the &gt;&gt; operator.</p><ul><li>Adding Literals and strings</li></ul><p>When we mix strings and string or character literals, at least one operand to each + operator must be of string type</p><ul><li>Dealing with the Characters in a string</li></ul><p>In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form name .h. </p><p>The C++ versions of these headers are named c name—they remove the .h suffix and precede the name with the letter c.</p><p>The c indicates that the header is part of the C library.</p><ul><li>Processing Every Character? Use Range-Based for</li></ul><p>If we want to do something to every character in a string, by far the best approach is to use a statement introduced by the new standard: 「the range for statement」.</p><p>The syntactic form is where expression is an object of a type that represents a sequence,and declaration defines the variable that we’ll use to access the underlying elements in the sequence.</p><p>On each iteration, the variable in declaration is initialized from the value of the next element in expression.</p><ul><li>Using a Range for to Change the Characters in a string</li></ul><p>If we want to change the value of the characters in a string, we must define the loop variable as a reference type.</p><pre><code class="c++">string s(&quot;Hello World!!!&quot;);// convert s to uppercasefor (auto &amp;c : s)   // for every char in s (note: c is a reference)    c = toupper(c); // c is a reference, so the assignment changes the char in scout &lt;&lt; s &lt;&lt; endl;</code></pre><ul><li>a subscript</li></ul><p>The subscript operator (the [ ] operator) takes a string::size_type value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position.</p><p>Subscripts for strings start at zero; if s is a string with at least two characters, then s[0] is the first character, s[1] is the second, and the last character is in s[s.size() - 1].</p><p>The value in the subscript is referred to as 「a subscript」 or 「an index」.</p><p>The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined.</p><h3 id="3-Library-vector-Type"><a href="#3-Library-vector-Type" class="headerlink" title="3. Library vector Type"></a><strong>3. Library vector Type</strong></h3><p>A vector is a collection of objects, all of which have the same type. Every object in the collection has an associated index, which gives access to that object. 「A vector」 is often referred to as 「a container」 because it “contains” other objects. </p><p>A vector is a class template. C++ has both class and function templates. 「Templates are not themselves functions or classes」.  Instead, they can be thought of as 「instructions」 to the compiler for generating classes or functions.</p><p>The process that the compiler uses to create classes or functions from templates is called 「instantiation」.</p><pre><code class="c++">vector&lt;int&gt; ivec;             // ivec holds objects of type intvector&lt;Sales_item&gt; Sales_vec; // holds Sales_itemsvector&lt;vector&lt;string&gt;&gt; file;  // vector whose elements are vectors</code></pre><p>「vector is a template, not a type.」 Types generated from vector must include the element type.</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a><strong>Note</strong></h2><p>Conventions for Variable Names：变量名称的约定</p><p>separate compilation：独立编译</p><p>tend to：倾向于</p><p>fits in：适合</p><p>so far：目前为止</p><p>the indicated value: 指定的值</p><p>yields a result : 产生一个结果</p><p>bound to (bind to) :绑定</p><p>plain：朴华无实的，平的（）text/plain 就是指纯文本，不会对这个数据进行任何解析</p><p>evaluated : 求…值</p><p>do not respect C++ scoping rules: 不遵守作用域规则</p><p> be used to： 用于</p><table><thead><tr><th><em>associative:联合</em></th><th><em>container:容器，集装箱</em></th><th><em>derived-Class: 派生类/子类</em></th></tr></thead><tbody><tr><td><em>alias:别名</em></td><td><em>override: 重写</em></td><td><em>overloading: 重载</em></td></tr><tr><td><em>directive:指令</em></td><td><em>redirect: 重定向</em></td><td><em>indicator:指示</em></td></tr><tr><td><em>arguments: 实参</em></td><td><em>library facility:库功能 (工具库)</em></td><td><em>statements:语句</em></td></tr><tr><td><em>extensive: 大规模</em></td><td><em>mechanisms: 机制</em></td><td><em>string literal: 字符串字面量</em></td></tr><tr><td><em>semicolon: 分号</em></td><td><em>block: 代码块</em></td><td><em>iteration: 重复</em></td></tr><tr><td><em>comments: 注释</em></td><td><em>built-in type： 内置类型</em></td><td><em>backslash： 反斜杠</em></td></tr><tr><td><em>carriage return： 回车</em></td><td><em>Escape Sequences: 转义序列</em></td><td><em>initializer: 初始化</em></td></tr><tr><td><em>commas： 逗号</em></td><td><em>type specifier: 类型说明符</em></td><td><em>Identifiers: 标识符</em></td></tr><tr><td><em>inclusive：包括</em></td><td><em>Nested Scopes：嵌套范围</em></td><td><em>fetch: 获取</em></td></tr><tr><td><em>type modifiers: 类型修饰符</em></td><td><em>underlying: 底层</em></td><td><em>Qualifier: 限定符</em></td></tr><tr><td><em>plain: 原始,素</em></td><td><em>synonym: 同义词</em></td><td><em>groups: 分组</em></td></tr><tr><td><em>implement：实现</em></td><td>strategy：a plan of action 策略</td><td>contents:内容</td></tr><tr><td>cover: 介绍 / 覆盖</td><td>punctuation: 标点</td><td>capitalize: 大写字母</td></tr><tr><td>subscript：下标</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="原版书籍" scheme="https://www.daihuiyou.top/categories/%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="原版书籍" scheme="https://www.daihuiyou.top/tags/%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>硅谷来信</title>
    <link href="https://www.daihuiyou.top/2018/11/30/%E7%A1%85%E8%B0%B7%E6%9D%A5%E4%BF%A1/"/>
    <id>https://www.daihuiyou.top/2018/11/30/硅谷来信/</id>
    <published>2018-11-30T15:21:45.000Z</published>
    <updated>2019-01-06T14:38:49.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="收获比较大的方面："><a href="#收获比较大的方面：" class="headerlink" title="收获比较大的方面："></a>收获比较大的方面：</h3><ul><li>学习什么都不重要，重要是学习是其中的方法和思维过程。再一次说明思维的重要性， 书本上的学到的是记忆，要加以理解，应用，才算是知识。要不然许多人学很多遍的知识都比不上别人学一遍来得快。</li><li>科学有新的定义：科学是注重方法和过程，不是结论。 科学的结论不一定是正确的结论，正确的结论不一定是科学的。许多专家给出的结论可能是正确，但是不说明这是科学的。盲信所谓专家的精神，倒霉的是自己。 </li><li>科学强调实验结果的重复性，西方科学和技术最显著的特点是可继承性和可叠加性。 </li><li>结论可以证实，但不可证伪。为什么呢？  就比如 “ 学Python再加上经济环境不好，找相关的工作很难。”， 这一结论只能证明该结论是对，不能证明该结论是错的，要是今年学Python的找工作相对困难呢，说明结论对了么？但是要是明年找工作又容易了，结论错了么？  总之， 因为未来的不确定，结论可以证实，不能证伪。</li><li>别人会的自己不学，只学习别人不会。 别人不会当然前提是别人是想学而学不会，人工智很多人都想学吗？都学会了吗？ 不太现实， 基础知识需要太多了，不仅仅只是说学Python， 就可以了。</li></ul><h3 id="语录："><a href="#语录：" class="headerlink" title="语录："></a>语录：</h3><ul><li>对于那些试图在金字塔上爬几个台阶的人来讲，最需要具有不是抱怨社会的不公平，而是需要付出足够的努力，同时把主力以放到最该关注的事情上去。 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="书籍" scheme="https://www.daihuiyou.top/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>算法精解</title>
    <link href="https://www.daihuiyou.top/2018/11/22/%E7%AE%97%E6%B3%95%E7%B2%BE%E8%A7%A3/"/>
    <id>https://www.daihuiyou.top/2018/11/22/算法精解/</id>
    <published>2018-11-22T11:54:02.000Z</published>
    <updated>2019-06-18T03:14:06.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-泛型指针"><a href="#1-泛型指针" class="headerlink" title="1. 泛型指针"></a>1. 泛型指针</h3><ul><li>很多种情况下， void 指针都是非常用的。 例如： C 标准函数库中的 memcpy 函数， 它将一段函数从内存中的一个地方复制到另一个地方。由于 memcpy 可能用来复制任何类型的参数的数据， 因此将它的指针参数设定为 void 类型</li></ul><h3 id="2-泛型指针和句柄的差别"><a href="#2-泛型指针和句柄的差别" class="headerlink" title="2. 泛型指针和句柄的差别"></a>2. 泛型指针和句柄的差别</h3><h5 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h5><ul><li>设计者： 设计函数的人</li><li>调用者： 调用函数的人</li><li>void 指针函数参数： 设计者不知道也不需要知道调用者使用的具体数据类型， void 指针做输出参数， 设计者可以根据已知的数据类型对 void 指针做转换。</li><li>句柄（void 类型）：调用者不知道也不需要知道设计者在函数体所使用的数据类型。句柄会在函数体转换成相应的数据类型。</li></ul><h3 id="3-编程规范"><a href="#3-编程规范" class="headerlink" title="3. 编程规范"></a>3. 编程规范</h3><pre><code class="c">#ifndef LIST_H#define LIST_H/*  funciton process result */typedef enum Result_{    FALSE = -1,    TRUE  = 0}Result;/* Define a structure for linked lists */typedef struct ListElmt_{    void                *data;    struct ListElmt_    *next;}ListElmt;/* Define a structure for linked lists */typedef struct List_{    int            size;    ListElmt    *head;    ListElmt    *tail;    int    (*match)(const void *key1, const void *key2);    void(*destroy)(void *data);}List;/* Public Interface */void list_init(List *list, void(*destroy)(void *data));void list_destory(List *list);int list_ins_next(List *list, ListElmt *element, const void *data);int list_rem_next(List *list, ListElmt *element, void **data);void list_destory(List *list);/* role : inline function*/#define list_size(list) ((list)-&gt;size)#define list_head(list) ((list)-&gt;head)#define list_tail(list) ((list)-&gt;tail)#define list_is_head(list, element) ((element) == (list)-&gt;head ? 1: 0)#define list_is_tail(list, element) ((element)-&gt;next == NULL ? 1 : 0)#define list_data(list) ((list)-&gt;data)#define list_next(list) ((list)-&gt;next)#endif</code></pre><pre><code class="c++">/* list.c */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;list.h&quot;/* list_init */void list_init(List * list, void(*destroy)(void *data)){    /* Initialize the list. */    list-&gt;size = 0;    list-&gt;destroy =     destroy;    list-&gt;head = NULL;    list-&gt;tail = NULL;    return;}/* list_destory */void list_destory(List *list){    void        *data;    /* Remove each element */    while (list_size(list) &gt; 0) {        if (list_rem_next(list, NULL, (void**)&amp;data) == 0             &amp;&amp; list-&gt;destroy != NULL){            /* Call a user-defined function to free dynamically data */            list-&gt;destroy(data);         }    }    /* No operations are allowed now, but clear the structure as a precautions */    memset(list, 0, sizeof(List));     return;}</code></pre><pre><code class="c++">/* list_ins_next *//* The ListElmt *element has the next pointer information , the next pointer is not null */int list_ins_next(List * list, ListElmt * element, const void * data){    ListElmt        *new_element;    /* Allocate storage for the element */    if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL) {        return -1;    }    /* Insert the element into the list */    new_element-&gt;data = (void *)data;    if (element == NULL) {        /* Handle insertion at the head of the list */        if (list_size(list) == 0)            list-&gt;tail = new_element;        new_element-&gt;next = list-&gt;head;        list-&gt;head = new_element;    }    else {        /* Handle insertion somewhere other than at the head */        if (element-&gt;next == NULL)            list-&gt;tail = new_element;        new_element-&gt;next = element-&gt;next;        element-&gt;next = new_element;    }    /* Adjust the size of the list to account for the inserted element */    list-&gt;size++;    return 0;}/* list_rem_next */int list_rem_next(List *list, ListElmt *element, void **data){    ListElmt        *old_element;    /* Do not allow removal an empty list */    if (list-&gt;head == NULL)        return -1;    /* Remove the element from the list */    if (element == NULL) {        /* Handle removal from the head of the list */        *data = list-&gt;head-&gt;data; //Generic pointer        old_element = list-&gt;head;        list-&gt;head = list-&gt;head-&gt;next;        if (list_size(list) == 1)            list-&gt;tail = NULL;    }    else {        /* Handle removal from somewhere other than the head */        if (element-&gt;next == NULL)            return -1;        *data = element-&gt;next-&gt;data;        old_element = element-&gt;next;        element-&gt;next = element-&gt;next-&gt;next; //It is easy to remember.    }    /* Free the storage allocated by the abstract datatype */    free(old_element);    /* Adjust the sizeof the list to account for the removal element */    list-&gt;size--;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://www.daihuiyou.top/2018/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://www.daihuiyou.top/2018/10/11/数据结构/</id>
    <published>2018-10-11T00:53:13.000Z</published>
    <updated>2019-06-18T03:12:48.393Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-for循环常用写法"><a href="#1-for循环常用写法" class="headerlink" title="1. for循环常用写法"></a>1. for循环常用写法</h3><pre><code class="c++">void main(){    int  i = 0;    int a[20];    int len = 10;    int pos = 5;    i = i - 1; /*结果:i = -1; 不是溢出.*/    printf(&quot;i = %d\n&quot;, i);    /*数组赋值*/    for (i = 0; i &lt; len; i++)        a[i] = i + 1;    printf(&quot;\n&quot;);    /*逆序打印*/    for (i = len-1; i &gt;=0; i--)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    /*插入元素, 往后移动元素(倒序循环)*/    for (i = len-1; i &gt;=5; i--)/* 往后移动 倒序循环*/    {        a[i+1] = a[i];  /*表示最后要插入a[6] = a[5] */    }    a[5] = 0;    len = len + 1;        /*逆序打印*/    for (i = len-1; i &gt;= 0; i--)        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    /*删除元素, 往前移动(正序循环)*/    for (i = 5; i &lt;len; i++) /*向前移动, 正序循环*/    {        a[i] = a[i+1];    }    len = len - 1;    /*逆序打印*/    for (i = len - 1; i &gt;= 0; i--) //倒序循环        printf(&quot;%d &quot;, a[i]);    printf(&quot;\n&quot;);    printf(&quot;\n&quot;);    printf(&quot;hello.&quot;);    system(&quot;pause&quot;);}/*总结:符号要注意区分, 正序循环&lt; 和 倒序循环&gt;A: 正序循环 for(i=0; i&lt;len; i++)              for(i=1; i&lt;=len; i++)B: 倒序循环 for(i=len-1; i&lt;=0; i--) //数组采用这种方式, 大于号和小于号           for(i=len; i&lt;0; i--) */</code></pre><h3 id="2-循序栈和链式栈"><a href="#2-循序栈和链式栈" class="headerlink" title="2. 循序栈和链式栈"></a>2. 循序栈和链式栈</h3><p>stack的采用模型：</p><p>线性表的链式存储：头插法　　　</p><p>线性表的顺序存储：尾插法　</p><h3 id="3-线性表顺序存储和链式存储"><a href="#3-线性表顺序存储和链式存储" class="headerlink" title="3. 线性表顺序存储和链式存储"></a>3. 线性表顺序存储和链式存储</h3><p>单独把结点的指针域 声明成结构体数据类型， </p><p>指针指向谁， 就把谁的地址赋给指针。</p><p><strong>note:</strong></p><p>wrong:</p><pre><code class="c++">current-&gt;next = node-&gt;next;node = current-&gt;next;        // what is wrong?   node is not pointer filed and can&#39;t be assigned.</code></pre><p>right:</p><pre><code class="c++">    node-&gt;next = current-&gt;next;    current-&gt;next = node;</code></pre><p><strong>LinkList Test FrameWork</strong></p><pre><code class="c++">#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &quot;linklist.h&quot;typedef struct Teahcer{    LinkListNode *node;    int age;    int name[64];}Teacher;void main(){    int len = 0;    int i = 0;    Teacher *tmp = NULL;    LinkList *list = NULL;      //note: list is handle that is void type.    list = LinkListCreate();    Teacher t1, t2, t3, t4, t5;    t1.age = 31;    t2.age = 32;    t3.age = 33;    t4.age = 34;    t5.age = 35;    list = LinkListCreate();    LinkListInsert(list, (LinkListNode*)&amp;t1, 0);    LinkListInsert(list, (LinkListNode*)&amp;t2, 0);    LinkListInsert(list, (LinkListNode*)&amp;t3, 0);    LinkListInsert(list, (LinkListNode*)&amp;t4, 0);    LinkListInsert(list, (LinkListNode*)&amp;t5, 0);    len = LinkListGetLength(list);    for (i = 0; i &lt; len; i++)    {        tmp = (Teacher*)LinkListGetElement(list, i);        if (tmp != NULL)        {            printf(&quot;age: %d &quot;, tmp-&gt;age);        }    }    printf(&quot;\n&quot;);    //note: This function deletes LinkList element at the position.    LinkListDeleteElement(list, 2);    printf(&quot;After delete element. \n &quot;);    len = LinkListGetLength(list);    for (i = 0; i &lt; len; i++)    {        tmp = (Teacher*)LinkListGetElement(list, i);        if (tmp != NULL)        {            printf(&quot;age: %d &quot;, tmp-&gt;age);        }    }    printf(&quot;\n&quot;);    LinkListClear(list);    printf(&quot;hello.&quot;);    system(&quot;pause&quot;);}</code></pre><p><strong>linklist.h</strong></p><pre><code class="c++">#pragma once#ifndef _LINKLIST_H#define _LINKLIST_H#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#endif/*    LinkList API*/typedef void LinkList;typedef struct _tag_LinkListNode{    struct _tag_LinkListNode *next;}LinkListNode; //Node type   It&#39;s a great heavest for me..  LinkList *LinkListCreate();int LinkListClear(LinkList *list);LinkListNode * LinkListGetElement(LinkList *list, int pos);int LinkListInsert(LinkList *list, LinkListNode *node, int pos);int LinkListDeleteElement(LinkList *list, int pos);int LinkListGetLength(LinkList *list);</code></pre><p><strong>linklist.c</strong></p><pre><code class="c++">#include &quot;linklist.h&quot;typedef struct _tag_LinkList{    LinkListNode header;    int length;}TLinkList; //It&#39;s still LinkListNode type.LinkList *LinkListCreate(){    TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList)); //alocate memory.     if (ret == NULL)    {        return NULL;    }    ret-&gt;length = 0;    ret-&gt;header.next = NULL;    return ret;}int LinkListClear(LinkList *list){    if (list == NULL)    {        return 0;    }    TLinkList *tlist = (TLinkList *)list;    free(tlist);    return 0;}LinkListNode * LinkListGetElement(LinkList *list, int pos){    int i = 0;    TLinkList *tlist = NULL;    LinkListNode *current = NULL;    LinkListNode *ret = NULL;    tlist = (TLinkList*)list; //handle(void type) have turn to Tlinklist(struct type);    current = &amp;tlist-&gt;header;     if (list == NULL || pos &lt; 0 || pos &gt;= tlist-&gt;length)    {        return NULL;    }    for (i = 0; i &lt; pos &amp;&amp; (current-&gt;next != NULL); i++)    {            current = current-&gt;next;    }    ret = current-&gt;next;    return     ret;}int LinkListInsert(LinkList *list, LinkListNode *node, int pos){    int i = 0;    TLinkList  *tlist = (TLinkList*)list; //transfrom    LinkListNode *current = NULL;    LinkListNode *ret = NULL;    current = &amp;tlist-&gt;header;    for (i = 0; i&lt;pos &amp;&amp; (current-&gt;next != NULL); i++)    {        current = current-&gt;next;    }    //insert elememt;    ret = current-&gt;next; //sort information, avoid that It can&#39;t find the next element;    current-&gt;next = node;    node-&gt;next = ret;    tlist-&gt;length++;    return 0;}int LinkListDeleteElement(LinkList *list, int pos){    int i = 0;    LinkListNode  *current = NULL;    LinkListNode *ret = NULL;    TLinkList *tlist = (TLinkList *)list;    current = &amp;tlist-&gt;header;    if (list == NULL || pos &lt;0 || pos &gt;= tlist-&gt;length)    {        return NULL;    }    for (i = 0; i &lt; pos; i++)    {        current = current-&gt;next;    }    ret = current-&gt;next;    current-&gt;next = ret-&gt;next;    return 0;}int LinkListGetLength(LinkList *list){    int ret = 0;    TLinkList *tlist = (TLinkList* )list;    ret = tlist-&gt;length;    return ret;}</code></pre><h3 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4. 基本概念"></a>4. 基本概念</h3><p>数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被成为记录。</p><p>数据项：一个数据元素可以由若干个数据项组成。</p><p>数据对象： 是性质相同的数据元素的集合，是数据的子集。</p><p>抽象数据类型（Abstract Data Type， ADT）： 是指一个数学模型及定义在该模型上的一组操作。  </p><p>逻辑结构：集合结构，线性结构，树形结构，图形结构</p><p>物理结构：顺序存储结构，链接存储结构。</p><p>好的算法还应该具备时间效率高和存储量低的特点。　　</p><p>线性阶：      </p><pre><code class="c++">int i;for(i=0; i&lt;n; i=+){}//对数阶： int count = 1;while (count  &lt; n){count = count * 2;}//平方阶：  int i, j;for (i = 0; i &lt; n; i++){    for (j = 0; j &lt; n; j++)    {    }}//时间复杂（m*n):  int i, j;for (i = 0; i &lt; n; i++){    for (j = i; j &lt; n; j++)    {        /*时间复杂度*/    }}//数列计算: n + (n-1) + (n-2) + ....+ 1 = n*(n+1)/2;/*最坏情况运行时间是一种保证， 那就是运行时间将不会再坏。在应用中，这是一种最重要的需求，通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。  平均时间是所有情况中最有意义的，因为他是期望的运行时间。一般没有特殊说明的情况下， 都是指最坏时间复杂度。/*</code></pre><p><strong>可以通过算法的时间复杂度的估算， 判断自己写的代码是否效率低下，是不是可以通过优化让计算机更加快速高效。</strong></p><p>线性表的抽象数据类型 :</p><ol><li>时间复杂度</li><li><p>空间复杂度  </p></li><li><p>时间换空间  </p></li><li><p>空间换时间</p></li></ol><h3 id="5-二叉树"><a href="#5-二叉树" class="headerlink" title="5. 二叉树"></a>5. 二叉树</h3><p>定义： 是 n(n&gt;=0)个结点的有限集合，由一个根结点以及两颗互不相交的，分别成为左子树和右子树的二叉树组成。</p><p>基本特征：每个结点最多只有两颗子树； 左子树和右子树次序不能颠倒（有序树）</p><p>二叉树性质： 对于任何一颗二叉树，若2度的节点数有 n 个，则叶子数必定为 n+1。</p><p>满二叉树：每层都“充满”了结点。</p><p>完全二叉树： 第 k-1 层 和满二叉树的一样； 最后一层，叶子节点尽力靠左。</p><p>性质： <strong>对完全二叉树，若从上至下，从左到右编号，则编号为 i 的结点，其左孩子编号必为 2i， 其右孩子编号必为 2i+1， 其双亲的编号必为 i/2.</strong> 可以通过数组下标，隐藏地找到其左孩子和右孩子。 </p><p>不是完全二叉树， 则一律转为完全二叉树。 将各层空缺处统统补上”虚结点“， 其内容为空。</p><ul><li><strong>二叉树的表示法</strong></li></ul><p>二叉树的二叉链表 表示法</p><p>二叉树的三叉链表 表示法： 添加了 Parent Position</p><p>二叉树的双亲链表 Parent）： 子结点中保存了 双亲的位置。</p><pre><code class="c">//二叉链 表示法 typedef struct BitNode {    int data;    struct BitNode *lchild, *rchild;}BitNode, *BitNode;//三叉链表typedef struct TriNode {    int data;    struct TriNode *lchild, *rchild;    struct TriNode *parent;}TriNode, *TriNode;//双亲表示法#define MAX_TREE_SIZE 100typedef struct BPTNode {    int data;    int parentPosition;    char LRTag;}BPTNode;typedef struct BPTree {    BPTNode nodes[MAX_TREE_SIZE];    int num_node;    int root;}BPTree;</code></pre><ul><li>二叉树遍历</li></ul><p>先序遍历： DLR， 先根再左再右</p><p>中序遍历： LDR， 先左再根再右</p><p>后序遍历： LDR，先左再右再根</p><p>总结： 顺序都是相对于根（root）来说的。</p><ul><li>对遍历的分析：</li></ul><p>1.从前面的三种遍历算法可以知道：如果将 printf 语句抹去，从递归的角度看， 这三种算法是完全相同的，或者说者三种遍历算法的访问路径是相同，知识访问结点的时机不同。</p><p>从虚线的出发点到终点的路径上，每个结点经过3次。</p><p>第 1 次经过时访问 = 先序遍历</p><p>第 2 次经过时访问 = 中序遍历</p><p>第 3 次经过时访问 = 后序遍历</p><h3 id="6-树的非递归中序遍历"><a href="#6-树的非递归中序遍历" class="headerlink" title="6. 树的非递归中序遍历"></a>6. 树的非递归中序遍历</h3><pre><code class="c++">/*步骤1： 如果结点有左子树，该结点入栈；若果结点没有左子树，访问该结点步骤2： 如果结点有右子树，重复步骤1；如果结点没有右子树（结点访问完毕），根据栈顶指示回退，访问栈顶元素，并访问右子树，重复步骤1如果栈为空，表示遍历结束。*/#include &lt;iostream&gt;using namespace std;#include &quot;stack&quot;typedef struct BitNode {    int data;    struct BitNode *lchild;    struct BitNode *rchild;}BitNode;//参数列表: BitNode *T, stack(BitNode *&gt; &amp;s//返回值: BitNode *BitNode *goLeft(BitNode *T, stack&lt;BitNode *&gt; &amp;s) {   //&amp;s 引用类型    if (T == NULL) {        return NULL;    }    while (T-&gt;lchild != NULL) {        //如果有左子树， 该结点入栈，并指向左子树。        s.push(T);        T = T-&gt;lchild;    }    //如果没有左子树， 返回该结点。    return T;}void inOrder(BitNode *T) {    BitNode *t = NULL;    stack&lt;BitNode *&gt;s;    t = goLeft(T, s);    while (t) {        printf(&quot;%d &quot;, t-&gt;data); // 访问该结点        //如果t有右子树，重复步骤1        if (t-&gt;rchild != NULL) {            t = goLeft(t-&gt;rchild, s);        }        // 如果t没有右子树，根据栈顶提示，回退        else if (!s.empty()) {            t = s.top();            s.pop();        }        // 如果没有右子树， 并且栈为空        else {            t = NULL;        }    }}void main() {    BitNode t1, t2, t3, t4, t5;    memset(&amp;t1, 0, sizeof(BitNode));    memset(&amp;t2, 0, sizeof(BitNode));    memset(&amp;t3, 0, sizeof(BitNode));    memset(&amp;t4, 0, sizeof(BitNode));    memset(&amp;t5, 0, sizeof(BitNode));    t1.data = 1;    t2.data = 2;    t3.data = 3;    t4.data = 4;    t5.data = 5;    t1.lchild = &amp;t2;    t1.rchild = &amp;t3;    t2.lchild = &amp;t4;    t3.lchild = &amp;t5;    printf(&quot;\r\n 非递归遍历 \r\n&quot;);    inOrder(&amp;t1);    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;    system(&quot;pause&quot;);}</code></pre><p>通过中序遍历和先序遍历可以确定一个树</p><p>通过中序遍历和后序遍历可以确定一个树</p><p>通过先序遍历和后序遍历不能确定一个树</p><p>单独先序遍历。</p><p>二叉线索树： 普通二叉树只能找到结点的左右孩子信息，而该结点的直接前驱和直接后继只能在遍历过程中获得；若可将遍历后对应的有关前驱和后继预存储起来，则从第一个结点开始就能很快“顺藤摸瓜”，而遍历整个树了。</p><h3 id="7-图"><a href="#7-图" class="headerlink" title="7. 图"></a>7. 图</h3><p>线性表中我们把数据元素叫元素，树中的数据元素叫结点，在图中数据元素，我们称之为顶点（Vertex）。</p><p>线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。同样，在图的结构中，不允许没有顶点，在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。</p><p>图中，任意两个顶点你之间都可能有关系，顶点之间的逻辑关系用吧边表示，边集可以是空的。</p><ul><li>连通图</li></ul><p>在无向图 G 中， 如果对于图中任意两个顶点v1，v2都是连通的，则称 G 是连通图。</p><p>无向图中的极大连通子图称为连通分量。</p><p>有向图 G 中，如果对于每一对vi， vj， 从vi 到 vj 和 从 vj 到 vi都存在路径，则称 G 是强连通图。 </p><ul><li>邻接表</li></ul><p>一种孩子表示法，将结点存入数组，并对结点的孩子进行链式存储，不管有多少孩子，也不会存在空间的浪费。这个思路同样适用于图的存储，我们把这种数据与链表结合的存储方法称为邻接表。</p><p>顶点表的各个结点有 data 和 firstedge 两个域表示， data 是数据域，存储顶点信息，firstedge 是指针域，指向边表的第一个结点。</p><p>边表结点有 adjvex 和 next 两个域组成， adjvex 是邻接点域，存储某顶点的邻接点在顶点中的下标。 next 则存储指向表中下一个结点的指针。</p><p>有时为了便于确定顶点的入度或以顶点为弧头的弧， 有向图的逆连接表，即对每个顶点 v1 都建立一个链接为 v1 为 弧头的表。</p><ul><li>邻接矩阵</li></ul><p>图的邻接矩阵存方式是用两个数组来表示图。一个一维数组存图中顶点信息， 一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://www.daihuiyou.top/2018/10/11/C++/"/>
    <id>https://www.daihuiyou.top/2018/10/11/C++/</id>
    <published>2018-10-11T00:17:58.000Z</published>
    <updated>2019-06-18T03:31:08.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><hr><p>多态即多种形态，多态的实现即3步骤：有继承，虚函数重写，父类指针指向子类对象。</p><p>那么类中函数的重载（overloading），也是多态，同一函数名的多种状态。</p><ul><li><strong>多态实现的原理</strong>：</li></ul><p>在类的成员方法有virtual关键字，那么在创建类对象时，编译器会把对象添加一个虚函数指针,来指向虚函数表。</p><p>虚函数表的作用来存放类中成员方法的虚函数地址。在程序运行时，根据虚函数表才能确定对应执行的操作（动态绑定）</p><ul><li><h5 id="为什么类中的析构函数通常都要添加-virtual-关键字？"><a href="#为什么类中的析构函数通常都要添加-virtual-关键字？" class="headerlink" title="为什么类中的析构函数通常都要添加 virtual 关键字？"></a>为什么类中的析构函数通常都要添加 virtual 关键字？</h5></li></ul><p>是为了正确调用子类的析构函数，不引发子类对象析构时的错误。</p><p>在父类中没有添加virtual的析构函数时，父类指针指向子类对象并析构子类对象时，只调用父类的虚构函数，导致错误的析构。</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;class Base{public:    Base() {}; //Base的构造函数    ~Base()   //Base的析构函数    {        cout &lt;&lt; &quot;Output from the destructor of class Base!&quot; &lt;&lt; endl;    };    virtual void DoSomething()    {        cout &lt;&lt; &quot;Do something in class Base!&quot; &lt;&lt; endl;    };};class Derived : public Base{public:    Derived() {}; //Derived的构造函数    ~Derived() //Derived的析构函数    {        cout &lt;&lt; &quot;Output from the destructor of class Derived!&quot; &lt;&lt; endl;    };    void DoSomething()    {        cout &lt;&lt; &quot;Do something in class Derived!&quot; &lt;&lt; endl;    };};int main(){    Derived *pTest1 = new Derived(); //Derived类的指针    pTest1-&gt;DoSomething();    delete pTest1;    cout &lt;&lt; endl;    Base *pTest2 = new Derived(); //Base类的指针    pTest2-&gt;DoSomething();    delete pTest2;    return 0;}// 输出结果1 Do something in class Derived!2 Output from the destructor of class Derived!3 Output from the destructor of class Base!4 5 Do something in class Derived!6 Output from the destructor of class Base!</code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><hr><p>运算符重载的左侧的操作数是调用的对象。</p><p>所以对于成员方法的运算符重载，那么左侧的操作数是 this，并不是第一个参数。</p><ul><li><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5></li></ul><p>只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型</p><p>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。</p><h3 id="动态绑定和静态绑定"><a href="#动态绑定和静态绑定" class="headerlink" title="动态绑定和静态绑定"></a>动态绑定和静态绑定</h3><hr><p>动态绑定就是程序在执行时才确定具体的操作，我认为动态绑定是动态存储区(heap)申请内存；静态绑定（即在编译时刻已经确定程序的大小）是在静态存储区存放大小。</p><p>在 C 中 malloc 实现动态存储区的申请。</p><p>在 C++ 中 new 实现动态存储区的申请。</p><p>静态绑定的执行效率优于动态绑定的执行效率。</p><ul><li><h5 id="虚函数表的存储空间在哪呢？"><a href="#虚函数表的存储空间在哪呢？" class="headerlink" title="虚函数表的存储空间在哪呢？"></a>虚函数表的存储空间在哪呢？</h5></li></ul><p>我觉得是动态存储区，因为只有实例化对象时，虚函数表才能生成，并不是编译时刻就确定好。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><hr><p>智能指针在结束对象的生存期，智能释放指针指向的存储空间，不会产生内存泄露问题。相对于普通指针，更加安全。</p><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><hr><p>重写与重载：</p><ul><li>方法的重写 Overriding 和重载 Overloading 是多态性的不同表现。</li><li>重写 Overriding 是父类与子类之间多态性的一种表现，</li><li>重载 Overloading 是一个类中多态性的一种表现。</li><li>如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。</li><li>子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；</li><li>如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。<br>Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同</li></ul><p>定义：malloc 和free是分配和释放一块内存，构建对象时不会自动调用构造和析构函数，而new和delete是建立和释放一个对象，构建对象时会自动调用构造和析构函数。</p><h3 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h3><hr><ul><li>左值和右值</li><li>左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；</li><li>右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。<br>-一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。</li></ul><p>对象的初始化， 和赋值不一样 </p><pre><code class="c++">A a = b;     //    调用a的拷贝构造函数A a;a = b;  //调用操作符重载=函数, </code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><hr><h5 id="带指针的类和不带指针的类"><a href="#带指针的类和不带指针的类" class="headerlink" title="带指针的类和不带指针的类"></a>带指针的类和不带指针的类</h5><ul><li><em>class with pointer member</em> 必须有 拷贝构造 和拷贝赋值 </li><li><strong>&amp; 有不同意义， 取地址和声明参数引用。</strong></li></ul><h5 id="对象类型："><a href="#对象类型：" class="headerlink" title="对象类型："></a>对象类型：</h5><ul><li><em>local objects （auto object）： Complex c2();</em></li><li><em>static objects</em>：其生命在作用域结束后仍然存在，知道整个程序结束。</li><li><em>global objects</em></li><li><em>heap objects</em></li></ul><h5 id="using-编译指令："><a href="#using-编译指令：" class="headerlink" title="using 编译指令："></a>using 编译指令：</h5><ul><li>在多函数程序中使用using编译指令，这是因为函数都使用了 <em>cout</em>， 因此需要能够访问位于命名空间std的 <em>cout</em> 定义 。</li><li><em>using namespace std</em>； 放在特定的函数定义中， 能够然这个函数使用命名空间std所有元素</li><li><em>namespace</em> 和  <em>Java</em> 的 包类似</li></ul><h5 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h5><ul><li>函数原型作为黑盒的函数</li><li>函数原型 prototype</li></ul><h5 id="成员函数："><a href="#成员函数：" class="headerlink" title="成员函数："></a>成员函数：</h5><ul><li>成员函数有一个this 的指针，this 是一个隐含的指针，不能被显示声明，它只是一个形参，一个局部变量。</li></ul><h5 id="static"><a href="#static" class="headerlink" title="static :"></a><em>static :</em></h5><ul><li><em>static data</em> 要 <em>static</em> 函数处理</li><li><em>static</em> 成员函数 和 成员函数区别：没有 <em>this pointer</em></li><li><em>static</em> 函数调用方式： <em>object</em> 调用 和 <em>class name</em> 调用</li></ul><h5 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a><em>Inheritance</em></h5><ul><li>继承成员变量</li><li>继承成员函数的调用权</li></ul><h5 id="vitual"><a href="#vitual" class="headerlink" title="vitual"></a><em>vitual</em></h5><ul><li><em>pure vitual</em></li><li><em>impure virtual</em></li><li><em>non-virtual</em></li></ul><h5 id="为什么需要原型"><a href="#为什么需要原型" class="headerlink" title="为什么需要原型"></a>为什么需要原型</h5><ul><li><h5 id="原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。-如-double-volume-cube（side）；"><a href="#原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。-如-double-volume-cube（side）；" class="headerlink" title="原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。    如 double volume  = cube（side）；"></a>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。    如 double volume  = cube（side）；</h5></li></ul><h5 id="原型的功能"><a href="#原型的功能" class="headerlink" title="原型的功能"></a>原型的功能</h5><ul><li>原型可以帮组编译器完成许多工作。</li><li>编译器正确处理函数返回值</li><li>编译器检查使用的参数数目是否正确</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="程序语言" scheme="https://www.daihuiyou.top/tags/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://www.daihuiyou.top/2018/08/28/Git/"/>
    <id>https://www.daihuiyou.top/2018/08/28/Git/</id>
    <published>2018-08-28T07:35:41.000Z</published>
    <updated>2019-06-11T11:09:51.510Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="GitHub基本概念"><a href="#GitHub基本概念" class="headerlink" title="GitHub基本概念"></a>GitHub基本概念</h3><ul><li><strong><em>Repository</em></strong>： 开源项目</li><li><strong><em>Issue</em></strong>： 在开源项目中，别人发现你的项目有Bug，或者某些地方做的不够好，他就可以给你提个<strong><em>Issue</em></strong> ，然后这些问题逐个去修复，即一个一个<strong><em>Close</em></strong>掉。</li><li><strong><em>Star</em></strong>：关注</li><li><strong><em>Fork</em></strong>：引用别人的开源项目</li><li><strong><em>Pull Request</em></strong>：在<strong><em>Fork</em></strong>的基础上，有更好的改进，提交给本开源项目的人，他收到请求后，仔细阅读你的提交的代码，即 <strong><em>review</em></strong>, 就接受你的<strong><em>Pull Request</em></strong>。</li><li><strong><em>Watch</em></strong>： <strong><em>Watch</em></strong>了该项目，它的任何更新消息，会通知你。</li><li><strong><em>Gist</em></strong>： 单纯分享代码段。</li></ul><h3 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h3><p>ssh-keygen -t rsa ： 就是指定 rsa 算法生成密钥，接着连续三个回车键，生成两个文件id_rsa和id_ras.pub, id_rsa.pub就是公钥，对应的id_rsa是私钥。  </p><p>将id_rsa.pub添加到GitHub上。这样就可以把Git和GitHub同步上了。</p><h3 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h3><p>git push origin master : 把本地代码推到远程master分支。  </p><p>git pull origin master : 远程master的最新代码拉下来。</p><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:daihuiyou/Material.git: 本地有仓库，修改很多次，需要更改为远程仓库地址。  </p><p>在提交代码之前，先要设置自己的用户名与邮箱，这些信息会出现所有的commit记录里  </p><pre><code>git config -global user.name &quot;daihuiyou&quot;  git config -global user.eamil &quot;daihuiyou.dev@gmail.com&quot;</code></pre><p> <strong><em>Pull requests</em></strong>： 我们每个人都可以一起参与开发，一起来完善，而这都通过<strong><em>Pull requestss</em></strong>来完成。  </p><ul><li><strong><em>fork</em></strong> 他人项目</li><li><strong><em>git clone</em></strong> （fork 来项目）</li><li>在本地，自己修改这个项目</li><li><strong><em>git push</em></strong> 到自己远程仓库</li><li><strong><em>Pull requests</em></strong> 到 他人项目上</li><li>他人 <strong><em>reviews</em></strong> 你在他项目修改什么， 并觉得合理， 就接受你的PR。</li><li>完成这个项目的贡献。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.daihuiyou.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.daihuiyou.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>学会提问</title>
    <link href="https://www.daihuiyou.top/2018/08/21/%E5%AD%A6%E4%BC%9A%E6%8F%90%E9%97%AE/"/>
    <id>https://www.daihuiyou.top/2018/08/21/学会提问/</id>
    <published>2018-08-21T04:19:37.000Z</published>
    <updated>2019-05-28T02:33:14.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日常上，我在网络上几乎不评论某些看法和表达自己的看法。因为心理上，我想成为信息的接受者，这样舒服，不必费劲，不必评论，不必打字。哈哈哈，发现自己懒癌已经不轻了。</p><p>但是我自己看了在微信，知乎看了许许多多的文章，我发现只有自己觉得认同的，通常不会再多考虑作者的理由是否妥当，就贸然接受其结论。 我认为这样不好，没有属于自己的思想。 </p><p>看完《学会提问》，批判性思维是重要的，克服自己的懒癌，不想是信息的接受者，而是信息的筛选者，还要是敢于表达自己的观点和想法。</p><h3 id="读书摘抄"><a href="#读书摘抄" class="headerlink" title="读书摘抄"></a>读书摘抄</h3><p><strong>价值观</strong>：  </p><ol><li>苏格拉底说过的话:”我唯一所知的就是我一无所知。”  </li><li>找不到作者的结论，你就会曲解别人的意图，这样做出的回应也显得驴唇不对马嘴。</li></ol><p>关键问题：论题和结论。</p><p>没有把证据支撑的断言称为纯观点。</p><p>写作建议：在写作之前最好确定好论题，引导读者得出你的结论</p><p>如果你没找到这些潜在的联系，你常常会发现自己不知不觉就相信了一些观点，这些观点稍加考虑的话就绝不会接受。  </p><p>一个论证的表面结构由理由和结论两部分组成。</p><p>我们把没有明说出来的想法成为假设。</p><p>先检查理由，然后检查结论，寻找价值观假设和描述性假设。  </p><p>假设越可疑，推理和结论的相关程度也就越小。</p><p>用证据证明一件事引起另一件事发生的过程里常见的一个难题–替代原因。</p><p>单一的个人经历，甚至是个人经历的总和，根本不足以构成一个代表性的经历样本。</p><ul><li>价值观是：人这辈子觉得什么是最珍贵的。例如 价值观：我喜欢团队合作，不喜欢竞争，不喜欢办公室文化。  </li><li>价值观假设：就是在特定情形下没有明说的出来的喜欢一种价值观超过另一种价值观的偏向。</li><li>谬误，就是推理中的欺骗手段，作者有肯恩利用这个欺骗手段来说服你采纳结论。</li><li>过度简化因果关系谬误指 依赖并不足解释整个事件的具有因果关系的因素来解释一个事件，或者过分强调这些因素的一个或多个因素的作用。  </li><li>以偏概全谬误指一个人仅根据群体中极小部分人的经历就得出有关整个群体的结论。</li><li>循环论证谬误指在推理过程中已然假设自己的结论成立的论证。</li><li>人生攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Share" scheme="https://www.daihuiyou.top/categories/Share/"/>
    
    
      <category term="Share" scheme="https://www.daihuiyou.top/tags/Share/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建流程</title>
    <link href="https://www.daihuiyou.top/2018/08/20/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.daihuiyou.top/2018/08/20/hexo博客搭建流程/</id>
    <published>2018-08-20T06:03:47.000Z</published>
    <updated>2019-06-18T03:06:57.658Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记录总体的搭建流程"><a href="#记录总体的搭建流程" class="headerlink" title="记录总体的搭建流程"></a>记录总体的搭建流程</h2><ol><li>搭建Node.js环境：命令行使用<strong>node -v</strong>查看版本。</li><li>安装Hexo博客框架：<strong>npm install hexo-cli -g</strong></li><li><strong>安装git, git同步在github上</strong>。</li><li>开启GitHub Pages服务： <strong>注意要选择主题，才有效。</strong></li><li>创建文件夹，存放博客文件： hexo init  myHexoBlog   </li><li>hexo g  //g是generetor的缩写，生成博客</li><li>hexo s  //s是server的缩写，启动服务</li><li><strong>hexo与github关联起来</strong></li><li>绑定域名</li><li>更换主题</li></ol><hr><h2 id="安装git-git同步在github上"><a href="#安装git-git同步在github上" class="headerlink" title="安装git, git同步在github上"></a>安装git, git同步在github上</h2><pre><code>git config --global user.name &quot;你的GitHub用户名&quot;git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></pre><ol><li><strong>生成ssh密钥文件：</strong>ssh-keygen -t rsa -C “你的GitHub注册邮箱”</li><li>然后找到生成的.ssh的文件夹中的id_rsa.pub密钥，将内容全部复制</li><li>打开GitHub_Settings_keys 页面，新建new SSH Key</li><li>在Git Bash中检测GitHub公钥设置是否成功，输入 <strong>ssh <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> </strong></li></ol><hr><h2 id="hexo与github关联起来：打开站点的配置文件-config-yml"><a href="#hexo与github关联起来：打开站点的配置文件-config-yml" class="headerlink" title="hexo与github关联起来：打开站点的配置文件_config.yml"></a>hexo与github关联起来：打开站点的配置文件_config.yml</h2><pre><code>deploy:      type: git      repository: git@github.com:DaiHuiYou/DaiHuiYou.github.io.git      branch: master</code></pre><hr><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><pre><code>ping www.daihuiyou.github.io #得到IP值</code></pre><p> 第一步：在阿里云解析服务： 填写</p><pre><code>主机记录www对应 daihuiyou.github.io主机记录@对应 www.daihuiyou.github.io主机记录www对应 185.199.111.153主机记录@对应 185.199.111.153</code></pre><p> 第二步：登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名 daihuiyou.top</p><p> 第三步：进入本地博客文件夹 ，进入blog/source目录下，创建一个CNAME，编辑内容为daihuiyou.top</p><hr><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>待更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="博客" scheme="https://www.daihuiyou.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://www.daihuiyou.top/2018/08/19/My-New-Post/"/>
    <id>https://www.daihuiyou.top/2018/08/19/My-New-Post/</id>
    <published>2018-08-18T16:06:36.000Z</published>
    <updated>2019-05-28T02:33:25.420Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Have-a-good-day"><a href="#Have-a-good-day" class="headerlink" title="Have a good day!"></a>Have a good day!</h4><h4 id="Cease-to-struggle-and-you-cease-to-live"><a href="#Cease-to-struggle-and-you-cease-to-live" class="headerlink" title="Cease to struggle and you cease to live."></a>Cease to struggle and you cease to live.</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="开篇" scheme="https://www.daihuiyou.top/categories/%E5%BC%80%E7%AF%87/"/>
    
    
      <category term="the first post." scheme="https://www.daihuiyou.top/tags/the-first-post/"/>
    
  </entry>
  
</feed>
